# DO NOT EDIT MANUALLY! FW2 VERSION
# Automatically generated on Wed Aug 15 19:32:42 2018 from firmware 0.0.0
SECTION "Config Data Entries" 0
{
     COMMAND "Config layout" 0x0100
     {
         doc "This includes its layout and properties of the physical media holding it."
             "This item is used in the static section."
         PARAM "Failsafe dynamic section base address"
             uint32
             doc "Base address or offset of the failsafe (not upgradable) dynamic section base."
                 "This field must be present.";
         PARAM "Upgradable dynamic section base address"
             uint32
             doc "Base address or offset of the upgradable dynamic section base."
                 "This field is optional for media types for which DFU is supported.";
         PARAM "Volatile section copy1 base address"
             uint32
             doc "Base address or offset to the area reserved for volatile section copy 1. Whether this is an"
                 "address or offset depends on the media type, and is an internal detail of those media types"
                 "access functions.  Double-buffering of the volatile section alternates between the two"
                 "copies when the active copy fills up and has to be consolidated to the other.  The volatile"
                 "section stores information that is mutable at runtime, and is therefore subject to loss if a"
                 "write operation is interrupted by loss of power.  Only an item that is currently being"
                 "written is subject to loss.  Generally, NVRAM media with large page sizes (like flash) use"
                 "double-buffering, while media with small page sizes (like EEPROM) allocate one or more"
                 "complete pages per volatile section item.";
         PARAM "Volatile section copy2 base address"
             uint32
             doc "Base address or offset to the area reserved for volatile section copy 2.  Whether this is an"
                 "address or offset depends on the media type, and is an internal detail of those media types"
                 "access functions.  See the documentation for vs_copy1_base, but note that not all media"
                 "types use double-buffering.";
         PARAM "Volatile section length per copy"
             uint32
             doc "Length in bytes per copy of the area reserved for each volatile section copy.  If the target"
                 "media uses double buffering to protect against loss, the total space used by the volatile"
                 "section is twice this amount.  See the documentation for vs_copy1_base and vs_copy1_base.";
         PARAM "Volatile section block size"
             uint32
             doc "Block size for volatile section items.  For media with small page sizes (like EEPROM) which"
                 "allocate one or more pages per volatile section item, blocks must be a multiple of the media"
                 "page size.";
         PARAM "Media page size"
             uint32
             doc "This info is needed for managing volatile section contents.";
     }

     COMMAND "Crystal frequency KHz" 0x0101
     {
         doc "Config item code used for config data to notify firmware of the frequency of the crystal."
             "This is used so that firmware does not have to (or if firmware cannot) measure the frequency."
         PARAM "Config crystal frequency KHz"
             uint32
             doc "Config item code used for config data to notify firmware of the frequency of the crystal.";
     }

     COMMAND "Init BB Register Bit Fields" 0x0102
     {
         doc "Config item code used to poke hardware register values to optimize system performance"
             "This config item is used to overwrite the selected bit fields of the "
             "BB register default values during firmware initialization."
         PARAM "Num entries"
             uint16
             doc "An abstract parameter used only for encoding purposes, not present in the"
                 "actual configuration item. When encoding the configuration item, determines"
                 "the number of address/mask/value entries to include."
             not_in_binary_message
             decode_value = 0                                    # Can only decode, not encode
             max = 86;                #Make sure this value doesnt go above <PARAM "Num entries"> data type
         PARAM "Register address[0]"
             uint32
             doc "Address of the baseband register"
             present_if ("Num entries" > 0);
         PARAM "Bit field mask[0]"
             uint32
             doc "Bit field mask. If a bit is 1 that bit value will be changed to the new value"
                 "specified"
             present_if ("Num entries" > 0);
         PARAM "Value[0]"
             uint32
             doc "Data to be written to the baseband register"
             present_if ("Num entries" > 0);
         PARAM "Register address[1]"
             uint32
             present_if ("Num entries" > 1);
         PARAM "Bit field mask[1]"
             uint32
             present_if ("Num entries" > 1);
         PARAM "Value[1]"
             uint32
             present_if ("Num entries" > 1);
         PARAM "Register address[2]"
             uint32
             present_if ("Num entries" > 2);
         PARAM "Bit field mask[2]"
             uint32
             present_if ("Num entries" > 2);
         PARAM "Value[2]"
             uint32
             present_if ("Num entries" > 2);
         PARAM "Register address[3]"
             uint32
             present_if ("Num entries" > 3);
         PARAM "Bit field mask[3]"
             uint32
             present_if ("Num entries" > 3);
         PARAM "Value[3]"
             uint32
             present_if ("Num entries" > 3);
         PARAM "Register address[4]"
             uint32
             present_if ("Num entries" > 4);
         PARAM "Bit field mask[4]"
             uint32
             present_if ("Num entries" > 4);
         PARAM "Value[4]"
             uint32
             present_if ("Num entries" > 4);
         PARAM "Register address[5]"
             uint32
             present_if ("Num entries" > 5);
         PARAM "Bit field mask[5]"
             uint32
             present_if ("Num entries" > 5);
         PARAM "Value[5]"
             uint32
             present_if ("Num entries" > 5);
         PARAM "Register address[6]"
             uint32
             present_if ("Num entries" > 6);
         PARAM "Bit field mask[6]"
             uint32
             present_if ("Num entries" > 6);
         PARAM "Value[6]"
             uint32
             present_if ("Num entries" > 6);
         PARAM "Register address[7]"
             uint32
             present_if ("Num entries" > 7);
         PARAM "Bit field mask[7]"
             uint32
             present_if ("Num entries" > 7);
         PARAM "Value[7]"
             uint32
             present_if ("Num entries" > 7);
         PARAM "Register address[8]"
             uint32
             present_if ("Num entries" > 8);
         PARAM "Bit field mask[8]"
             uint32
             present_if ("Num entries" > 8);
         PARAM "Value[8]"
             uint32
             present_if ("Num entries" > 8);
         PARAM "Register address[9]"
             uint32
             present_if ("Num entries" > 9);
         PARAM "Bit field mask[9]"
             uint32
             present_if ("Num entries" > 9);
         PARAM "Value[9]"
             uint32
             present_if ("Num entries" > 9);
         PARAM "Register address[10]"
             uint32
             present_if ("Num entries" > 10);
         PARAM "Bit field mask[10]"
             uint32
             present_if ("Num entries" > 10);
         PARAM "Value[10]"
             uint32
             present_if ("Num entries" > 10);
         PARAM "Register address[11]"
             uint32
             present_if ("Num entries" > 11);
         PARAM "Bit field mask[11]"
             uint32
             present_if ("Num entries" > 11);
         PARAM "Value[11]"
             uint32
             present_if ("Num entries" > 11);
         PARAM "Register address[12]"
             uint32
             present_if ("Num entries" > 12);
         PARAM "Bit field mask[12]"
             uint32
             present_if ("Num entries" > 12);
         PARAM "Value[12]"
             uint32
             present_if ("Num entries" > 12);
         PARAM "Register address[13]"
             uint32
             present_if ("Num entries" > 13);
         PARAM "Bit field mask[13]"
             uint32
             present_if ("Num entries" > 13);
         PARAM "Value[13]"
             uint32
             present_if ("Num entries" > 13);
         PARAM "Register address[14]"
             uint32
             present_if ("Num entries" > 14);
         PARAM "Bit field mask[14]"
             uint32
             present_if ("Num entries" > 14);
         PARAM "Value[14]"
             uint32
             present_if ("Num entries" > 14);
         PARAM "Register address[15]"
             uint32
             present_if ("Num entries" > 15);
         PARAM "Bit field mask[15]"
             uint32
             present_if ("Num entries" > 15);
         PARAM "Value[15]"
             uint32
             present_if ("Num entries" > 15);
         PARAM "Register address[16]"
             uint32
             present_if ("Num entries" > 16);
         PARAM "Bit field mask[16]"
             uint32
             present_if ("Num entries" > 16);
         PARAM "Value[16]"
             uint32
             present_if ("Num entries" > 16);
         PARAM "Register address[17]"
             uint32
             present_if ("Num entries" > 17);
         PARAM "Bit field mask[17]"
             uint32
             present_if ("Num entries" > 17);
         PARAM "Value[17]"
             uint32
             present_if ("Num entries" > 17);
         PARAM "Register address[18]"
             uint32
             present_if ("Num entries" > 18);
         PARAM "Bit field mask[18]"
             uint32
             present_if ("Num entries" > 18);
         PARAM "Value[18]"
             uint32
             present_if ("Num entries" > 18);
         PARAM "Register address[19]"
             uint32
             present_if ("Num entries" > 19);
         PARAM "Bit field mask[19]"
             uint32
             present_if ("Num entries" > 19);
         PARAM "Value[19]"
             uint32
             present_if ("Num entries" > 19);
         PARAM "Register address[20]"
             uint32
             present_if ("Num entries" > 20);
         PARAM "Bit field mask[20]"
             uint32
             present_if ("Num entries" > 20);
         PARAM "Value[20]"
             uint32
             present_if ("Num entries" > 20);
         PARAM "Register address[21]"
             uint32
             present_if ("Num entries" > 21);
         PARAM "Bit field mask[21]"
             uint32
             present_if ("Num entries" > 21);
         PARAM "Value[21]"
             uint32
             present_if ("Num entries" > 21);
         PARAM "Register address[22]"
             uint32
             present_if ("Num entries" > 22);
         PARAM "Bit field mask[22]"
             uint32
             present_if ("Num entries" > 22);
         PARAM "Value[22]"
             uint32
             present_if ("Num entries" > 22);
         PARAM "Register address[23]"
             uint32
             present_if ("Num entries" > 23);
         PARAM "Bit field mask[23]"
             uint32
             present_if ("Num entries" > 23);
         PARAM "Value[23]"
             uint32
             present_if ("Num entries" > 23);
         PARAM "Register address[24]"
             uint32
             present_if ("Num entries" > 24);
         PARAM "Bit field mask[24]"
             uint32
             present_if ("Num entries" > 24);
         PARAM "Value[24]"
             uint32
             present_if ("Num entries" > 24);
         PARAM "Register address[25]"
             uint32
             present_if ("Num entries" > 25);
         PARAM "Bit field mask[25]"
             uint32
             present_if ("Num entries" > 25);
         PARAM "Value[25]"
             uint32
             present_if ("Num entries" > 25);
         PARAM "Register address[26]"
             uint32
             present_if ("Num entries" > 26);
         PARAM "Bit field mask[26]"
             uint32
             present_if ("Num entries" > 26);
         PARAM "Value[26]"
             uint32
             present_if ("Num entries" > 26);
         PARAM "Register address[27]"
             uint32
             present_if ("Num entries" > 27);
         PARAM "Bit field mask[27]"
             uint32
             present_if ("Num entries" > 27);
         PARAM "Value[27]"
             uint32
             present_if ("Num entries" > 27);
         PARAM "Register address[28]"
             uint32
             present_if ("Num entries" > 28);
         PARAM "Bit field mask[28]"
             uint32
             present_if ("Num entries" > 28);
         PARAM "Value[28]"
             uint32
             present_if ("Num entries" > 28);
         PARAM "Register address[29]"
             uint32
             present_if ("Num entries" > 29);
         PARAM "Bit field mask[29]"
             uint32
             present_if ("Num entries" > 29);
         PARAM "Value[29]"
             uint32
             present_if ("Num entries" > 29);
         PARAM "Register address[30]"
             uint32
             present_if ("Num entries" > 30);
         PARAM "Bit field mask[30]"
             uint32
             present_if ("Num entries" > 30);
         PARAM "Value[30]"
             uint32
             present_if ("Num entries" > 30);
         PARAM "Register address[31]"
             uint32
             present_if ("Num entries" > 31);
         PARAM "Bit field mask[31]"
             uint32
             present_if ("Num entries" > 31);
         PARAM "Value[31]"
             uint32
             present_if ("Num entries" > 31);
         PARAM "Register address[32]"
             uint32
             present_if ("Num entries" > 32);
         PARAM "Bit field mask[32]"
             uint32
             present_if ("Num entries" > 32);
         PARAM "Value[32]"
             uint32
             present_if ("Num entries" > 32);
         PARAM "Register address[33]"
             uint32
             present_if ("Num entries" > 33);
         PARAM "Bit field mask[33]"
             uint32
             present_if ("Num entries" > 33);
         PARAM "Value[33]"
             uint32
             present_if ("Num entries" > 33);
         PARAM "Register address[34]"
             uint32
             present_if ("Num entries" > 34);
         PARAM "Bit field mask[34]"
             uint32
             present_if ("Num entries" > 34);
         PARAM "Value[34]"
             uint32
             present_if ("Num entries" > 34);
         PARAM "Register address[35]"
             uint32
             present_if ("Num entries" > 35);
         PARAM "Bit field mask[35]"
             uint32
             present_if ("Num entries" > 35);
         PARAM "Value[35]"
             uint32
             present_if ("Num entries" > 35);
         PARAM "Register address[36]"
             uint32
             present_if ("Num entries" > 36);
         PARAM "Bit field mask[36]"
             uint32
             present_if ("Num entries" > 36);
         PARAM "Value[36]"
             uint32
             present_if ("Num entries" > 36);
         PARAM "Register address[37]"
             uint32
             present_if ("Num entries" > 37);
         PARAM "Bit field mask[37]"
             uint32
             present_if ("Num entries" > 37);
         PARAM "Value[37]"
             uint32
             present_if ("Num entries" > 37);
         PARAM "Register address[38]"
             uint32
             present_if ("Num entries" > 38);
         PARAM "Bit field mask[38]"
             uint32
             present_if ("Num entries" > 38);
         PARAM "Value[38]"
             uint32
             present_if ("Num entries" > 38);
         PARAM "Register address[39]"
             uint32
             present_if ("Num entries" > 39);
         PARAM "Bit field mask[39]"
             uint32
             present_if ("Num entries" > 39);
         PARAM "Value[39]"
             uint32
             present_if ("Num entries" > 39);
         PARAM "Register address[40]"
             uint32
             present_if ("Num entries" > 40);
         PARAM "Bit field mask[40]"
             uint32
             present_if ("Num entries" > 40);
         PARAM "Value[40]"
             uint32
             present_if ("Num entries" > 40);
         PARAM "Register address[41]"
             uint32
             present_if ("Num entries" > 41);
         PARAM "Bit field mask[41]"
             uint32
             present_if ("Num entries" > 41);
         PARAM "Value[41]"
             uint32
             present_if ("Num entries" > 41);
         PARAM "Register address[42]"
             uint32
             present_if ("Num entries" > 42);
         PARAM "Bit field mask[42]"
             uint32
             present_if ("Num entries" > 42);
         PARAM "Value[42]"
             uint32
             present_if ("Num entries" > 42);
         PARAM "Register address[43]"
             uint32
             present_if ("Num entries" > 43);
         PARAM "Bit field mask[43]"
             uint32
             present_if ("Num entries" > 43);
         PARAM "Value[43]"
             uint32
             present_if ("Num entries" > 43);
         PARAM "Register address[44]"
             uint32
             present_if ("Num entries" > 44);
         PARAM "Bit field mask[44]"
             uint32
             present_if ("Num entries" > 44);
         PARAM "Value[44]"
             uint32
             present_if ("Num entries" > 44);
         PARAM "Register address[45]"
             uint32
             present_if ("Num entries" > 45);
         PARAM "Bit field mask[45]"
             uint32
             present_if ("Num entries" > 45);
         PARAM "Value[45]"
             uint32
             present_if ("Num entries" > 45);
         PARAM "Register address[46]"
             uint32
             present_if ("Num entries" > 46);
         PARAM "Bit field mask[46]"
             uint32
             present_if ("Num entries" > 46);
         PARAM "Value[46]"
             uint32
             present_if ("Num entries" > 46);
         PARAM "Register address[47]"
             uint32
             present_if ("Num entries" > 47);
         PARAM "Bit field mask[47]"
             uint32
             present_if ("Num entries" > 47);
         PARAM "Value[47]"
             uint32
             present_if ("Num entries" > 47);
         PARAM "Register address[48]"
             uint32
             present_if ("Num entries" > 48);
         PARAM "Bit field mask[48]"
             uint32
             present_if ("Num entries" > 48);
         PARAM "Value[48]"
             uint32
             present_if ("Num entries" > 48);
         PARAM "Register address[49]"
             uint32
             present_if ("Num entries" > 49);
         PARAM "Bit field mask[49]"
             uint32
             present_if ("Num entries" > 49);
         PARAM "Value[49]"
             uint32
             present_if ("Num entries" > 49);
         PARAM "Register address[50]"
             uint32
             present_if ("Num entries" > 50);
         PARAM "Bit field mask[50]"
             uint32
             present_if ("Num entries" > 50);
         PARAM "Value[50]"
             uint32
             present_if ("Num entries" > 50);
         PARAM "Register address[51]"
             uint32
             present_if ("Num entries" > 51);
         PARAM "Bit field mask[51]"
             uint32
             present_if ("Num entries" > 51);
         PARAM "Value[51]"
             uint32
             present_if ("Num entries" > 51);
         PARAM "Register address[52]"
             uint32
             present_if ("Num entries" > 52);
         PARAM "Bit field mask[52]"
             uint32
             present_if ("Num entries" > 52);
         PARAM "Value[52]"
             uint32
             present_if ("Num entries" > 52);
         PARAM "Register address[53]"
             uint32
             present_if ("Num entries" > 53);
         PARAM "Bit field mask[53]"
             uint32
             present_if ("Num entries" > 53);
         PARAM "Value[53]"
             uint32
             present_if ("Num entries" > 53);
         PARAM "Register address[54]"
             uint32
             present_if ("Num entries" > 54);
         PARAM "Bit field mask[54]"
             uint32
             present_if ("Num entries" > 54);
         PARAM "Value[54]"
             uint32
             present_if ("Num entries" > 54);
         PARAM "Register address[55]"
             uint32
             present_if ("Num entries" > 55);
         PARAM "Bit field mask[55]"
             uint32
             present_if ("Num entries" > 55);
         PARAM "Value[55]"
             uint32
             present_if ("Num entries" > 55);
         PARAM "Register address[56]"
             uint32
             present_if ("Num entries" > 56);
         PARAM "Bit field mask[56]"
             uint32
             present_if ("Num entries" > 56);
         PARAM "Value[56]"
             uint32
             present_if ("Num entries" > 56);
         PARAM "Register address[57]"
             uint32
             present_if ("Num entries" > 57);
         PARAM "Bit field mask[57]"
             uint32
             present_if ("Num entries" > 57);
         PARAM "Value[57]"
             uint32
             present_if ("Num entries" > 57);
         PARAM "Register address[58]"
             uint32
             present_if ("Num entries" > 58);
         PARAM "Bit field mask[58]"
             uint32
             present_if ("Num entries" > 58);
         PARAM "Value[58]"
             uint32
             present_if ("Num entries" > 58);
         PARAM "Register address[59]"
             uint32
             present_if ("Num entries" > 59);
         PARAM "Bit field mask[59]"
             uint32
             present_if ("Num entries" > 59);
         PARAM "Value[59]"
             uint32
             present_if ("Num entries" > 59);
         PARAM "Register address[60]"
             uint32
             present_if ("Num entries" > 60);
         PARAM "Bit field mask[60]"
             uint32
             present_if ("Num entries" > 60);
         PARAM "Value[60]"
             uint32
             present_if ("Num entries" > 60);
         PARAM "Register address[61]"
             uint32
             present_if ("Num entries" > 61);
         PARAM "Bit field mask[61]"
             uint32
             present_if ("Num entries" > 61);
         PARAM "Value[61]"
             uint32
             present_if ("Num entries" > 61);
         PARAM "Register address[62]"
             uint32
             present_if ("Num entries" > 62);
         PARAM "Bit field mask[62]"
             uint32
             present_if ("Num entries" > 62);
         PARAM "Value[62]"
             uint32
             present_if ("Num entries" > 62);
         PARAM "Register address[63]"
             uint32
             present_if ("Num entries" > 63);
         PARAM "Bit field mask[63]"
             uint32
             present_if ("Num entries" > 63);
         PARAM "Value[63]"
             uint32
             present_if ("Num entries" > 63);
         PARAM "Register address[64]"
             uint32
             present_if ("Num entries" > 64);
         PARAM "Bit field mask[64]"
             uint32
             present_if ("Num entries" > 64);
         PARAM "Value[64]"
             uint32
             present_if ("Num entries" > 64);
         PARAM "Register address[65]"
             uint32
             present_if ("Num entries" > 65);
         PARAM "Bit field mask[65]"
             uint32
             present_if ("Num entries" > 65);
         PARAM "Value[65]"
             uint32
             present_if ("Num entries" > 65);
         PARAM "Register address[66]"
             uint32
             present_if ("Num entries" > 66);
         PARAM "Bit field mask[66]"
             uint32
             present_if ("Num entries" > 66);
         PARAM "Value[66]"
             uint32
             present_if ("Num entries" > 66);
         PARAM "Register address[67]"
             uint32
             present_if ("Num entries" > 67);
         PARAM "Bit field mask[67]"
             uint32
             present_if ("Num entries" > 67);
         PARAM "Value[67]"
             uint32
             present_if ("Num entries" > 67);
         PARAM "Register address[68]"
             uint32
             present_if ("Num entries" > 68);
         PARAM "Bit field mask[68]"
             uint32
             present_if ("Num entries" > 68);
         PARAM "Value[68]"
             uint32
             present_if ("Num entries" > 68);
         PARAM "Register address[69]"
             uint32
             present_if ("Num entries" > 69);
         PARAM "Bit field mask[69]"
             uint32
             present_if ("Num entries" > 69);
         PARAM "Value[69]"
             uint32
             present_if ("Num entries" > 69);
         PARAM "Register address[70]"
             uint32
             present_if ("Num entries" > 70);
         PARAM "Bit field mask[70]"
             uint32
             present_if ("Num entries" > 70);
         PARAM "Value[70]"
             uint32
             present_if ("Num entries" > 70);
         PARAM "Register address[71]"
             uint32
             present_if ("Num entries" > 71);
         PARAM "Bit field mask[71]"
             uint32
             present_if ("Num entries" > 71);
         PARAM "Value[71]"
             uint32
             present_if ("Num entries" > 71);
         PARAM "Register address[72]"
             uint32
             present_if ("Num entries" > 72);
         PARAM "Bit field mask[72]"
             uint32
             present_if ("Num entries" > 72);
         PARAM "Value[72]"
             uint32
             present_if ("Num entries" > 72);
         PARAM "Register address[73]"
             uint32
             present_if ("Num entries" > 73);
         PARAM "Bit field mask[73]"
             uint32
             present_if ("Num entries" > 73);
         PARAM "Value[73]"
             uint32
             present_if ("Num entries" > 73);
         PARAM "Register address[74]"
             uint32
             present_if ("Num entries" > 74);
         PARAM "Bit field mask[74]"
             uint32
             present_if ("Num entries" > 74);
         PARAM "Value[74]"
             uint32
             present_if ("Num entries" > 74);
         PARAM "Register address[75]"
             uint32
             present_if ("Num entries" > 75);
         PARAM "Bit field mask[75]"
             uint32
             present_if ("Num entries" > 75);
         PARAM "Value[75]"
             uint32
             present_if ("Num entries" > 75);
         PARAM "Register address[76]"
             uint32
             present_if ("Num entries" > 76);
         PARAM "Bit field mask[76]"
             uint32
             present_if ("Num entries" > 76);
         PARAM "Value[76]"
             uint32
             present_if ("Num entries" > 76);
         PARAM "Register address[77]"
             uint32
             present_if ("Num entries" > 77);
         PARAM "Bit field mask[77]"
             uint32
             present_if ("Num entries" > 77);
         PARAM "Value[77]"
             uint32
             present_if ("Num entries" > 77);
         PARAM "Register address[78]"
             uint32
             present_if ("Num entries" > 78);
         PARAM "Bit field mask[78]"
             uint32
             present_if ("Num entries" > 78);
         PARAM "Value[78]"
             uint32
             present_if ("Num entries" > 78);
         PARAM "Register address[79]"
             uint32
             present_if ("Num entries" > 79);
         PARAM "Bit field mask[79]"
             uint32
             present_if ("Num entries" > 79);
         PARAM "Value[79]"
             uint32
             present_if ("Num entries" > 79);
         PARAM "Register address[80]"
             uint32
             present_if ("Num entries" > 80);
         PARAM "Bit field mask[80]"
             uint32
             present_if ("Num entries" > 80);
         PARAM "Value[80]"
             uint32
             present_if ("Num entries" > 80);            
         PARAM "Register address[81]"
             uint32
             present_if ("Num entries" > 81);
         PARAM "Bit field mask[81]"
             uint32
             present_if ("Num entries" > 81);
         PARAM "Value[81]"
             uint32
             present_if ("Num entries" > 81);
         PARAM "Register address[82]"
             uint32
             present_if ("Num entries" > 82);
         PARAM "Bit field mask[82]"
             uint32
             present_if ("Num entries" > 82);
         PARAM "Value[82]"
             uint32
             present_if ("Num entries" > 82);
         PARAM "Register address[83]"
             uint32
             present_if ("Num entries" > 83);
         PARAM "Bit field mask[83]"
             uint32
             present_if ("Num entries" > 83);
         PARAM "Value[83]"
             uint32
             present_if ("Num entries" > 83);
         PARAM "Register address[84]"
             uint32
             present_if ("Num entries" > 84);
         PARAM "Bit field mask[84]"
             uint32
             present_if ("Num entries" > 84);
         PARAM "Value[84]"
             uint32
             present_if ("Num entries" > 84);
         PARAM "Register address[85]"
             uint32
             present_if ("Num entries" > 85);
         PARAM "Bit field mask[85]"
             uint32
             present_if ("Num entries" > 85);
         PARAM "Value[85]"
             uint32
             present_if ("Num entries" > 85);
     }

     COMMAND "Data" 0x0103
     {
         doc "Config item code used to write an arbitrary chunk of data to an arbitrary address."
         PARAM "Address"
             uint32
             doc "The address to which the Data bytes are to be loaded.";
         PARAM "Data"
             uint8[0xFF00] omit_pad_bytes
             doc "The data bytes to be loaded to the Address specified. The data with arbitrary length. "
                 "The length is implied by the size of the array specified for data, as in data = {0x01, 0x02}.";
     }

     COMMAND "Compressed data" 0x0104
     {
         doc "Config item code used to write compressed chunk of data. Given that this data will be a part of"
             "an image, there never needs to be a need to encode such an item from an ENTRY: construct.  An"
             "encoder subroutine is still provided just in case."
         PARAM "Address"
             uint32
             doc "The address to which the (decompressed) Data bytes are to be loaded.";
         PARAM "Data"
             uint8[0xFF00] omit_pad_bytes
             doc "The compressed data bytes to be loaded to the Address specified.";
     }

     COMMAND "Register DLL SRAM use" 0x0105
     {
         doc "Config item code used to register the SRAM used by a DLL, which could be a patch or application"
             "DLL loaded from config data."
         PARAM "Address"
             uint32
             doc "The address to which the Data bytes are to be loaded.";
     }

     COMMAND "Function Call" 0x0106
     {
         doc "Config item code used to call a function directly while processing config data. It takes a"
             "single parameter in such an ENTRY: construct, which is function_addresss."
         PARAM "Address"
             uint32
             doc "The address of the function to be called.";
     }

     COMMAND "Dynamic Memory Pool" 0x0107
     {
         doc "Config item code used for configuration of the dynamic memory management module."
         PARAM "Number of pools"
             uint8
             doc "The number of pools that are to be created from the general pools.  The default value is"
                 "DYNAMIC_MEMORY_NUM_POOLS, but we reserve an extra pool control block, in case we need to add"
                 "a block size category from configuration data.  Unless we need to add a new block size"
                 "category pool, config data (.ags, .cgx) should probably just use DYNAMIC_MEMORY_NUM_POOLS"
                 "as a named value for this field.";
         PARAM "Size[0]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 0);
         PARAM "Count[0]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 0);
         PARAM "Die reserve[0]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 0);
         PARAM "Size[1]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 1);
         PARAM "Count[1]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 1);
         PARAM "Die reserve[1]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 1);
         PARAM "Size[2]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 2);
         PARAM "Count[2]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 2);
         PARAM "Die reserve[2]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 2);
         PARAM "Size[3]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 3);
         PARAM "Count[3]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 3);
         PARAM "Die reserve[3]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 3);
         PARAM "Size[4]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 4);
         PARAM "Count[4]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 4);
         PARAM "Die reserve[4]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 4);
         PARAM "Size[5]"
             uint16
             doc "The size of each block in this pool."
             present_if ("Number of pools" > 5);
         PARAM "Count[5]"
             uint8
             doc "The number of blocks in this pool."
             present_if ("Number of pools" > 5);
         PARAM "Die reserve[5]"
             uint8
             doc "The number of blocks in this pool that are reserved for dynamic_memory_AllocateOrDie calls."
                 "This number of reserved blocks cannot be consumed by calls to"
                 "dynamic_memory_AllocateOrReturnNULL, which will return NULL if the block count is below the"
                 "die_reserve threshold."
             present_if ("Number of pools" > 5);
     }

     COMMAND "PMU minimum sleep time" 0x0108
     {
         doc "Config item code used for configuration of the minimum sleep time.  If sleep is allowed by all"
             "participants in the sleep decision, but firmware would need to wake up before this amount of"
             "time has elapsed, fimware won't bother sleeping."
         PARAM "Minimum Sleep time"
             uint32
             doc "Minimum sleep time.";
     }

     COMMAND "PMU Config Flags" 0x0109
     {
         doc "Config item code used for configuration of the PMU flags."
             "This PMU Config map file defines various PMU Configurations as described below."
         PARAM "PMU config flags"
             uint32
             doc "General PMU config bitmap.";
     }

     COMMAND "Lpo Sniff Control" 0x010A
     {
         doc "Specifies the lpo clock drift and whether to use it in sniff mode."
         PARAM "RESERVED"
             uint32{31:17}
             doc "Pad bits included to fill the parameters out to a uint8."
             binary_message_only
             encode_value = 0
             enabled_if (0 = 1);     # Never
    
         PARAM "enable in sniff"
             uint32{ 16:16 }
             doc "use lpo in sniff mode when as a slave.";
    
         PARAM "lpo drift"
             uint32{ 15:0 }
             doc "lpo clock drift. Drift value used to calculate receive window.";
     }

     COMMAND "PMU Crystal Warm up Time" 0x010B
     {
         doc "This item is to overwrite the PMU Crystal Warm up Time in Micro Seconds."
         PARAM "Crystal warm up time"
             uint32
             doc "In micro seconds."
             default = 0xA3;
     }

     COMMAND "PMU PLL Warmup Time" 0x010C
     {
         doc "Config item used for configuration of external PLL warmup time."
         PARAM "PLL warm up time"
             uint32
             doc "External PLL warmup time"
             default = 0x05;
     }

     COMMAND "Sleep Mode Configuration" 0x010D
     {
         doc "Configure how to sleep."
         PARAM "Sleep mode"
             uint8
             doc "Sleep mode algorithm selection."
             enum
             {
                 {0x00, "No sleep mode"},
                 {0x01, "UART"},
                 {0x02, "UART with messaging"},
                 {0x03, "USB"},
                 {0x05, "USB with host wake"},
                 {0x06, "SDIO"},
                 {0x07, "UART CS-N"},
                 {0x08, "SPI"}
             };
         PARAM "Idle threshold host"
             uint8
             doc "Host Idle Threshold, applicable To Sleep Modes 1, 2, 5, 7."
                 "This is the number of firmware loops executed with no activity"
                 "before the Host wake line is deasserted. Activity includes HCI"
                 "traffic excluding certain sleep mode commands and the presence"
                 "of SCO connections if the \"Allow Host Sleep During SCO\" flag is"
                 "not set to 1. Each count of this parameter is roughly equivalent"
                 "to 300 ms. For example, when this parameter is set to 16 (0x10),"
                 "the Host wake line will be deasserted after approximately 4.8"
                 "seconds of inactivity."
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 5) or
                         ("Sleep mode" = 7));
         PARAM "Idle threshold HC"
             uint8
             doc "Host Controller Idle Threshold, applicable To Sleep Modes 1, 2, 3, 5, 6, 7."
                 "This is the number of firmware loops executed with no activity"
                 "before the HC is considered idle. Depending on the mode, HC may"
                 "then attempt to sleep. Activity includes HCI traffic excluding"
                 "certain sleep mode commands and the presence of ACL/SCO connections."
                 "Each count of this parameter is roughly equivalent to 300 ms."
                 "For example, when this parameter is set to 16 (0x10), the HC will"
                 "be considered idle after approximately 4.8 seconds of inactivity."
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                         ("Sleep mode" = 5) or ("Sleep mode" = 6) or ("Sleep mode" = 7));
         PARAM "Enable break to host"
             uint8{7:7}
             doc "Enable break to host.";
         PARAM "Pulse host wake"
             uint8{6:6}
             doc "Pulse host wake.";
         PARAM "Active connection handling on suspend"
             uint8{5:5}
             doc "Suspend Behavior, applicable To Sleep Modes 3, 5."
                 "When set to 0, this flag indicates that upon detecting a USB suspend,"
                 "the device should sleep whenever possible. This means that the device"
                 "will stay up if necessary to maintain active ACL and/or SCO connections,"
                 "and will wake up to perform any scheduled periodic activities if configured to do so."
                 "When set to 1, the device will immediate go to sleep upon detecting a USB"
                 "SUSPEND and will not wake up until USB RESUME is detected. This will cause"
                 "all connections (whether ACL or SCO, parked or not, etc.) to be dropped."
                 "All periodic activity will also be suspended. When this flag is set to 1,"
                 "all other parameters are ignored."
             enum
             {
                 {0x00, "Maintain connections; sleep when timed activity allows"},
                 {0x01, "Sleep until resume is detected"}
             }
             enabled_if (("Sleep mode" = 3) or ("Sleep mode" = 5));
         PARAM "Enable tristate control of UART TX line"
             bool in uint8{4}
             doc "Applicable To Sleep Modes 1, 2, 7."
                 "When set to 0, the device will not tristate its UART TX line before going to sleep.<br>"
                 "When set to 1, the device will tristate its UART TX line before going to sleep."
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 7));
         PARAM "Combine sleep mode and LPM"
             bool in uint8{3}
             doc "Applicable To Sleep Modes 1, 2, 3, 5, 7."
                 "In Mode 0, always set byte 7 to 0. In all sleep modes, device always"
                 "requires permission to sleep between scans / periodic inquiries regardless"
                 "of the setting of this byte. In Modes 1 and 2, if byte is set, device must"
                 "have \"permission\" to sleep during the low power modes of sniff, hold, and park."
                 "If byte is not set, device can sleep without permission during these modes."
                 "Permission to sleep in Mode 1 is obtained if the BT_WAKE signal is not asserted."
                 "Permission to sleep in Mode 2 occurs after the Sleep Request / Sleep Request ACK exchange."
                 "In Mode 3 and 5, if the byte is set to 0, the device will not be able to sleep"
                 "during the low power modes. If it is set to 1, the device will be able so sleep"
                 "during the low power modes."
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                         ("Sleep mode" = 5) or ("Sleep mode" = 7));
         PARAM "Allow host sleep during SCO"
             bool in uint8{2}
             doc "Applicable To Sleep Modes 1, 2, 3, 5, 7."
                 "When this flag is set to 0, the host is not allowed to sleep while"
                 "an SCO is active. In modes 1 and 2, the device will keep the host"
                 "wake line asserted while an SCO is active. In mode 3, the device"
                 "will immediately issue a USB RESUME if the host issues a SUSPEND."
                 "When this flag is set to 1, the host can sleep while an SCO is active."
                 "This flag should only be set to 1 if SCO traffic is directed to the PCM interface."
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                         ("Sleep mode" = 5) or ("Sleep mode" = 7));
         PARAM "Host wake GPIO 3 active mode"
             uint8{1:1}
             doc "Applicable To Sleep Modes 1, 2, 5, 7."
                 "This flag indicates whether the GPIO 3 line is active low or high."
             enum
             {
                 {0x00, "Active Low"},
                 {0x01, "Active High"}
             }
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 5) or
                         ("Sleep mode" = 7));
         PARAM "Bt GPIO 0 active mode"
             uint8{0:0}
             doc "Applicable To Sleep Modes 1, 2, 7."
                 "This flag indicates whether the GPIO 0 line is active low or high."
             enum
             {
                 {0x00, "Active Low"},
                 {0x01, "Active High"}
             }
             enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 7));
         PARAM "Resume timeout"
             uint8
             doc "Applicable To Sleep Modes 3, 5."
                 "After the device issues a USB RESUME, it will wait this many seconds for the"
                 "Host to resume USB operations before issuing another USB RESUME."
                 "If this value is set to 0, the device will never reissue RESUME"
                 "and will instead wait forever for the host to act on the initial RESUME."
             enabled_if (("Sleep mode" = 3) or ("Sleep mode" = 5));
         PARAM "Sleep enable"
             uint8
             doc "If 1, the device is allowed to go to sleep.  If 0, the device must remain awake at"
                 "all times";
         PARAM "Bt wake GPIO"
             uint8
             doc "Bt wake GPIO";
     }

     COMMAND "CRC Start" 0x010E
     {
         doc "This item used for configuration of CRC start marker."
         PARAM "Checksum"
             uint32
             doc "The checksum for the following config items until the CRC End Marker encountered";
     }

     COMMAND "CRC End" 0x010F
     {
         doc "Config item used for configuration of CRC end marker."
     }

     COMMAND "Patch Entry" 0x0110
     {
         doc "Installs a code patch entry.  There are three types of patches.  The first type is a"
             "simple replacement of an 8-byte block of instructions with another, and therefore does"
             "not make use of the Code byte array.  The second type contains replacement instructions"
             "which vector to a contiguous block of code, loaded from the Code parameter.  The third"
             "type contains replacement instructions which vector to a fragmented block of code, "
             "loaded from the Code byte array of the Patch Entry config item, with other associated"
             "code segments being loaded from one or more Data Patch config items."
         PARAM "Patch index"
             uint8
             doc "The patch register index to be used"
             max = 255; 
         PARAM "Break out block address"
             uint32
             doc "The address of the block of code to be replaced.  It must fall on a four-byte"
                 "boundary.";
         PARAM "Replacement instructions"
             uint8[4]
             doc "The instructions to be executed in place of the block of code to be replaced.";
         PARAM "Code size"
             uint16
             doc "The size of the code segment to be loaded."
             binary_message_only
             encode_value = ByteArrayValidLength("Code");
         PARAM "Code address"
             uint32
             doc "The address to which to load the code bytes in the Code byte array.";
         PARAM "Code"
             uint8[0xFF00] omit_pad_bytes
             doc "The actual code instructions to be loaded to the address specified by Code address";
     }

    COMMAND "Serial Flash Write Protect Config" 0x111
    {
        doc "Used to enable the write protect features and specify the GPIO to use for the HW write protect bit"
        PARAM "spare"
            uint8{ 7:6 }
            doc "padding"
            default = 0;
        PARAM "HW Write Protection GPIO"
            uint8{5:2}
            doc "The GPIO to be used for the HW Write protect (HWP) feature. When driven low, the HWP is asserted.";
        PARAM "HW Write Protection Enable"
            uint8{1}
            doc "When set to 1, HW Write Protect is enabled";
        PARAM "SW Write Protection Enable"
            uint8{0}
            doc "When set to 1, SW Write Protect is enabled";
    }

     COMMAND "32Bit Register Pokes With Fab ID" 0x0112
     {
         doc "Config item code used to poke hardware register values to optimize system performance."
    
         PARAM "Fab ID"
             uint8
             doc "Fab ID";
         PARAM "Address"
             uint32
             doc "The address of the register to poke.";
         PARAM "Mask"
             uint32
             doc "The mask of value bits that are to be written.  Where mask bits are 1, the corresponding"
                 "value bit will be applied.  Where mask bits are 0, the existing bit value in the target"
                 "hardware register will be preserve";
         PARAM "Value"
             uint32
             doc "The value bits that are to be written.  Where mask bits are 1, the corresponding value"
                 "bit will be applied.  Where mask bits are 0, the existing bit value in the target hardware"
                 "register will be preserve";
     }

     COMMAND "transport override command" 0x0113
     {
         doc "Config item code used to explicitly set transport, thereby overriding the auto-detected transport."
         PARAM "Transport override"
         uint8
         doc "tran override";
     }

     COMMAND "UART Configuration" 0x0114
        {
            doc "Configures the baud rate, mode, and thresholds for the UART transport"
            PARAM "Transport UART baud rate"
                uint32
                doc "The baud rate used for the transport UART";
            PARAM "Debug UART baud rate"
                uint32
                doc "The baud rate used for the debug UART";
            PARAM "Flow control water mark"
                uint16
                doc "The number of bytes being unread in the UART receive FIFO, below which the peer"
                    "will receive a flow on indication and above which the peer will receive a flow off"
                    "indication."
                max = 480
                default = 345;
            PARAM "Transmit DMA threshold"
                uint16
                doc "The number of bytes in a packet being transmitted, above which DMA will be used"
                    "and below which the data will be read directly from the FIFO by firmware."
                max = 480
                default = 60;
            PARAM "Receive DMA threshold"
                uint16
                doc "The number of bytes in a packet being recevied, above which DMA will be used"
                    "and below which the data will be written directly to the FIFO by firmware."
                max = 480
                default = 5;
         PARAM "SLIP mode"
                uint8
                doc "Enables slip mode operation"
             enum
                {
                    {0x00, "Disable"},
                    {0x01, "Enable for SLIP interoperability with FTE"},
                    {0x81, "Enable with RFC 1071 compliance"}
                };
        }

     COMMAND "HW AES scratch buffer Size" 0x0115
     {
         doc "The size of the scratch buffer for HW AES "
         PARAM "Size"
             uint16
             doc " The size of the scratch buffer for HW AES in Bytes";
     }

     COMMAND "Dynamic Memory Min Address" 0x0116
     {
         doc "This sets the address from which permanent memory starts growing upward.  Can be used to make space for patches in SRAM."
         PARAM "MinAddress"
         uint32
             doc "Value of g_dynamic_memory_MinAddress";
     }

     COMMAND "HW PKA scratch buffer Size" 0x0117
     {
         doc "The size of the scratch buffer for HW PKA "
         PARAM "Size"
             uint16
             doc " The size of the scratch buffer for HW PKA in Bytes";
     }

     COMMAND "Spoffy AHB master command" 0x0118
     {
         doc "Config item code used for spiffy slave as AHB master init."
         PARAM "Spiffy AHB master enable"
             bool8
             doc "Spiffy AHB master enable. TRUE or FALSE.";
         PARAM "Spiffy AHB master spi mode"
             uint8
             doc "Spiffy AHB master spi mode";
         PARAM "SPIFFY_AHBM_SPIMODE_00/01/10/11"
             uint8
             doc "SPIFFY_AHBM_CSPOLARITY_LO/HI";
     }

     COMMAND "Spiffy display driver enable command" 0x0119
     {
         doc "Config item code used for spiffy MIPI-DBIC display driver enable."
         PARAM "Spiffy MIPI-DBIC display driver enable"
             bool8
             doc "Spiffy MIPI-DBIC display driver enable. TRUE or FALSE.";
         PARAM "Spiffy MIPI-DBIC display module"
             uint8
             doc "0, NHD12896; else, reserved";
     }

     COMMAND "eflash driver enable command" 0x0120
     {
         doc "Config item code used for eflash driver enable."
         PARAM "eflash driver enable"
             bool8
             doc "eflash driver enable. TRUE or FALSE.";
     }

     COMMAND "AVS enable command" 0x0121
     {
         doc "Config item code used for AVS enable."
         PARAM "AVS enable"
             bool8
             doc "AVS enable. TRUE or FALSE.";
     }

     COMMAND "AVS thresholds command" 0x0122
     {
         doc "Config item code used for AVS thresholds."
         PARAM "LP8H5_12MHZ_lower"
             uint16
             doc "Lower thresholds for LP8H5 in 12MHz.";
         PARAM "LP8H5_12MHZ_upper"
             uint16
             doc "Upper thresholds for LP8H5 in 12MHz.";
         PARAM "LP8H5_24MHZ_lower"
             uint16
             doc "Lower thresholds for LP8H5 in 24MHz.";
         PARAM "LP8H5_24MHZ_upper"
             uint16
             doc "Upper thresholds for LP8H5 in 24MHz.";
         PARAM "LP8H5_48MHZ_lower"
             uint16
             doc "Lower thresholds for LP8H5 in 48MHz.";
         PARAM "LP8H5_48MHZ_upper"
             uint16
             doc "Upper thresholds for LP8H5 in 48MHz.";
         PARAM "LP8H5_96MHZ_lower"
             uint16
             doc "Lower thresholds for LP8H5 in 96MHz.";
         PARAM "LP8H5_96MHZ_upper"
             uint16
             doc "Upper thresholds for LP8H5 in 96MHz.";
         PARAM "LP8S5_12MHZ_lower"
             uint16
             doc "Lower thresholds for LP8S5 in 12MHz.";
         PARAM "LP8S5_12MHZ_upper"
             uint16
             doc "Upper thresholds for LP8S5 in 12MHz.";
         PARAM "LP8S5_24MHZ_lower"
             uint16
             doc "Lower thresholds for LP8S5 in 24MHz.";
         PARAM "LP8S5_24MHZ_upper"
             uint16
             doc "Upper thresholds for LP8S5 in 24MHz.";
         PARAM "LP8S5_48MHZ_lower"
             uint16
             doc "Lower thresholds for LP8S5 in 48MHz.";
         PARAM "LP8S5_48MHZ_upper"
             uint16
             doc "Upper thresholds for LP8S5 in 48MHz.";
         PARAM "LP8S5_96MHZ_lower"
             uint16
             doc "Lower thresholds for LP8S5 in 96MHz.";
         PARAM "LP8S5_96MHZ_upper"
             uint16
             doc "Upper thresholds for LP8S5 in 96MHz.";
         PARAM "LP8L5_12MHZ_lower"
             uint16
             doc "Lower thresholds for LP8L5 in 12MHz.";
         PARAM "LP8L5_12MHZ_upper"
             uint16
             doc "Upper thresholds for LP8L5 in 12MHz.";
         PARAM "LP8L5_24MHZ_lower"
             uint16
             doc "Lower thresholds for LP8L5 in 24MHz.";
         PARAM "LP8L5_24MHZ_upper"
             uint16
             doc "Upper thresholds for LP8L5 in 24MHz.";
         PARAM "LP8L5_48MHZ_lower"
             uint16
             doc "Lower thresholds for LP8L5 in 48MHz.";
         PARAM "LP8L5_48MHZ_upper"
             uint16
             doc "Upper thresholds for LP8L5 in 48MHz.";
         PARAM "LP8L5_96MHZ_lower"
             uint16
             doc "Lower thresholds for LP8L5 in 96MHz.";
         PARAM "LP8L5_96MHZ_upper"
             uint16
             doc "Upper thresholds for LP8L5 in 96MHz.";
     }

     COMMAND "AVS LDO flags1 command" 0x0123
     {
         doc "Config item code used for AVS LDO flags1."
         PARAM "AVS LDO flags1"
             bool8
             doc "AVS LDO flags1. TRUE or FALSE.";
     }

     COMMAND "AVS LDO flags2 command" 0x0124
     {
         doc "Config item code used for AVS LDO flags2."
         PARAM "AVS LDO flags2"
             bool8
             doc "AVS LDO flags2. TRUE or FALSE.";
     }

     COMMAND "AVS LDO value1 command" 0x0125
     {
         doc "Config item code used for AVS LDO register value1."
         PARAM "AVS LDO value1"
             uint32
             doc "AVS LDO register value1.";
     }

     COMMAND "AVS LDO value2 command" 0x0126
     {
         doc "Config item code used for AVS LDO register value2."
         PARAM "AVS LDO value2"
             uint32
             doc "AVS LDO register value2.";
     }

     COMMAND "Slimboot Config Size" 0x0127
     {
         doc "Config item code used for amount of AON RAM to allocate for slimboot config."
         PARAM "Size"
             uint16
             doc "Max AON usage";
     }

     COMMAND "Slimboot Data" 0x0128
     {
         doc "Config item code used to write an arbitrary chunk of data to an arbitrary address after booting into slimboot."
         PARAM "Address"
             uint32
             doc "The address to which the Data bytes are to be loaded.";
         PARAM "Data"
             uint8[0xFF00] omit_pad_bytes
             doc "The data bytes to be loaded to the Address specified. The data with arbitrary length. "
                 "The length is implied by the size of the array specified for data, as in data = {0x01, 0x02}.";
     }

     COMMAND "Slimboot Patch Entry" 0x0129
     {
         doc "Installs a slimboot code patch entry.  See Patch Entry documentation for more info."
             " Patch data is excluded for AON RAM savings."
         PARAM "Patch index"
             uint8
             doc "The patch register index to be used"
             max = 191; 
         PARAM "Break out block address"
             uint32
             doc "The address of the block of code to be replaced.  It must fall on a four-byte"
                 "boundary.";
         PARAM "Replacement instructions"
             uint8[4]
             doc "The instructions to be executed in place of the block of code to be replaced.";
     }

     COMMAND "Slimboot Data Write" 0x012A
     {
         doc "Variable width slimboot config data write."
         PARAM "Address"
             uint32
             doc "The address  to be written.";
         PARAM "Width/Length"
             uint16
             doc "Width in bits [15:14]. 00 = byte, 01 = halfword, 1x = word."
                 "Length in bits [13:0].";
         PARAM "Data"
             uint8[0xFF00] omit_pad_bytes
             doc "The data bytes to be loaded to the Address specified. The data with arbitrary length. "
                 "The length must match the length in the Width/Length field";
     }

     COMMAND "AON Data" 0x012B
     {
         doc "Config item code used to write an arbitrary chunk of data to an arbitrary address.  This will only happen one time on cold boot."
         PARAM "Address"
             uint32
             doc "The address to which the Data bytes are to be loaded.";
         PARAM "Data"
             uint8[0xFF00] omit_pad_bytes
             doc "The data bytes to be loaded to the Address specified. The data with arbitrary length. "
                 "The length is implied by the size of the array specified for data, as in data = {0x01, 0x02}.";
     }

     COMMAND "FOUNDATION_CONFIG_ITEM_CLOCK_TIMER_CPU_SPEED" 0x012C
     {
         doc "CPU Speed Config for Clock Request."
                "Setting both to the same value will lock the CPU speed to that value."
    
         PARAM "Min CPU Speed"
             uint8
             doc "Min CPU Speed (enum value)"
             enum
             {
                 {0x00, "CLOCK_DISABLE"},
                 {0x01, "CLOCK_1MHZ"},
                 {0x02, "CLOCK_4MHZ"},
                 {0x03, "CLOCK_6MHZ"},
                 {0x04, "CLOCK_12MHZ"},
                 {0x05, "CLOCK_16MHZ"},
                 {0x06, "CLOCK_24MHZ"},
                 {0x07, "CLOCK_32MHZ"},
                 {0x08, "CLOCK_48MHZ"},
                 {0x09, "CLOCK_96MHZ"},
                 {0x0A, "CLOCK_XTAL"}
             };
         PARAM "Max CPU Speed"
             uint8
             doc "Max CPU Speed (enum value)"
             enum
             {
                 {0x00, "CLOCK_DISABLE"},
                 {0x01, "CLOCK_1MHZ"},
                 {0x02, "CLOCK_4MHZ"},
                 {0x03, "CLOCK_6MHZ"},
                 {0x04, "CLOCK_12MHZ"},
                 {0x05, "CLOCK_16MHZ"},
                 {0x06, "CLOCK_24MHZ"},
                 {0x07, "CLOCK_32MHZ"},
                 {0x08, "CLOCK_48MHZ"},
                 {0x09, "CLOCK_96MHZ"},
                 {0x0A, "CLOCK_XTAL"}
             };
     }

     COMMAND "FOUNDATION_CONFIG_ITEM_PROCESS_HEADER_TABLE_POINTER" 0x012D
     {
         doc "Variable length config headers table. Autogenerated by cgs.exe. Do not use in cfg"
         PARAM "Len"
             uint32
             doc "Number of records in the table";
     }

     COMMAND "Slimboot Patch Loader" 0x012E
     {
     doc "Config item code used to write an arbitrary chunk of data to an arbitrary address followed by a function call to the given address"
     PARAM "Launch Address"
          uint32
                     doc "The launch address to invoke after loading the item to Destination";
     PARAM "Destination"
                     uint32
                     doc "The address to which the Data bytes are to be loaded.";
     PARAM "Data"
                     uint8[0xFF00] omit_pad_bytes
                     doc "The data bytes to be loaded to the Address specified. The data with arbitrary length. "
                                     "The length is implied by the size of the array specified for data, as in data = {0x01, 0x02}.";
     }

     COMMAND "Slimboot AVS enable command" 0x012f
     {
         doc "Config item code used for Slimboot AVS enable."
         PARAM "Slimboot AVS enable"
             bool8
             doc "Slimboot AVS enable. TRUE or FALSE.";
     }

     COMMAND "AVS tracking enable command" 0x0130
     {
         doc "Config item code used for AVS tracking enable."
         PARAM "AVS tracking enable"
             bool8
             doc "AVS tracking enable. TRUE or FALSE.";
     }

    COMMAND "PMU register w/r" 0x01F0
    {
        doc "Configures what PMU is writting before and after sleep"
        PARAM "Record Subtype"
            uint32
            doc "1-preSleep, 2- postSleep, 3- dump";
        PARAM "Num entries"
            uint8
            doc "An abstract parameter used only for encoding purposes, not present in the"
                "actual configuration item. When encoding the configuration item, determines"
                "the number of address/value pairs to include."
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 40;
        PARAM "Register address[0]"
            uint32
            doc "Address of the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Bit field mask[0]"
            uint32
            doc "Bit field mask. If a bit is 1 that bit value will be changed to the new value"
                "specified"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint32
            doc "Data to be written to the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Register address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Bit field mask[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Register address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Bit field mask[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Register address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Bit field mask[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Register address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Bit field mask[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Register address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Bit field mask[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Register address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Bit field mask[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Register address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Bit field mask[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Register address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Bit field mask[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Register address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Bit field mask[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Register address[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Bit field mask[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Register address[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Bit field mask[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Value[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Register address[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Bit field mask[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Value[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Register address[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Bit field mask[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Value[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Register address[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Bit field mask[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Value[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Register address[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Bit field mask[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Value[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Register address[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Bit field mask[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Value[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Register address[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Bit field mask[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Value[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Register address[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Bit field mask[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Value[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Register address[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Bit field mask[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Value[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Register address[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Bit field mask[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Value[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Register address[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Bit field mask[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Value[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Register address[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Bit field mask[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Value[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Register address[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Bit field mask[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Value[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Register address[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Bit field mask[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Value[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Register address[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Bit field mask[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Value[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Register address[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Bit field mask[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Value[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Register address[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Bit field mask[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Value[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Register address[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Bit field mask[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Value[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Register address[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Bit field mask[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Value[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Register address[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Bit field mask[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Value[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Register address[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Bit field mask[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Value[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Register address[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Bit field mask[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Value[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Register address[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Bit field mask[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Value[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Register address[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Bit field mask[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Value[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Register address[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Bit field mask[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Value[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Register address[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Bit field mask[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Value[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Register address[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Bit field mask[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Value[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Register address[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Bit field mask[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Value[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Register address[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Bit field mask[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Value[39]"
            uint32
            present_if ("Num entries" > 39);
    }
    #COMMAND "PMU register writes" 0xF0

     COMMAND "R and RC Calibration" 0x0201
     {
         doc "Config item to define scaling and offsets for R and RC calibration values."
         PARAM "Rx filter RC scale"
             uint16
             doc "Bluetooth Rx Filter RC scaling.";
         PARAM "Rx filter RC offset"
             uint16
             doc "Bluetooth Rx Filter RC offset.";
         PARAM "ADC RC scale"
             uint16
             doc "Bluetooth ADC RC scaling.";
         PARAM "ADC RC offset"
             uint16
             doc "Bluetooth ADC RC offset.";
         PARAM "Mixer RC scale"
             uint16
             doc "Bluetooth Mixer RC scaling.";
         PARAM "Mixer RC offset"
             uint16
             doc "Bluetooth Mixer RC offset.";
         PARAM "BG R scale"
             uint16
             doc "Bluetooth BG R scaling.";
         PARAM "BG R offset"
             uint16
             doc "Bluetooth BG R offset.";
         PARAM "BGVCOLO R scale"
             uint16
             doc "Bluetooth BGVCOLO R scaling.";
         PARAM "BGVCOLO R offset"
             uint16
             doc "Bluetooth BGVCOLO R offset.";
         PARAM "FM R scale"
             uint16
             doc "FM R scaling.";
         PARAM "FM R offset"
             uint16
             doc "FM R offset.";
         PARAM "FM RC scale"
             uint16
             doc "FM RC scaling.";
         PARAM "FM RC offset"
             uint16
             doc "FM RC offset.";
     }

     COMMAND "BD_ADDR" 0x0300
     {
         doc "Config item code for the Bluetooth device address."
         PARAM "Bluetooth device address"
             uint8[6] 
             doc "Config item code for the Bluetooth device address.  The config variable is rm_deviceBDAddr.";
     }

     COMMAND "ACL Pool Configuration" 0x0301
     {
         doc "Config item code for ACL buffer pools configuration."
         PARAM "Host claim ACL Host to device size"
             uint16
             doc "The size of buffers for host claim host to device ACL traffic.";
         PARAM "ACL Host to device size"
             uint16
             doc "The size of buffers for host to device ACL traffic.";
         PARAM "Unemployed entry"
             uint16
             doc "This entry is currently used by BLE only and shall be set to zero always for BT.";
         PARAM "ACL Device to host size"
             uint16
             doc "The size of buffers for device to host ACL traffic.";
         PARAM "Host Claim ACL Host to device count"
             uint8
             doc "The number of buffers for host claim host to device ACL traffic.";
         PARAM "ACL Host to device count"
             uint8
             doc "The number of buffers for host to device ACL traffic.";
         PARAM "ACL Device to host count"
             uint8
             doc "The number of buffers for device to host ACL traffic.";
     }

     COMMAND "BLE ACL Pool Configuration" 0x0302
     {
         doc "Config item code for BLE buffer pools configuration."
         PARAM "BLE Host claim ACL Host to device size"
             uint16
             doc "The size of buffers for host claim host to device BLE ACL traffic.";
         PARAM "BLE ACL Host to device size"
             uint16
             doc "The size of buffers for host to device BLE ACL traffic.";
         PARAM "BLE device claim ACL device to host size"
             uint16
             doc "The max ACL payload size (<=251) for packets from device to host.";
         PARAM "BLE ACL Device to host size"
             uint16
             doc "The size of buffers for device to host BLE ACL traffic.";
         PARAM "BLE Host Claim ACL Host to device count"
             uint8
             doc "The number of buffers for host claim host to device BLE ACL traffic.";
         PARAM "BLE ACL Host to device count"
             uint8
             doc "The number of buffers for host to device BLE ACL traffic.";
         PARAM "BLE ACL Device to host count"
             uint8
             doc "The number of buffers for device to host BLE ACL traffic.";
     }

     COMMAND "Local Name" 0x0303
     {
         doc "Config item code for specifying the device local name."
         PARAM "Name"
             utf8[248] omit_pad_bytes 
             doc "The local name for this device.";
     }

     COMMAND "AFH Channel Classification Configuration" 0x0304
     {
         doc "Configures various aspect of AFH channel classification behavior"
             "1. How often channel classification algorithm should run"
             "2. How often active RSSI scan should run"
         PARAM "afhccInterval"
             uint8
             doc "Channel classification interval in 125 ms granularity."
             default = 32;
         PARAM "scanType"
             uint8
             doc "Legacy/pipelined RSSI."
             enum
             {
                 {0x00, "Pipelined RSSI Scan"},
                 {0x01, "BCI RSSI Scan"}
             }
             default = 0x1;
         PARAM "activeScanInterval"
             uint16
             doc "How often to run active scan in 12.5ms interval."
             default = 320;
         PARAM "reclaimCnt"
             uint8
             doc "Number of active scans before a channel can be reclaimed"
             default = 20;
         PARAM "reclaimSnr"
             int8
             doc "Number of scans over which peak RSSI scan values are retained."
             default = 20;
         PARAM "targetPerGoodSig"
             uint8
             doc "Packet Error Rate (PER) threshold per BT channel under good receive power (/ 255)"
             default = 26;
         PARAM "targetPerWeakSig"
             uint8
             doc "Packet Error Rate (PER) threshold per BT channel under weak receive power (/ 255)"
             default = 102;
         PARAM "wifiThreshold_bg"
             uint8
             doc "Number of 1 MHz channels to declaim the presence of 11bg"
             default = 10;
         PARAM "wifiThreshold_n"
             uint8
             doc "Number of 1 MHz channels to declaim the presence of 11n"
             default = 21;
         PARAM "Threshold_reserved_1"
             uint8
             doc "Number of 1 MHz channels to declaim the presence of ..."
             default = 0;
         PARAM "Threshold_reserved_2"
             uint8
             doc "Number of 1 MHz channels to declaim the presence of ..."
             default = 0;
     }

     COMMAND "AFH Channel Classification Internal Configuration" 0x0305
     {
         doc "Config item code for AFH private configuration."
         PARAM "bypassScan"
             uint16{15}
             doc  "Whether to run active RSSI scan "
             enum
             {
                 {0x0, "Run "},
                 {0x1, "Bypass active RSSI scan "}
             }
             default = 0x0;
         PARAM "filterRxRssi"
             uint16{14}
             doc  "Enable filter passive RSSI values"
             enum
             {
                 {0x0, "No filtering"},
                 {0x1, "Filtering"}
             }
             default = 0x0;
         PARAM "longRSSIScanIntervalInLpo"
             uint16{13}
             doc "Enable long RSSI Scan Interval In Lpo mode"
             enum
             {
                 {0x0, "Disable"},
                 {0x1, "Enable"}
             }
             default = 0x0;
         PARAM "avoidLeAdChs"
             uint16{12}
             doc "Avoid using LE advertise channels with active LE link(s)."
             default = 0x1;
         PARAM "enforceRules"
             uint16{11}
             doc "Enforce association rules"
             enum
             {
                 {0x0, "Do not enforce association rules"},
                 {0x1, "Enforce association rules"}
             }
             default = 0x1;
         PARAM "bypassCC"
             uint16{10}
             doc "bypassCC"
             enum
             {
                 {0x0, "Run channel classification"},
                 {0x1, "Bypass channel classification"}
             }
             default = 0x0;
         PARAM "considerSlaveMap"
             uint16{9}
             doc "slave map"
             enum
             {
                 {0x0, "Ignore slave maps"},
                 {0x1, "Take slave maps into consideration"}
             }
             default = 0x1;
         PARAM "scan_coex"
             uint16{8}
             doc "coex"
             enum
             {
                 {0x0, "Ignore coex settings"},
                 {0x1, "Take coex maps into consideration"}
             }
             default = 0x1;
         PARAM "hdrFecTuple"
             uint16{7:3}
             doc "Number of FEC tuple errors before classifying to bad packets for statistics only"
             default = 0x0;
         PARAM "site_survey"
             uint16{2}
             doc "FEC"
             enum
             {
                 {0x0, "Normal operation (scan with links)"},
                 {0x1, "Scan without links"}
             }
             default = 0x0;
         PARAM "afhcc_log"
             uint16{1:0}
             doc "Logging"
             enum
             {
                 {0x0, "No log"},
                 {0x1, "RSSI log"},
                 {0x2, "CC log"},
                 {0x3, "RSSI and CC log"}
             }
             default = 0x0;
         PARAM "PLL_Settling_Time"
             uint8
             doc "Settling time in us for most channels"
             note "us"
             default = 40;
         PARAM "Extra_Settling_Time"
             uint8
             doc "Settling time in us for the first swithced-in channels"
             note "us"
             default = 80;
         PARAM "afhccAsscRuleEn"
             uint32
             doc "Enable bit for assocation rules"
             default = 0x003fffff;
         PARAM "PER_Shift"
             uint8
             doc"Shift factor for channel PER filter [1-6]"
             default = 5;
         PARAM "minPackets"
             uint8
             doc "Min. packets before enable PER based condemnation"
             default = 3;
         PARAM "lazyResetTh"
             uint8
             doc "Threshold for lazy reset"
             default = 0x1f;
         PARAM "rssiReadTime"
             uint8
             doc "time to finish RSSI reading and averaging"
             default = 100;
         PARAM "rxSensitivity"
             int8
             doc "RX sensitivity from the eye of AFH"
             default = -82;
         PARAM "rxrssi_th"
             int8
             doc "Threshold for good/weak signal level (dBm)"
             default = -70;
         PARAM "condemnCnt"
             uint8
             doc "Number of RSSI scans release condemning a channel" 
             default = 10;
         PARAM "condemnSnrGoodSig"
             int8
             doc "SNR margin for condemning under good signal level" 
             default = 5;
         PARAM "condemnSnrWeakSig"
             int8
             doc "SNR margin for condemning under weak signal level" 
             default = 0;
         PARAM "regroupTh"
             uint16
             doc "Number of CC runs before reclaim all channel for defragmentation purpose" 
             default = 0xFFFF;
         PARAM "syncToTh"
             uint8
             doc "Sync TO margin for condemning under strong signal level" 
             default = 7;
         PARAM "absCondemnTh"
             int8
             doc "Absolute RSSI threshold for future-proof ETSI regulation"
             default = -71;
     }

     COMMAND "BFC Configuration" 0x0306
     {
         doc "Broadcom Fast Connect (BFC) configuration"
         PARAM "Reserved"
             uint16{15:11}
             doc "Reserved BFC configuration";
         PARAM "Resume Failure Page Enable"
             uint16{10:10}
             doc "Resume Failure Page Enable"
             enum
             {
                 {0x00, "Disable"},
                 {0x01, "Enable"}
             };
         PARAM "Storage Type"
             uint16{9:7}
             doc "storage type"
             enum
             {
                 {0x00, "none"},
                 {0x01, "VSE"},
                 {0x02, "NVRAM"}
             };
         PARAM "Fast Connect Method"
             uint16{6:4}
             doc "fast connect method"
             enum
             {
                 {0x00, "none"},
                 {0x01, "LE"},
                 {0x02, "TBFC"}
             };
         PARAM "Enc After Reconnect"
             uint16{3:3}
             doc "Restart Encryption After Reconnect"
             enum
             {
                 {0x00, "No"},
                 {0x01, "Yes"}
             };
         PARAM "Auth After Reconnect"
             uint16{2:2}
             doc "Restart Authentication After Reconnect"
             enum
             {
                 {0x00, "No"},
                 {0x01, "Yes"}
             };
         PARAM "Rapid Reconnect Support"
             uint16{1:1}
             doc "Rapid Reconnect Support"
             enum
             {
                 {0x00, "No"},
                 {0x01, "Yes"}
             };
         PARAM "BFC Enable"
             uint16{0:0}
             doc "BFC supported"
             enum
             {
                 {0x00, "No"},
                 {0x01, "Yes"}
             };
         PARAM "Reconnect Timeout"
             uint16
             doc "Reconnect Timeout";
         PARAM "Scan Window"
             uint8
             doc "Scan Window";
         PARAM "Scan Interval"
             uint8
             doc "Scan Interval";
     }

     COMMAND "Device Info" 0x0307
     {
         doc "Config item code for Bluetooth device info."
         PARAM "Spec Support BitMask"
             uint16
             doc "Core spec support (BT1.2, BT2.0, BT3.0, BT4.0, etc.)";
         PARAM "Clock Accuracy"
             uint16
             doc "Sleep clock accuracy (as reported to peer device)";
         PARAM "Multi Slot Sniff"
             uint8
             doc "Enable/disable multi-slot packets in Sniff mode";
     }

     COMMAND "Soft Picky" 0x0308
     {
         doc "Config item code for soft picky."
         PARAM "softDecodingFECEnabled"
             uint8
             doc "Soft decoding FEC enabled";
         PARAM "softHeaderPickyEnabled"
             uint8
             doc "Soft header picky enabled";
         PARAM "hdrBitWeakThres"
             uint16
             doc "Header bit week threshold";
         PARAM "bcsFecConfig"
             uint32
             doc "BCS FEC config";
         PARAM "SCO"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): SCO";
         PARAM "eSCO NB"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): eSCO NB";
         PARAM "eSCO WB"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): eSCO WB";
         PARAM "A2DP"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): A2DP";
         PARAM "Multicast"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): Multicast";
         PARAM "LMP"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): LMP";
         PARAM "L2CAP 1 slot"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): L2CAP 1 slot";
         PARAM "L2CAP 3 slots"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): L2CAP 3 slots";
         PARAM "L2CAP 5 slots"
             uint32
             doc "Header QOS config table (hdrQosConfigTable): L2CAP 5 slots";
     }

     COMMAND "PC Workarounds" 0x0309
     {
         doc "This item is to enable/disable a variety of features and workarounds"
             "for the PC programs."
         PARAM "PC Workaround flags"
             uint16
             doc "PC workaround enable flags"
                 "  0001: Send extra HCI event credit on enumeration.  Vista race condition between usb and BT drivers"
                 "         will sometimes halt usb endpoint before BT stack is over and we lose a command complete"
                 "  0002: Avoid back to back 5 slot packets after sniff rx.  (see below)"
                 "  0004: Don't set AFH instant to less than 1.5 seconds.  2042 KB only responds every 500 ms in "
                 "        fake sniff subrating mode, so we need to make sure it gets the set_afh before the instant."
                 "  0008: Don't send lmp detach with a pending AFH instant.  Pause the LMP until AFH instant passes."
                 "        2040 HIDs have AFH failures when detaching with pending AFH instant."
                 "  0010: Delay entering sleep (see below)"
                 "  0020: Insert silence for transparent encoded SCO"
                 "  0040: Custom scheduling LRM adaptation for multislot HIDs.  Allocate additional frames between"
                 "        sniff connections if HID supports multislot packets.  Also, schedule multislot HIDs after single"
                 "        slot HIDs."
                 "  0080: Return slotOffset=1249 whenever slotOfffset=0 during MSS to workaround 2042 HIDs issue."
                 "  0100: Unsniffs Sniffed Master connections when a sniffed connection becomes active or "
                 "        When a sco is added or removed to re-pack the sniff connections." 
                 "  0200: Disables the support for USB MSFT OS descriptors to avoid loading MSFT driver"
                 "  0400: Enables the USB resume duration to be set from the configuration"
             bitmap
             {
                 {0x0001, "Send extra HCI event credit on enumeration"},
                 {0x0002, "Enable long AFH instant"},
                 {0x0004, "Avoid detach with pending AFH instant"},
                 {0x0008, "Avoid 5 slot packets in sniff"},
                 {0x0010, "Enable delay entering sleep"},
                 {0x0020, "Enable transparent encoded SCO silence"},
                 {0x0040, "Multislot HID Scheduling"},
                 {0x0080, "MSS SlotOffset 0 Issue"},
                 {0x0100, "Enable auto unsniff feature"},
                 {0x0200, "Disable USB MSFT OS descriptor support"},
                 {0x0400, "Enable USB Resume Duration"}
             }
             default = 0x0001;
         PARAM "Avoid 5 slot packets"
             uint8
             doc "DEPRECATED! Do not send back to back 5 slot packets immediately after hearing from a sniff link."
                 "The value is the number of slots to wait after a sniff response before allowing 5 slot packets "
                 "again.  2042 KB will disconnect when its master link transmits two 5 slot packets to anyone "
                 "right after responding on a fake sniff subrating 500ms interval.  80 is currently used."
             enabled_if ( ("PC Workaround flags" & 0x0008)=0x0008);
         PARAM "Delay entering sleep"
             uint8
             doc "Delay entering USB sleep.  Value is amount to insert into pmu_slpModeIdleThresholdFactor table."
                 "Current workaround uses 24 which delays sleep by a couple seconds.  2042 KB clock doesn't allow"
                 "clock drift during transition to HID sleep stage, so we can't immediately switch to LPO."
             enabled_if ( ("PC Workaround flags" & 0x0010)=0x0010);
         PARAM "USB Resume Duration"
             uint8
             doc "Enable the USB resume duration to be set by the configuration."
             enabled_if ( ("PC Workaround flags" & 0x0400)=0x0400);
     }

     COMMAND "Audio Byte Pool Size" 0x030A
     {
         doc "This item is to overwrite Audio Byte Pool Size."
         PARAM "AA byte pool size"
             uint32
             doc "Buffer size for audio routing.";
     }

     COMMAND "PCM2 Config" 0x30B
     {
         doc "PTUAUX PCM2 configuration"
                 PARAM "Config_REG_Reserved"
                         uint32{31:22}
             doc     "Reserved bits";
                 PARAM "Sync_Output_Enable"
                         uint32{21:21}
             doc     "Syn output enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         };
                 PARAM "Clock_Inversion"
                         uint32{20:20}
             doc     "Clock inversion"
                         enum
                         {
                                 {0, "Normal"},
                                 {1, "Inverted"}
                         };
                 PARAM "Loopback"
                         uint32{19:19}
             doc     "Loopback mode"
                         enum
                         {
                                 {0, "Normal"},
                                 {1, "Loopback"}
                         }; 
                 PARAM "NumberOfSlots"
                         uint32{18:14}
             doc     "Number of slots"
                         min = 0
                         max = 31;               
                 PARAM "Slot_Width"
                         uint32{13:9}
             doc     "Slot width"
                         min = 0
                         max = 31;               
                 PARAM "Tri-State"
                         uint32{8:8}
             doc     "Tri-state"
                         enum
                         {
                                 {0, "Not tri-stated"},
                                 {1, "Tri-stated"}
                         }; 
                 PARAM "Clock_Generation"
                         uint32{7:7}
             doc     "Clock generation"
                         enum
                         {
                                 {0, "Not generated"},
                                 {1, "Generated"}
                         };
                 PARAM "Sync_Width"
                         uint32{6:4}
             doc     "Sync width"
                         min = 0
                         max = 7;
                 PARAM "Sync_Aligned"
                         uint32{3:3}
             doc     "Sync aligned"
                         enum
                         {
                                 {0, "Not aligned"},
                                 {1, "Alined"}
                         };
                 PARAM "Sync_Generation"
                         uint32{2:2}
             doc     "Sync generation"
                         enum
                         {
                                 {0, "Not generated"},
                                 {1, "Generated"}
                         };
                 PARAM "Operation_Mode"
             uint32{1:1}
             doc     "Operation mode"
                         enum
                         {
                                 {0, "PCM"},
                                 {1, "I2S"}
                         };
                 PARAM "Soft_Reset"
             uint32{0:0}
             doc     "Soft Reset"
                         enum
                         {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
             
                 PARAM "Ch_Period_REG_Reserved"
                         uint32{31:12}
             doc     "CH Period REG reserved";
                 PARAM "Ch_2_Period"
                         uint32{11:8}
             doc     "CH2 period"
                         min = 0x0
                         max = 0xF;
                 PARAM "Ch_1_Period"
                         uint32{7:4}
             doc     "CH1 period"
                         min = 0x0
                         max = 0xF;
                 PARAM "Ch_0_Period"
                         uint32{3:0}
             doc     "CH0 period"
                         min = 0x0
                         max = 0xF;      
                         
                 PARAM "Bank_Set_REG_Reserved"
                         uint32{31:18}
             doc     "Bank set REG reserved";
                 PARAM "Bank_1_Programmable_Fill_Data"
                         uint32{17:15}
             doc     "Bank1 prog fill"
                         min = 0x0
                         max = 0x7;
                 PARAM "Bank_1_LSB_First"
                         uint32{14:14}
             doc     "Bank1 LSB first"
                         enum
                         {
                                 {0x00, "MSB First"},
                                 {0x01, "LSB First"}
                         };
                 PARAM "Bank_1_Right_Justify"
                         uint32{13:13}
             doc     "Bank1 right justify"
                         enum
                         {
                                 {0x00, "Left Justified"},
                                 {0x01, "Righ Justified"}
                         };
                 PARAM "Bank_1_Number_of_Fill_Bits"
                         uint32{12:11}
             doc     "Bank1 fill bits"
                         min = 0x0
                         max = 0x3;
                 PARAM "Bank_1_Fill_Mode"
                         uint32{10:9}
             doc     "Bank1 fill mode"
                         enum
                         {
                                 {0x00, "0s"},
                                 {0x01, "1s"},
                                 {0x02, "Sign"},
                                 {0x03, "Programmable"}
                         };
                 PARAM "Bank_0_Programmable_Fill_Data"
                         uint32{8:6}
             doc     "Bank 0 fill data"
                         min = 0x0
                         max = 0x7;
                 PARAM "Bank_0_LSB_First"
                         uint32{5:5}
             doc     "Bank0 LSB first"
                         enum
                         {
                                 {0x00, "MSB First"},
                                 {0x01, "LSB First"}
                         };
                 PARAM "Bank_0_Right_Justify"
                         uint32{4:4}
             doc     "Bank0 right justify"
                         enum
                         {
                                 {0x00, "Left Justified"},
                                 {0x01, "Righ Justified"}
                         };
                 PARAM "Bank_0_Number_of_Fill_Bits"
                         uint32{3:2}
             doc     "Bank0 fill bits"
                         min = 0x0
                         max = 0x3;
                 PARAM "Bank_0_Fill_Mode"
                         uint32{1:0}
             doc     "Bank1 fill mode"
                         enum
                         {
                                 {0x00, "0s"},
                                 {0x01, "1s"},
                                 {0x02, "Sign"},
                                 {0x03, "Programmable"}
                         };
                 PARAM "Ch_Config_REG_Reserved"
                         uint32{31:30}
             doc     "CH Config REG reserved";
                 PARAM "Ch_4_Enable"
                         uint32{29:29}
             doc     "CH4 enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         };
                 PARAM "Ch_4_Slot_Number"
                         uint32{28:24}
             doc     "CH4 slot number"
                         min = 0x0
                         max = 0x1F;
                 PARAM "Ch_3_Enable"
                         uint32{23:23}
             doc     "CH3 enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         };
                 PARAM "Ch_3_Slot_Number"
                         uint32{22:18}
             doc     "CH3 slot nimber"
                         min = 0x0
                         max = 0x1F;
                 PARAM "Ch_2_Enable"
                         uint32{17:17}
             doc     "CH2 enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         };
                 PARAM "Ch_2_Slot_Number"
                         uint32{16:12}
             doc     "CH2 slot number"
                         min = 0x0
                         max = 0x1F;
                 PARAM "Ch_1_Enable"
                         uint32{11:11}
             doc     "CH1 enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         }; 
                 PARAM "Ch_1_Slot_Number"
                         uint32{10:6}
             doc     "CH1 slot number"
                         min = 0x0
                         max = 0x1F;
                 PARAM "Ch_0_Enable"
                         uint32{5:5}
             doc     "CH0 enable"
                         enum
                         {
                                 {0, "Disabled"},
                                 {1, "Enabled"}
                         }; 
                 PARAM "Ch_0_Slot_Number"
                         uint32{4:0}
             doc     "CH0 slot number"
                         min = 0x0
                         max = 0x1F;
                         
                 PARAM "PCM_Clock_Freq"
                         uint32
             doc     "PCM clock frequency";
         }

     COMMAND "WBS SBC Configuration" 0x030C
     {
         doc "Configures the WBS SBC audio block parameters"
         PARAM "WBS SBC Enable"
             uint8
             doc "The switch to turn on Wideband Speech and the SideBand Codec audio path."
                 "Default is 1 (enabled)";
         PARAM "WBS SBC Log Enable map"
             uint8
             doc "audio encoder and decoder debug log map."
                 "Default is 0 ";
         PARAM "WBS SBC option"
             uint32
             doc "Wide band speech audio codec configuration."
                 "Default is 1 (enabled)";
     }

     COMMAND "Codec Stack Size" 0x030D
     {
         doc "Config item code for codec stack size."
         PARAM "AA stack size"
             uint16
             doc "For codec stack size.";
     }

     COMMAND "PCM Loopack Configuration" 0x030E
     {
         doc "This item is to overwrite the PCM loopback variables"
         PARAM "PCM loopback delay"
             uint16
             doc "Configure PCM loopback delay, value ranges from 0 to 512 samples of delay."
                 "The default value is 128 samples."
             max = 512;
     }

     COMMAND "Coexistence Config" 0x030F
     {
         doc "A structure defines the Bluetooth Coexistence (with WLAN) to be used"
             "and defines the priority associated with each Bluetooth activity"
         PARAM "Type"
             uint8
             doc "Select the Coexistence Type to be used"
             enum
             {
                 {0x0, "No collaboration"},
                 {0x1, "2 pin 2 pin solution"},
                 {0x2, "3 pin 2 pin solution"},
                 {0x3, "WCS"},
                 {0x4, "WiMax"}
             };
         PARAM "T1 time 3 wire"
             uint8
             doc "Defines the times RF_ACTIVE will be asserted (before the begining of the TX Slot)."
                 "Units are in microseconds. The default value is 150."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             default = 150;
         PARAM "T2 time 3 wire"
             uint8
             doc "Defines the priority assertion time of STATUS line, during this time the priority"
                 "is reflected. After this time TX-RX is reflected. Units are in microseconds. The"
                 "default value is 20."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             default = 20;
         PARAM "T3 time 3 wire"
             uint8
             doc "Defines the time to assert the STATUS line before begining TX as a slave."
                 "Units are in microseconds. The default value is 88."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             default = 88;
         PARAM "T5 time 3 wire"
             uint8
             doc "Defines the time to sample the TX_CONFX before the begining of the TX slot."
                 "Units are in microseconds. The default value is 75."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             default = 75;
         PARAM "T7 time 3 wire"
             uint8
             doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS. Units are"
                 "in microseconds. The default value is 0 and the maximum value is 1."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             max = 1;
         PARAM "T9 time 3 wire"
             uint8
             doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS for Low priority frame."
                 "Units are in microseconds."
             enabled_if ( ("Type" = 2) or ("Type" = 0) )
             default = 175;
         PARAM "T1 time 3 wire for BLE"
             uint8
             doc "Defines the times TX_BT will be asserted (before the begining of the TX Slot)."
                 "Units are in microseconds. The default value is 25."
             default = 108;
         PARAM "T2 time 3 wire for BLE"
             uint8
             doc "Defines the priority assertion time of STATUS line, during this time the priority"
                 "is reflected. After this time TX-RX is reflected. Units are in microseconds. The"
                 "default value is 88."
             default = 88;
         PARAM "T5 time 3 wire for BLE"
             uint8
             doc "Defines the time to sample the TX_CONFX before the begining of the TX slot."
                 "Units are in microseconds. The default value is 63."
             default = 63;
         PARAM "T7 time 3 wire for BLE"
             uint8
             doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS. Units are"
                 "in microseconds. The default value is 0 and the maximum value is 1."
             default = 107;
         PARAM "4TH_WIRE"
             uint8
             doc "Defines the GPIO used as 4th wire"
             default = 2;
         PARAM "5TH_WIRE"
             uint8
             doc "Defines the GPIO used as 5th wire"
             default = 3;
         PARAM "GPIO_5WIRE_TYPE"
             uint8
             doc "Select the GPIO on which to route the 4th wire signal."
             enum
             {
                 {0x0, "GPIO2_5WIRE"},
                 {0x1, "GPIOC_5WIRE"},
                 {0x2, "GPIOD_5WIRE"}
             }
             default = 0x0;
         PARAM "SCOThreshold"
             uint8
             doc "Every one of SCOThreshold number of SCO instance will be sent as low priority in 4th wire"
             default = 30;
         PARAM "A2DP Priority inverse threshold"
             uint8{ 7:4 }
             doc "Effective if"
                 "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED is enabled. This paramter defines after how"
                 "many frames defered by the WLAN, the the priority of that defered frame will be"
                 "increased"
             min = 1;
         PARAM "ACL Priority inverse threshold"
             uint8{ 3:0 }
             doc "Effective if"
                 "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED is enabled. This paramter defines after how"
                 "many frames defered by the WLAN, the the priority of that defered frame will be"
                 "increased"
             min = 1;
         PARAM "Priorities"
             uint32
             doc "Bluetooth Priorities per activity"
             bitmap
             {
                 {0x00000001, "STANDBY"},
                 {0x00000002, "LOW_PRI_CONNECTION"},
                 {0x00000004, "AFH_RSSISCAN"},
                 {0x00000008, "BROADCAST"},
                 {0x00000010, "INQUIRY"},
                 {0x00000020, "PAGE"},
                 {0x00000040, "CONNECTION"},
                 {0x00000080, "CONN_WITH_DATA"},
                 {0x00000100, "TPOLL"},
                 {0x00000200, "INQSCAN"},
                 {0x00000400, "PAGESCAN"},
                 {0x00000800, "MASTER_SLAVE_SWITCH"},
                 {0x00001000, "NEW_CONNECTION"},
                 {0x00002000, "SETUP_CONN"},
                 {0x00004000, "MODULO"},
                 {0x00008000, "HOLD"},
                 {0x00010000, "SNIFF"},
                 {0x00020000, "PARK"},
                 {0x00040000, "SCO"},
                 {0x00080000, "ESCO"},
                 {0x00100000, "SLAVE_POLL_LMP"},
                 {0x01000000, "DEFER_HIGH_PRIORITY_FRAME (3 wires only)"},
                 {0x02000000, "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED"},
                 {0x04000000, "DONT_RESET_LCU (2048 only)"},
                 {0x08000000, "NON_CONNECTION_HW_SUPPORT  (2048 only)"},
                 {0x40000000, "PAGE_SCAN_HW_SUPPORT_BIT_0 (2048 only)"},
                 {0x80000000, "PAGE_SCAN_HW_SUPPORT_BIT_1 (2048 only)"}
             };
         PARAM "Configuration flags 1"
             uint32
             doc "Additional configuration flags."
             bitmap
             {
                 {0x00000001, "Coexistence auto selection"},
                 {0x00000002, "Coexistence auto pad config"},
                 {0x01000000, "5WIRE support"},
                 {0x02000000, "A2DP ACL priority inverse"},
                 {0x04000000, "EIR scan mode"},
                 {0x08000000, "Nonconnection LCU reset"},
                 {0x10000000, "Connection hardware support"},
                 {0x80000000, "Hardware coexistence mode"},
                 {0x00010000, "BLE COEX Nokia Mode"},
                 {0x00008000, "BLE COEX Enable"},
                 {0x00004000, "BLE COEX Scan Configure"}
             };
         PARAM "Configuration flags 2"
             uint32
             doc "Additional configuration flags."
             bitmap
             {
                 {0x02000000, "BLE Connection high priority"},
                 {0x01000000, "BLE INIT high priority"},
                 {0x00800000, "BLE SCAN high priority"},
                 {0x00400000, "BLE ADV high priority"},
                 {0x20000000, "Slave poll priority"},
                 {0x40000000, "PS and FHS low priority"},
                 {0x80000000, "LMP high priority"}
             };
         PARAM "ECSI Config"
             uint32
             doc "ECSI related config.";
         PARAM "ECSI Config 1"
             uint32
             doc "ECSI related config 1.";
         PARAM "ECSI Config 2"
             uint32
             doc "ECSI related config 2.";
     }

     COMMAND "HCI LM LC Specific Requests" 0x0311
     {
         doc "This item is to enable/disable customer specific features"
             "that fall in HCI, LM or LC category."
         PARAM "CS config flags"
             uint32
             doc "General customer specific config bitmap."
             bitmap
             {
                 {0x00000001, "Disable sending authentication failure event to host"},
                 {0x00000002, "Send three sco complete events when enter local loopback mode"},
                 {0x00000004, "Enable extra paramters for hci read clock command"},
                 {0x00000008, "Enable BQB Support"},
                 {0x00000010, "Enable small SCO buffers"},
                 {0x00000020, "Enable Return Missing if PIN Request Negative"},
                 {0x00000040, "Enable AFH Block WLAN Channels only"},
                 {0x00000080, "Enable AFH reporting of the Slave even if Master disable channel assesement"},
                 {0x00000100, "Enable Flushing ACL packet while ACL connection is removed"},
                 {0x00000400, "AFH_BLANK_TWO_WLAN_GCHANNELS"},
                 {0x00000800, "Enable AFH rssi scan based on PER"},
                 {0x00001000, "Enabled sending AFH events anytime a new channel map is enabled (for debug only)"},
                 {0x00002000, "Master sends Detach with LMP Response Timeout if LMP Timer expires during locally initiated Authentication"},
                 {0x00004000, "AFH never reclaim blocked WLAN channels"},
                 {0x00008000, "Delete old ACL link if duplicated"},
                 {0x00010000, "Enable NOKSYM_CH8_FM_CMD"},
                 {0x00020000, "Configure Number of Completed Packets threshold value per Nokia requirement"},
                 {0x00040000, "Automatically initiate or reject role switch to avoid slave-slave scatternet"}
             };
     }

     COMMAND "Link Quality Control Configuration" 0x312
     {
         doc "Enables rate control, sets the time history and the update duration"
         PARAM "Allow rate control"
             bool8
             doc "When set to 1 the 2045 will monitor the link quality for each connection";
         PARAM "Time history duration"
             uint8
             doc "The length of time that statistical information is maintained in seconds. The"
                 "minimum value is 4 and the maximum is 20."
             enabled_if ("Allow rate control" = 1)
             min = 4
             max = 20;
         PARAM "Update rate duration"
             uint8
             doc "How often the Link Quality is evaluated for each link in seconds. The minimum"
                 "value is 2 and the maximum is 10."
             enabled_if ("Allow rate control" = 1)
             min = 2
             max = 10;
     }

     COMMAND "Link Quality Thresholds"    0x0313
     {
         doc "The thresholds used to switch between packet types"
         PARAM "Min number of packets for LQ calculation"
             uint8
             doc "If there are less than this number of packets in the stats"
                 "buffer then the BER will be 255";
         PARAM "3-DH5 to 2-DH5 LQ threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "2-DH5 to 3-DH5 LQ threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "2-DH5 to 3-DH5_RSSI"
             int8
             doc "The Raw RSSI must be at or above this threshold to switch to 3-DH5 from 2-DH5";
         PARAM "2-DH5 to 2-DH3 LQ threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                    "best quality";
         PARAM "2-DH3 to 2-DH5 LQ threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                    "best quality";
         PARAM "DH5 to DM5 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "DM5 to DH5 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "DM5 to DM3 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "DM3 to DM5 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "DM3 to DM1 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
         PARAM "DM1 to DM3 threshold"
             uint8
             doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                 "best quality";
     }

     COMMAND "RSSI Config"  0x314
     {
         doc "Sets the RSSI thresholds and interval used for increment and decrement power decisions"
         PARAM "Low Power Limit"
             uint8
             doc "When abs(RSSI) is above this limit, firmware sends LMP_incr_power_req. Raw RSSI"
                 "readings are from 0 to -110 dB.";
         PARAM "High Power Limit"
             uint8
             doc "When abs(RSSI) is below this limit, firmware sends LMP_decr_power_req. Raw RSSI"
                 "readings are from 0 to -110 dB.";
         PARAM "Increment Interval Count"
             uint8
             doc "The minimum number of 125 mSec periods between increment lmp messages"
                 "After the period has expired and other conditions are met, an lmp may be sent.";
         PARAM "Increment Mode"
             uint8
             doc "If set to 0 any sample below the golden range triggers an incr lmp"
                 "If set to 1 the avg. power must be below the golden range to trigger an incr pwr lmp";
         PARAM "Decrement Interval Count"
             uint8
             doc "The minimum number of 125 mSec periods between decrement lmp messages"
                 "After the period has expired and other conditions are met, an lmp may be sent.";
         PARAM "Disable Local Power Control"
             uint8
             doc "When set to 1, local power control will be disabled. The firmware will not change"
                 "the Tx power regardless of any received incr or decr lmp.";
         PARAM "Max Class 2 Power Level"
             uint8
             doc "The Tx power setting in dbm used when the remote device does not support power control";
         PARAM "Agc Status Register Offset"
             int8
             doc "This value is an offset added to the AGC status reg. reading to calculate the correct RSSI";
         PARAM "Max Pwr Request Power Delta Trigger"
             int8
             doc "If the rx power delta between samples is >= this limit, ask the remote device to send max power";
     }

     COMMAND "Scan Interval Threshold" 0x315
     {
         doc "Page/Inquiry scan interval threshold"
         PARAM "Interval threshold in slots"
             uint16
             doc "Scan interval threshold in slots";
     }

     COMMAND "Config Data Version" 0x316
     {
          doc "Sets the configuration data version of the released configuration data file. The value"
              "is set when the CGS source file is compiled to a formal release in CGR format."
          PARAM "Config data version"
              uint16
              doc "The version of configuration data, range is 0x000 to 0xFFF."
              max = 0x0FFF
              binary_message_only
              encode_value = ReleaseParameter("Config data version");
     }

     COMMAND "SCO Parameters"  0x0317
     {
         doc "Sets the SCO and PCM interface parameters."
         PARAM "RESERVED"
             uint32{31:25}
             doc "Pad bits included to fill the parameters out to a uint32."
             binary_message_only
             encode_value = 0
             enabled_if (0 = 1);     # Never
         PARAM "I2S enable"
             uint32{24:24}
             doc "Enables the I2S/PCM interface."
             enum
             {
                 {0x00, "False"},
                 {0x01, "True"}
             };
         PARAM "Sample rate"
             uint32{23:22}
             doc "Sets the sampling rate of the PCM/I2S Interface."
             enum
             {
                 {0x00, "8 KBps"},
                 {0x01, "16 KBps"},
                 {0x02, "4 KBps"}
             };
         PARAM "SCO routing"
             uint32{21:19}
             doc "Sets the SCO data source and destination to either transport or PCM."
             enum
             {
                 {0x00, "PCM"},
                 {0x01, "Transport"}
             };
         PARAM "Clock mode"
             uint32{18:18}
             doc "Specifies whether Bluetooth module to be the master or slave for PCM_CLK signal"
             enum
             {
                 {0x00, "Slave"},
                 {0x01, "Master"}
             };
         PARAM "SCO time slot"
             uint32{17:14}
             doc "Time slot assignment";
         PARAM "Justify"
             uint32{13:13}
             doc "Indicates the data to right justify (fill data shifted out first) or not. Default is left justify"
                 "(fill data shifted out last)."
             enum
             {
                 {0x00, "Left"},
                 {0x01, "Right"}
             };
         PARAM "Fill bits"
             uint32{12:10}
             doc "Specifies the number of bits to be filled.  The maximum value is three."
             max = 3;
         PARAM "Fill data"
             uint32{9:8}
             doc "Indicates the method of filling unused data bits"
             enum
             {
                 {0x00, "0's"},
                 {0x01, "1's"},
                 {0x02, "Signed"},
                 {0x03, "Programmable"}
             };
         PARAM "Fill value"
             uint32{7:6}
             doc "Specifies the value with which to fill unused bits if Fill_Data is set to"
                 "programmable"
             enabled_if ("Fill data" = 0x03)
             max =   if      ("Fill bits" = 0) then  0
                     else if ("Fill bits" = 1) then  1
                     else if ("Fill bits" = 2) then  3
                     else                            7;
         PARAM "PCM interface rate"
             uint32{5:3}
             doc "Indicates the PCM clock frequency."
             enum
             {
                 {0x00, "128 KBps"},
                 {0x01, "256 KBps"},
                 {0x02, "512 KBps"},
                 {0x03, "1024 KBps"},
                 {0x04, "2048 KBps"}
             };
         PARAM "Frame type"
             uint32{2:2}
             doc "Indicates the PCM frame type: short frame or long frame"
             enum
             {
                 {0x00, "Short"},
                 {0x01, "Long"}
             };
         PARAM "Sync mode"
             uint32{1:1}
             doc "Indicates whether Bluetooth module is the master or slave for PCM_SYNC signal"
             enum
             {
                 {0x00, "Slave"},
                 {0x01, "Master"}
             };
         PARAM "Bit order"
             uint32{0:0}
             doc "Indicates whether the LSB bit is shifted out first or not for serial PCM data"
             enum
             {
                 {0x00, "MSB first"},
                 {0x01, "LSB first"}
             };
        }

     COMMAND "Disable Dynamic SCO Data Routing Change" 0x319
     {
         doc "This disables the host to change SCO/eSCO routing between PCM and transport while the"
             "audio connection still active"
         PARAM "Disable"
             uint8
             doc "Boolean parameter to enable or disable dynamic SCO/eSCO data routing change."
                 "Support is enabled by default, this parameter need only ever be set to true."
             binary_message_only
             encode_value = 1;
     }

     COMMAND "LED Control" 0x31A
     {
         doc "Sets the LED behavior as a function of chip state"
          PARAM "LED Global Disable"
              uint8{ 7:7 }
              doc "If set to TRUE then LED logic not used";
          PARAM "GPIO used for led control"
              uint8{ 6:0 }
              doc "The GPIO (0-7) that controls the LED state"
              max = 0x7;
          PARAM "GPIO Open Drain Mode"
              uint8{ 7:7 }
              doc "If set to TRUE then the GPIO is operated in open drain mode";
          PARAM "GPIO sense used to turn LED ON"
              uint8{ 6:0 }
              doc "Sets the sense of the LED GPIO to turn the LED ON"
              enum
              {
                  {0x0, "Set low"},
                  {0x1, "Set high"}
              };
          PARAM "Power-up state priority"
              uint8{ 7:4 }
              doc "The highest priority active attribute will control the LED."
                  "The range of Priority is 0 to 15 decimal."
              min = 0x0
              max = 0xF;
          PARAM "Power-up state mode"
              uint8{ 3:0 }
              doc "The operating mode"
                  "For states other than the Power-up state, the mode may"
                 "be set to State not used."
                 "States that are not used will not control the LED behavior"
             enum
             {
                 {0x0, "State not used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Power-up state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Power-up state mode" = 0x03);
         PARAM "Power-up state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Power-up state mode" = 0x03);
         PARAM "Power-up state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Power-up state mode" = 0x03);
         PARAM "USB global suspend state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "USB global suspend state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "USB global suspend state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB global suspend state mode" = 0x03);
         PARAM "USB global suspend state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB global suspend state mode" = 0x03);
         PARAM "USB global suspend state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB global suspend state mode" = 0x03);
         PARAM "USB selective suspend state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "USB selective suspend state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "USB selective suspend state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB selective suspend state mode" = 0x03);
         PARAM "USB selective suspend state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB selective suspend state mode" = 0x03);
         PARAM "USB selective suspend state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("USB selective suspend state mode" = 0x03);
         PARAM "Connected state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Connected state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Connected state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Connected state mode" = 0x03);
         PARAM "Connected state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Connected state mode" = 0x03);
         PARAM "Connected state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Connected state mode" = 0x03);
         PARAM "Transmit - receive state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Transmit - receive state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Transmit - receive state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Transmit - receive state mode" = 0x03);
         PARAM "Transmit - receive state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Transmit - receive state mode" = 0x03);
         PARAM "Transmit - receive state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Transmit - receive state mode" = 0x03);
         PARAM "Autopairing Phase 1 state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Autopairing Phase 1 state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Autopairing Phase 1 state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 1 state mode" = 0x03);
         PARAM "Autopairing Phase 1 state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 1 state mode" = 0x03);
         PARAM "Autopairing Phase 1 state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 1 state mode" = 0x03);
         PARAM "Autopairing Phase 2 state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Autopairing Phase 2 state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Autopairing Phase 2 state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 2 state mode" = 0x03);
         PARAM "Autopairing Phase 2 state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 2 state mode" = 0x03);
         PARAM "Autopairing Phase 2 state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Autopairing Phase 2 state mode" = 0x03);
         PARAM "Inquiry state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Inquiry state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Inquiry state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry state mode" = 0x03);
         PARAM "Inquiry state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry state mode" = 0x03);
         PARAM "Inquiry state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry state mode" = 0x03);
         PARAM "Page state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Page state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Page state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page state mode" = 0x03);
         PARAM "Page state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page state mode" = 0x03);
         PARAM "Page state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second.."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page state mode" = 0x03);
         PARAM "Radio disabled state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED."
                 "The range of Priority is 0 to 15 decimal."
             min = 0x0
             max = 0xF;
         PARAM "Radio disabled state mode"
             uint8{ 3:0 }
             doc "The operating mode"
                 "For states other than the Power-up state, the mode may be set to State not used."
                 "States that are not used will not control the LED behavior."
             enum
             {
                 {0x0, "State not used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Radio disabled state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second.."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Radio disabled state mode" = 0x03);
         PARAM "Radio disabled state blinking period"
             uint8
             doc "The period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Radio disabled state mode" = 0x03);
         PARAM "Radio disabled state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Radio disabled state mode" = 0x03);
         PARAM "Sleep state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED."
                 "The range of Priority is 0 to 15 decimal."
             min = 0x0
             max = 0xF;
         PARAM "Sleep state mode"
             uint8{ 3:0 }
             doc "The operating mode"
                 "For states other than the Power-up state, the mode may be set to State not used."
                 "States that are not used will not control the LED behavior."
             enum
             {
                 {0x0, "State not used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"}
             };
         PARAM "Sleep state blinking minimum dwell time"
             uint8
             doc "Unused for sleep state.  Necessary because all states require"
                 "same amount of storage in FW."
             enabled_if ("Sleep state mode" = 0x03);
         PARAM "Sleep state blinking period"
             uint8
             doc "Unused for sleep state.  Necessary because all states require"
                 "same amount of storage in FW."
             enabled_if ("Sleep state mode" = 0x03);
         PARAM "Sleep state blinking led on time"
             uint8
             doc "Unused for sleep state.  Necessary because all states require"
                 "same amount of storage in FW."
             enabled_if ("Sleep state mode" = 0x03);
         PARAM "Page scan state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Page scan state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Page scan state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page scan state mode" = 0x03);
         PARAM "Page scan state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page scan state mode" = 0x03);
         PARAM "Page scan state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Page scan state mode" = 0x03);
         PARAM "Inquiry scan state priority"
             uint8{ 7:4 }
             doc "The highest priority active attribute will control the LED"
             min = 0x0
             max = 0xF;
         PARAM "Inquiry scan state mode"
             uint8{ 3:0 }
             doc "The operating mode"
             enum
             {
                 {0x0, "State Not Used"},
                 {0x1, "LED is OFF"},
                 {0x2, "LED is ON"},
                 {0x3, "LED is BLINKING"}
             };
         PARAM "Inquiry scan state blinking minimum dwell time"
             uint8
             doc "The minimum time that the active attribute will control the LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry scan state mode" = 0x03);
         PARAM "Inquiry scan state blinking period"
             uint8
             doc "The Period for a blinking LED."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry scan state mode" = 0x03);
         PARAM "Inquiry scan state blinking led on time"
             uint8
             doc "Duration of the ON time for each period."
                 "Time is expressed in units of 8 counts per second."
                 "For example, 2 seconds is 16 counts."
             enabled_if ("Inquiry scan state mode" = 0x03);
     }

     COMMAND "Radio Control GPIO" 0x31B
     {
         doc "This config item enables controlling the radio through an external GPIO"
             "signal."
         PARAM "Enable GPIO radio control"
             uint8
             doc "Enables GPIO radio control, automatically set to 1 when the config item is present"
             binary_message_only
             encode_value = 1;
         PARAM "GPIO selection"
             uint8
             doc "Designate a GPIO to control the radio. It takes values from 0 to 7"
                 "corresponding to GPIO0 to GPIO7 and values 8 to 15 corresponding to"
                 "AGPIO0 to AGPIO7"
             enum
             {
                 {0x00, "GPIO 0"},
                 {0x01, "GPIO 1"},
                 {0x02, "GPIO 2"},
                 {0x03, "GPIO 3"},
                 {0x04, "GPIO 4"},
                 {0x05, "GPIO 5"},
                 {0x06, "GPIO 6"},
                 {0x07, "GPIO 7"},
                 {0x08, "AGPIO 0"},
                 {0x09, "AGPIO 1"},
                 {0x0a, "AGPIO 2"},
                 {0x0b, "AGPIO 3"},
                 {0x0c, "AGPIO 4"},
                 {0x0d, "AGPIO 5"},
                 {0x0e, "AGPIO 6"},
                 {0x0f, "AGPIO 7"}
             };
         PARAM "Radio off GPIO level"
             uint8
             doc "This value indicates which GPIO level to be considered as the"
                 "indication to turn off the radio. Value 0 is to indicate turning off"
                 "the radio when GPIO is asserted active low. Value 1 is to indicate"
                 "turning off the radio when GPIO is asserted active high."
             enum
             {
                 {0, "Disable Radio when GPIO is low"},
                 {1, "Disable Radio when GPIO is high"}
             };
         PARAM "Radio off latency for disconnect"
             uint8
             doc "This parameter is in the units of 1.28 seconds. After initiating the"
                 "disconnection for active Bluetooth connections it will wait for this"
                 "much time before it actually turning off the radio.";
     }

    	  COMMAND "3D Parameters" 0x31C
        {
            doc "3D Parameters."
            PARAM "Duty Cycle"
                uint32
                doc "Duty cycle to be used";
            PARAM "Shutter Delay Clk"
                uint32
                doc "Shutter Delay Clk";
            PARAM "Shutter Delay PClk"
                uint32
                doc "Shutter Delay PClk";
            PARAM "Mode in Use"
                uint32
                doc "Mode in Use."
                enum
                {
                    {0x00, "debugging mode"},
                    {0x01, "full control mode"},
                    {0x10, "hostless mode"}
                };    
        }

     COMMAND "JITTER_BUFFER_CONFIG" 0x31D
     {
         doc "Configures the Jitter Buffer"
         PARAM "Jitter Buffer Size"
             uint32
             doc "Jitter Buffer Size";
         PARAM "SBC Watermark Level"
             uint32
             doc "SBC Watermark Level";
         PARAM "SBC Lower Threshold Level"
             uint32
             doc "SBC Lower Threshold Level";
         PARAM "SBC Upper Threshold Level"
             uint32
             doc "SBC Upper Threshold Level";
         PARAM "MP3 Watermark Level"
             uint32
             doc "MP3 Watermark Level";
         PARAM "MP3 Lower Threshold Level"
             uint32
             doc "MP3 Lower Threshold Level";
         PARAM "MP3 Upper Threshold Level"
             uint32
             doc "MP3 Upper Threshold Level";
     }

     COMMAND "VAD_CONFIG" 0x31E
     {
         doc "Configures the VAD"
         PARAM "VAD Mode"
             uint8
             doc "VAD Mode";
         PARAM "VAD Silence Threshold"
             uint8
             doc "VAD Silence Threshold";
         PARAM "VAD Hang Over"
             int16
             doc "VAD Hang Over";
         PARAM "VAD Burst Hang Over"
             int16
             doc "VAD Burst Hang Over";
         PARAM "VAD Burst Length"
             int16
             doc "VAD Burst Length";
         PARAM "VAD Threshold DB"
             int16
             doc "VAD Threshold DB";
         PARAM "VAD Threshold BLKDB"
             int16
             doc "VAD Threshold BLKDB";
         PARAM "VAD MAX Threshold DB"
             int16
             doc "VAD MAX Threshold DB";
         PARAM "VAD Bk Noise Init"
             int16
             doc "VAD Bk Noise Init";
         PARAM "VAD MIN Threshold DB"
             int16
             doc "VAD MIN Threshold DB";
         PARAM "VAD Range DB"
             int16
             doc "VAD Range DB";
         PARAM "VAD Silence Window"
             int16
             doc "VAD Silence Window";
         PARAM "VAD Discard Threshold"
             int16
             doc "VAD Discard Threshold";
     }

     COMMAND "PLC_CONFIG" 0x31F
     {
         doc "Configures the PLC"
         PARAM "log[0]"
             uint8{ 7:7 }
             doc "log";
         PARAM "fast_clk[0]"
             uint8{ 6:6 }
             doc "fast_clk";
         PARAM "vol[0]"
             uint8{ 5:5 }
             doc "vol";
         PARAM "eq[0]"
             uint8{ 4:4 }
             doc "eq";
         PARAM "cvsdupdate[0]"
             uint8{ 3:3 }
             doc "cvsdupdate";
         PARAM "lcplc[0]"
             uint8{ 2:1 }
             doc "lcplc";
         PARAM "enabled[0]"
             uint8{ 0:0 }
             doc "enabled";
         PARAM "log[1]"
             uint8{ 7:7 }
             doc "log";
         PARAM "fast_clk[1]"
             uint8{ 6:6 }
             doc "fast_clk";
         PARAM "vol[1]"
             uint8{ 5:5 }
             doc "vol";
         PARAM "eq[1]"
             uint8{ 4:4 }
             doc "eq";
         PARAM "cvsdupdate[1]"
             uint8{ 3:3 }
             doc "cvsdupdate";
         PARAM "lcplc[1]"
             uint8{ 2:1 }
             doc "lcplc";
         PARAM "enabled[1]"
             uint8{ 0:0 }
             doc "enabled";
         PARAM "log[2]"
             uint8{ 7:7 }
             doc "log";
         PARAM "fast_clk[2]"
             uint8{ 6:6 }
             doc "fast_clk";
         PARAM "vol[2]"
             uint8{ 5:5 }
             doc "vol";
         PARAM "eq[2]"
             uint8{ 4:4 }
             doc "eq";
         PARAM "cvsdupdate[2]"
             uint8{ 3:3 }
             doc "cvsdupdate";
         PARAM "lcplc[2]"
             uint8{ 2:1 }
             doc "lcplc";
         PARAM "enabled[2]"
             uint8{ 0:0 }
             doc "enabled";
     }

     COMMAND "BCPP Tx Inq Power Descriptors" 0x321
     {
         doc "BCPP Tx Inq Power Descriptors"
         PARAM "FAB ID"
             uint8
             doc "8-bit unique code for identifying the actual foundary at which"
                 "this device was manufactured. Used to allow variable tuning for"
                 "parts from different foundaries in the same products."
             default = 0xff;   
         PARAM "low power limit"
             int8
             doc "low power limit"
             default = -65;            
         PARAM "high power limit"
             int8
             doc "high power limit"
             default = 10;             
         PARAM "inquiry table length"
             uint16
             doc "inquiry table length";
         PARAM "PowerdB[0]"
             int8
             doc " PowerdB[0] "
             present_if("inquiry table length" > 0);            
         PARAM "RegValue[0]"
             uint8
             doc " RegValue[0] "
             present_if("inquiry table length" > 0);            
         PARAM "PowerdB[1]"
             int8
             doc " PowerdB[1] "
             present_if("inquiry table length" > 1);            
         PARAM "RegValue[1]"
             uint8
             doc " RegValue[1] "
             present_if("inquiry table length" > 1);                         
         PARAM "PowerdB[2]"
             int8
             doc " PowerdB[2] "
             present_if("inquiry table length" > 2);            
         PARAM "RegValue[2]"
             uint8
             doc " RegValue[2] "
             present_if("inquiry table length" > 2);            
         PARAM "PowerdB[3]"
             int8
             doc " PowerdB[3] "
             present_if("inquiry table length" > 3);            
         PARAM "RegValue[3]"
             uint8
             doc " RegValue[3] "
             present_if("inquiry table length" > 3);     
         PARAM "PowerdB[4]"
             int8
             doc " PowerdB[4] "
             present_if("inquiry table length" > 4);            
         PARAM "RegValue[4]"
             uint8
             doc " RegValue[4] "
             present_if("inquiry table length" > 4);            
         PARAM "PowerdB[5]"
             int8
             doc " PowerdB[5] "
             present_if("inquiry table length" > 5);            
         PARAM "RegValue[5]"
             uint8
             doc " RegValue[5] "
             present_if("inquiry table length" > 5);                         
         PARAM "PowerdB[6]"
             int8
             doc " PowerdB[6] "
             present_if("inquiry table length" > 6);            
         PARAM "RegValue[6]"
             uint8
             doc " RegValue[6] "
             present_if("inquiry table length" > 6);            
         PARAM "PowerdB[7]"
             int8
             doc " PowerdB[7] "
             present_if("inquiry table length" > 7);            
         PARAM "RegValue[7]"
             uint8
             doc " RegValue[7] "
             present_if("inquiry table length" > 7);       
         PARAM "LM_INQ_TX_EN"
             uint8
             doc "Enable 8 bits and 32 bits register";
         PARAM "Num Regs8"
             uint8
             doc "Number of 8-bit registers."
             min = 0
             max = 12;
         PARAM "Num Regs32"
             uint8
             doc "Number of 32-bit registers."
             min = 0
             max = 14; 
         PARAM "Addr8[0]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 0);
         PARAM "Mask8[0]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 0);
         PARAM "Data8[0]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 0);
         PARAM "Addr8[1]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 1);
         PARAM "Mask8[1]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 1);
         PARAM "Data8[1]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 1);          
         PARAM "Addr8[2]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 2);
         PARAM "Mask8[2]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 2);
         PARAM "Data8[2]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 2);
         PARAM "Addr8[3]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 3);
         PARAM "Mask8[3]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 3);
         PARAM "Data8[3]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 3);
         PARAM "Addr8[4]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 4);
         PARAM "Mask8[4]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 4);
         PARAM "Data8[4]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 4);
         PARAM "Addr8[5]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 5);
         PARAM "Mask8[5]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 5);
         PARAM "Data8[5]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 5);         
         PARAM "Addr8[6]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 6);
         PARAM "Mask8[6]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 6);
         PARAM "Data8[6]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 6);
         PARAM "Addr8[7]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 7);
         PARAM "Mask8[7]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 7);
         PARAM "Data8[7]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 7);
        PARAM "Addr8[8]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 8);
         PARAM "Mask8[8]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 8);
         PARAM "Data8[8]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 8);
         PARAM "Addr8[9]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 9);
         PARAM "Mask8[9]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 9);
         PARAM "Data8[9]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 9);
         PARAM "Addr8[10]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 10);
         PARAM "Mask8[10]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 10);
         PARAM "Data8[10]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 10);
         PARAM "Addr8[11]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs8" > 11);
         PARAM "Mask8[11]"
             uint8
             doc " 8-bit mask "
             present_if("Num Regs8" > 11);
         PARAM "Data8[11]"
             uint8
             doc " 8-bit data "
             present_if("Num Regs8" > 11);
         PARAM "Addr32[0]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 0);
         PARAM "Mask32[0]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 0);
         PARAM "Data32[0]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 0);
         PARAM "Addr32[1]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 1);
         PARAM "Mask32[1]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 1);
         PARAM "Data32[1]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 1);         
         PARAM "Addr32[2]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 2);
         PARAM "Mask32[2]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 2);
         PARAM "Data32[2]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 2);
         PARAM "Addr32[3]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 3);
         PARAM "Mask32[3]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 3);
         PARAM "Data32[3]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 3);             
         PARAM "Addr32[4]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 4);
         PARAM "Mask32[4]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 4);
         PARAM "Data32[4]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 4);
         PARAM "Addr32[5]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 5);
         PARAM "Mask32[5]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 5);
         PARAM "Data32[5]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 5);          
         PARAM "Addr32[6]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 6);
         PARAM "Mask32[6]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 6);
         PARAM "Data32[6]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 6);
         PARAM "Addr32[7]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 7);
         PARAM "Mask32[7]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 7);
         PARAM "Data32[7]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 7);             
         PARAM "Addr32[8]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 8);
         PARAM "Mask32[8]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 8);
         PARAM "Data32[8]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 8);
         PARAM "Addr32[9]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 9);
         PARAM "Mask32[9]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 9);
         PARAM "Data32[9]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 9);          
         PARAM "Addr32[10]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 10);
         PARAM "Mask32[10]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 10);
         PARAM "Data32[10]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 10);
         PARAM "Addr32[11]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 11);
         PARAM "Mask32[11]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 11);
         PARAM "Data32[11]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 11);              
         PARAM "Addr32[12]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 12);
         PARAM "Mask32[12]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 12);
         PARAM "Data32[12]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 12);
         PARAM "Addr32[13]"
             uint32
             doc " 32-bit addr "
             present_if("Num Regs32" > 13);
         PARAM "Mask32[13]"
             uint32
             doc " 32-bit mask "
             present_if("Num Regs32" > 13);
         PARAM "Data32[13]"
             uint32
             doc " 32-bit data "
             present_if("Num Regs32" > 13);  
         PARAM "2076 lowPwrTbl[0]"
            uint8[3]
             doc " 2076 lowPwrTbl[0] ";
         PARAM "2076 lowPwrTbl[1]"
            uint8[3]
             doc " 2076 lowPwrTbl[1] ";          
         PARAM "2076 lowPwrTbl[2]"
             uint8[3]
             doc " 2076 lowPwrTbl[2] ";           
         PARAM "2076 lowPwrTbl[3]"
             uint8[3]
             doc " 2076 lowPwrTbl[3] ";     
     }

     COMMAND "BT Sleep Configuration" 0x0322
     {
         doc "Allows setting of BT sleep parameters"
         PARAM "BT Sleep Enable"
             bool8
             doc "Used to enable/disable BT clock sleep AND BT short sleep."
                    "BT clock sleep turns off the 1MHz BT clock.  BT short sleep keeps the 1Mhz clock on but turns off parts of the BB.  "
                    "Disabling this flag will disable both BT sleep and BT short sleep.  "
                    "Enabling this flag will enable BT clock sleep, and enable BT short sleep only if BT Short Sleep Enable is also enabled.  ";
         PARAM "BT Short Sleep Enable"
             bool8
             doc "Used to enable/disable BT short sleep. "
                    "BT short sleep keeps the 1MHz BT clock on but turns off parts of the BB.";
     }

     COMMAND "Batch Scan Storage Size" 0x0325
     {
         doc "Sets Batch Scan Storage Size.  Allocated only if Batch Scan feature is enabled via VSC"
         PARAM "Size"
             uint16
             doc "Batch Scan Storage Size in Bytes";
     }

     COMMAND "BT Maximum Slave Piconet Count" 0x0327
     {
         doc "A system-wide setting that decides how many slave piconets are supported."
         PARAM "Max Slave Piconet Count"
             uint8
             doc "Maximum Slave Piconet Count.  Set to 4 to disable Slave Piconet Multiplexing feature.";
     }

     COMMAND "Boost CPU Speed For BT ISRs" 0x0329
     {
         doc "Enable or Disable boosting of CPU speed for BT ISRs."
         PARAM "Boost CPU for BT ISRs"
             uint8
             doc "Enable/Disable boosting of CPU speed";
         PARAM "CPU Increment"
             uint8
             doc "The CPU increment to be used while boosting CPU for BT ISRs.  Refer to CLOCK_FREQ enum.";
     }

     COMMAND "Postpone SSP Key Generation" 0x032B
     {
         doc "Enable postponing of SSP Key Generation"
         PARAM "Postpone BT SSP Key Generation"
             uint8
             doc "Postpone of SSP Key Generation during Write_Simple_Pairing_Mode handling";
     }

     COMMAND "SAM Configuration" 0x032C
     {
         doc "SAM Configuration"
         PARAM "samEnabled"
             bool8
             doc "enable/disable SAM feature"
                 "default is 0";
         PARAM "samDirectTestMode"
             bool8
             doc "enable Direct Test Mode"
                 "default is 0";
         PARAM "samDirectTestBcsEnabled"
             bool8
             doc "enable BCS for direct test mode"
                 "default is 0";
         PARAM "samESamEnabled"
             bool8
             doc "enable ESam format mode"
                 "default is 1";
         PARAM "samOtherLinks"
             bool8
             doc "enable SAM for other links"
                 "default is 1";
     }

     COMMAND "MPAF Thread Stack Size" 0x0500
     {
         doc "Config item code for the MPAF Thread Stack Size."
         PARAM "MPAF stack size"
             uint16
             doc "For MPAF thread stack size.";
     }

     COMMAND "MPAF UART FLEX" 0x0501
     {
         doc "Config item code for Bluetooth MPAF UART FLEX MODE."
         PARAM " UART Buffsize"
             uint16
             doc "UART Recieve buffer size";
         PARAM "Timer Tick"
             uint16
             doc "Latency Timer tick";
     }

     COMMAND "BT MPAF FRAMEWORK" 0x0503
     {
         doc "Config item code for Bluetooth MPAF APP."
         PARAM "MPAF appEnableBitMask"
             uint32
              doc "MPAF APP Enable Bit Mask";
         PARAM "feature map"
             uint32
             doc "For BT MPAF feature Map";
         PARAM "MPAF NV max devinfo"
             uint8
             doc " MPAF Platform config, Maximum device info in NV";
         PARAM "MPAF TRANS MODE"
             uint8
             doc " MPAF config transport mode";
         PARAM "MPAF PKT TYPE"
             uint8
             doc " MPAF transport packet type";
         PARAM "mm_Sbrk_Limit"
             uint32
             doc "MM SBRK Limit";
     }

     COMMAND "BT MPAF STACK" 0x0504
     {
         doc "Config item code for Bluetooth MPAF STACK."
         PARAM "L2C maxChannels"
             uint8
              doc "L2CAP max channel";
         PARAM "L2C maxLinks"
             uint8
              doc "L2CAP max Links";
         PARAM "L2C maxClients"
             uint8
              doc "L2CAP maxClients";
         PARAM "L2C inactivityTOut"
             uint8
              doc "L2CAP inactivity Time Out";
         PARAM "L2C mtuSize"
             uint16
              doc "L2CAP MTU Size";
         PARAM "RFC maxPorts"
             uint8
              doc "RFCOMM Max Ports";
         PARAM "RFC maxConn"
             uint8
              doc "RFCOMM Max Connections";
         PARAM "SDP maxConn"
             uint8
              doc "SDP Max Connections";
         PARAM "SDP maxRecords"
             uint8
              doc "SDP Max Records";
         PARAM "SDP maxDiscRecords"
             uint8
              doc "SDP - The maximum number of record handles retrieved in a search";
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_LDO_CONFIG" 0x051C
     {
         doc "Configure LDO Driver"
         PARAM "RESERVED_0"
             uint32 {31:5}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "LDO Sleep Output Level"
             uint32 {4:2}
             doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
             enum
             {
                 { 0x4,      "LDO_VOUT_0P88V" },
                 { 0x5,      "LDO_VOUT_0P96V" },
                 { 0x6,      "LDO_VOUT_1P04V" },
                 { 0x7,      "LDO_VOUT_1P12V" },
                 { 0x0,      "LDO_VOUT_1P20V" },
                 { 0x1,      "LDO_VOUT_1P24V" },
                 { 0x2,      "LDO_VOUT_1P28V" },
                 { 0x3,      "LDO_VOUT_1P32V" }
    
             }
             default = 0;
    
         PARAM "HIDOFF Powerdown Bandgap Enable"
             uint32 {1}
             doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
             enum
             {
                 {1, "Enable"},
                 {0, "Disable"}
             }
             default = 0;
    
         PARAM "LDO Control Enable"
             uint32 {0}
             doc "Enable LDO control"
             enum
             {
                 {1, "Enable"},
                 {0, "Disable"}
             }
             default = 0;
    
         PARAM "RESERVED_1"
             uint32 {31:26}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "LDO Current Feedback for ESR Zero"
             uint32 {25:24}
             doc "LDO Current Feedback Adjustment."
             max     = 15
             default = 0;
    
         PARAM "LDO Current Limit Adjustment"
             uint32 {23}
             doc "LDO Current Limit Adjustment"
             default = 0;
    
         PARAM "LDO Current Limit Mode"
             uint32 {22}
             doc "The current limit mode if LDO Current limit enable"
               "Default Constant"
             enum
             {
                 {0, "Constant"},
                 {1, "Feedback"}
             }
             default = 0;
    
         PARAM "LDO Current Limit Enable"
             uint32 {21}
             doc "LDO Current limit enable"
               "Default Disable"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             }
             default = 0;
    
         PARAM "LDO VDS Matching Amp Enable"
             uint32 {20}
             doc "Enable VDS matching amplifier for LDO operation"
                 "Default Disable"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             }
             default = 0;
    
         PARAM "LDO Output Adjustment"
             uint32 {19:17}
             doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
             enum
             {
                 { 0x4,      "LDO_VOUT_0P88V" },
                 { 0x5,      "LDO_VOUT_0P96V" },
                 { 0x6,      "LDO_VOUT_1P04V" },
                 { 0x7,      "LDO_VOUT_1P12V" },
                 { 0x0,      "LDO_VOUT_1P20V" },
                 { 0x1,      "LDO_VOUT_1P24V" },
                 { 0x2,      "LDO_VOUT_1P28V" },
                 { 0x3,      "LDO_VOUT_1P32V" }
             }
    
             default = 0;
    
         PARAM "LDO Power Mode"
             uint32 {16}
             doc "LDO power mode."
                 "Default Power Up"
             enum
             {
                 {0, "Power Up"},
                 {1, "Power Down"}
             }
             default = 0;
    
         PARAM "RESERVED_2"
             uint32 {15}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "Bandgap Reference Voltage Adjustment"
             uint32 {14:12}
             doc "Bandgap reference voltage adjustment."
                 "Default 0."
             max     = 7
             default = 0;
    
         PARAM "Bandgap CTAT Current Adjustment"
             uint32 {11:8}
             doc "Bandgap CTAT current adjustment"
                 "Default 0."
             max     = 15
             default = 0;
    
         PARAM "Bandgap PTAT Current Adjustment"
             uint32 {7:4}
             doc "Bandgap PTAT current adjustment."
                 "Default 0."
             max     = 15
             default = 0;
    
         PARAM "Bandgap Power Mode"
             uint32 {3}
             doc "Bandgap low power mode."
                 "Default Power Up"
             enum
             {
                 {0, "Power Up"},
                 {1, "Power Down"}
             }
             default = 0;
    
         PARAM "LPF Filter Off Bandgap Noise"
             uint32 {2:1}
             doc "LPF enable/adjust to filter off BG noise."
                 "Default disabled for fast startup."
             max     = 7
             default = 0;
    
    
         PARAM "Bandgap Low Powermode Enable"
             uint32 {0}
             doc "Bandgap low power mode."
                 "Default enable."
             enum
             {
                 {0, "Enable"},
                 {1, "Disable"}
             }
             default = 0;
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_RTC_CONFIG" 0x051D
     {
         doc "Configure RTC Driver"
    
         PARAM "Oscillator Frequency in kHz"
             uint8
             doc "Oscillator Frequence for RTC. Default = 128 kHz"
             default = 128;
         PARAM "Rtc reference clock"
             uint8
             doc "The reference clock to use for RTC - the 32K or 128 Mia LPO"
                 "seem not used now"
             default = 0;
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_GPIO_DRIVER_CONFIG" 0x051E
     {
         doc "Configures GPIO. 20703 has 3 GPIO ports (port0 - port2)."
             "Port 0 has 16 pins  (GPIO_0 to GPIO_15)"
             "Port 1 has 16 pins (GPIO_16 to GPIO_31)"
             "Port 2 has 8 pins (GPIO_32 to GPIO_39)"
             "The total is 40 pins. "
            
         PARAM "GPIO Count"
            uint8
            doc "This defines the number of GPIO pin that will be configurated in the below configuration. If GPIO pin is not"
                "defined here, the pin will be configured as the default."
            min = 0
            max = 40; 
            
         PARAM "Maximum Port Count"
            uint8
            doc "Defines the maximum number of ports that is used for the pins. 20703 has 3 GPIO ports"
            not_in_binary_message
            decode_value = 0            
            min = 0
            max = 3;
            
         PARAM "GPIO Port[0] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port0 are high when output is enabled."
            present_if ("Maximum Port Count" > 0);
         PARAM "GPIO Port[1] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port1 are high when output is enabled."
            present_if ("Maximum Port Count" > 1);
         PARAM "GPIO Port[2] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port2 are high when output is enabled."
            present_if ("Maximum Port Count" > 2);
         PARAM "GPIO Port[3] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port3 are high when output is enabled."
            present_if ("Maximum Port Count" > 3);
    
         PARAM "Port[0]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_0.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 0);
         PARAM "Pin[0]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_0 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_1[0]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Output mux[0]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_0."
               "The default value is 0"
               present_if ("GPIO Count" > 0);
         PARAM "Hysteresis[0]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_2[0]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Drive[0]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 0);
         PARAM "Pullup Pulldown[0]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_3[0]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_4[0]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Global input[0]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 0);
         PARAM "Output control[0]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_0 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 0);
         PARAM "Interrupt enable[0]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Dual edge trigger[0]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Negative edge trigger[0]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Edge trigger[0]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 0);
         
         
         
         
         
         
         PARAM "Port[1]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_1.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 1);
         PARAM "Pin[1]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_1 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_1[1]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Output mux[1]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_1."
               "The default value is 0"
               present_if ("GPIO Count" > 1);
         PARAM "Hysteresis[1]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_2[1]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Drive[1]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 1);
         PARAM "Pullup Pulldown[1]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_3[1]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_4[1]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Global input[1]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 1);
         PARAM "Output control[1]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_1 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 1);
         PARAM "Interrupt enable[1]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Dual edge trigger[1]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Negative edge trigger[1]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Edge trigger[1]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 1);
         
         
         
         
         
         
         PARAM "Port[2]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_2.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 2);
         PARAM "Pin[2]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_2 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_1[2]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Output mux[2]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_2."
               "The default value is 0"
               present_if ("GPIO Count" > 2);
         PARAM "Hysteresis[2]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_2[2]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Drive[2]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 2);
         PARAM "Pullup Pulldown[2]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_3[2]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_4[2]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Global input[2]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 2);
         PARAM "Output control[2]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_2 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 2);
         PARAM "Interrupt enable[2]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Dual edge trigger[2]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Negative edge trigger[2]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Edge trigger[2]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 2);
         
         
         
         
         
         
         PARAM "Port[3]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_3.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 3);
         PARAM "Pin[3]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_3 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_1[3]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Output mux[3]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_3."
               "The default value is 0"
               present_if ("GPIO Count" > 3);
         PARAM "Hysteresis[3]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_2[3]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Drive[3]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 3);
         PARAM "Pullup Pulldown[3]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_3[3]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_4[3]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Global input[3]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 3);
         PARAM "Output control[3]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_3 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 3);
         PARAM "Interrupt enable[3]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Dual edge trigger[3]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Negative edge trigger[3]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Edge trigger[3]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 3);
         
         
         
         
         
         
         PARAM "Port[4]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_4.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 4);
         PARAM "Pin[4]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_4 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_1[4]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Output mux[4]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_4."
               "The default value is 0"
               present_if ("GPIO Count" > 4);
         PARAM "Hysteresis[4]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_2[4]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Drive[4]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 4);
         PARAM "Pullup Pulldown[4]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_3[4]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_4[4]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Global input[4]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 4);
         PARAM "Output control[4]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_4 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 4);
         PARAM "Interrupt enable[4]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Dual edge trigger[4]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Negative edge trigger[4]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Edge trigger[4]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 4);
         
         
         
         
         
         
         PARAM "Port[5]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_5.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 5);
         PARAM "Pin[5]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_5 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_1[5]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Output mux[5]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_5."
               "The default value is 0"
               present_if ("GPIO Count" > 5);
         PARAM "Hysteresis[5]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_2[5]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Drive[5]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 5);
         PARAM "Pullup Pulldown[5]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_3[5]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_4[5]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Global input[5]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 5);
         PARAM "Output control[5]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_5 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 5);
         PARAM "Interrupt enable[5]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Dual edge trigger[5]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Negative edge trigger[5]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Edge trigger[5]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 5);
         
         
         
         
         
         
         PARAM "Port[6]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_6.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 6);
         PARAM "Pin[6]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_6 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_1[6]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Output mux[6]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_6."
               "The default value is 0"
               present_if ("GPIO Count" > 6);
         PARAM "Hysteresis[6]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_2[6]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Drive[6]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 6);
         PARAM "Pullup Pulldown[6]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_3[6]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_4[6]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Global input[6]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 6);
         PARAM "Output control[6]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_6 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 6);
         PARAM "Interrupt enable[6]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Dual edge trigger[6]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Negative edge trigger[6]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Edge trigger[6]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 6);
         
         
         
         
         
         
         PARAM "Port[7]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_7.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 7);
         PARAM "Pin[7]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_7 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_1[7]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Output mux[7]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_7."
               "The default value is 0"
               present_if ("GPIO Count" > 7);
         PARAM "Hysteresis[7]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_2[7]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Drive[7]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 7);
         PARAM "Pullup Pulldown[7]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_3[7]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_4[7]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Global input[7]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 7);
         PARAM "Output control[7]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_7 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 7);
         PARAM "Interrupt enable[7]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Dual edge trigger[7]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Negative edge trigger[7]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Edge trigger[7]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 7);
         
         
         
         
         
         
         PARAM "Port[8]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_8.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 8);
         PARAM "Pin[8]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_8 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_1[8]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Output mux[8]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_8."
               "The default value is 0"
               present_if ("GPIO Count" > 8);
         PARAM "Hysteresis[8]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_2[8]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Drive[8]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 8);
         PARAM "Pullup Pulldown[8]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_3[8]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_4[8]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Global input[8]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 8);
         PARAM "Output control[8]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_8 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 8);
         PARAM "Interrupt enable[8]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Dual edge trigger[8]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Negative edge trigger[8]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Edge trigger[8]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 8);
         
         
         
         
         
         
         PARAM "Port[9]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_9.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 9);
         PARAM "Pin[9]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_9 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_1[9]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Output mux[9]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_9."
               "The default value is 0"
               present_if ("GPIO Count" > 9);
         PARAM "Hysteresis[9]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_2[9]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Drive[9]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 9);
         PARAM "Pullup Pulldown[9]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_3[9]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_4[9]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Global input[9]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 9);
         PARAM "Output control[9]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_9 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 9);
         PARAM "Interrupt enable[9]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Dual edge trigger[9]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Negative edge trigger[9]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Edge trigger[9]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 9);
         
         
         
         
         
         
         PARAM "Port[10]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_10.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 10);
         PARAM "Pin[10]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_10 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_1[10]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Output mux[10]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_10."
               "The default value is 0"
               present_if ("GPIO Count" > 10);
         PARAM "Hysteresis[10]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_2[10]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Drive[10]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 10);
         PARAM "Pullup Pulldown[10]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_3[10]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_4[10]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Global input[10]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 10);
         PARAM "Output control[10]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_10 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 10);
         PARAM "Interrupt enable[10]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Dual edge trigger[10]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Negative edge trigger[10]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Edge trigger[10]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 10);
         
         
         
         
         
         
         PARAM "Port[11]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_11.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 11);
         PARAM "Pin[11]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_11 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_1[11]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Output mux[11]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_11."
               "The default value is 0"
               present_if ("GPIO Count" > 11);
         PARAM "Hysteresis[11]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_2[11]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Drive[11]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 11);
         PARAM "Pullup Pulldown[11]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_3[11]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_4[11]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Global input[11]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 11);
         PARAM "Output control[11]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_11 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 11);
         PARAM "Interrupt enable[11]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Dual edge trigger[11]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Negative edge trigger[11]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Edge trigger[11]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 11);
         
         
         
         
         
         
         PARAM "Port[12]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_12.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 12);
         PARAM "Pin[12]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_12 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_1[12]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Output mux[12]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_12."
               "The default value is 0"
               present_if ("GPIO Count" > 12);
         PARAM "Hysteresis[12]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_2[12]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Drive[12]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 12);
         PARAM "Pullup Pulldown[12]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_3[12]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_4[12]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Global input[12]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 12);
         PARAM "Output control[12]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_12 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 12);
         PARAM "Interrupt enable[12]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Dual edge trigger[12]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Negative edge trigger[12]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Edge trigger[12]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 12);
         
         
         
         
         
         
         PARAM "Port[13]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_13.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 13);
         PARAM "Pin[13]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_13 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_1[13]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Output mux[13]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_13."
               "The default value is 0"
               present_if ("GPIO Count" > 13);
         PARAM "Hysteresis[13]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_2[13]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Drive[13]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 13);
         PARAM "Pullup Pulldown[13]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_3[13]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_4[13]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Global input[13]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 13);
         PARAM "Output control[13]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_13 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 13);
         PARAM "Interrupt enable[13]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Dual edge trigger[13]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Negative edge trigger[13]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Edge trigger[13]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 13);
         
         
         
         
         
         
         PARAM "Port[14]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_14.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 14);
         PARAM "Pin[14]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_14 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_1[14]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Output mux[14]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_14."
               "The default value is 0"
               present_if ("GPIO Count" > 14);
         PARAM "Hysteresis[14]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_2[14]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Drive[14]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 14);
         PARAM "Pullup Pulldown[14]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_3[14]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_4[14]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Global input[14]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 14);
         PARAM "Output control[14]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_14 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 14);
         PARAM "Interrupt enable[14]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Dual edge trigger[14]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Negative edge trigger[14]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Edge trigger[14]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 14);
         
         
         
         
         
         
         PARAM "Port[15]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_15.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 15);
         PARAM "Pin[15]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_15 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_1[15]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Output mux[15]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_15."
               "The default value is 0"
               present_if ("GPIO Count" > 15);
         PARAM "Hysteresis[15]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_2[15]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Drive[15]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 15);
         PARAM "Pullup Pulldown[15]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_3[15]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_4[15]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Global input[15]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 15);
         PARAM "Output control[15]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_15 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 15);
         PARAM "Interrupt enable[15]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Dual edge trigger[15]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Negative edge trigger[15]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Edge trigger[15]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 15);
         
         
         
         
         
         
         PARAM "Port[16]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_16.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 16);
         PARAM "Pin[16]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_16 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_1[16]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Output mux[16]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_16."
               "The default value is 0"
               present_if ("GPIO Count" > 16);
         PARAM "Hysteresis[16]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_2[16]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Drive[16]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 16);
         PARAM "Pullup Pulldown[16]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_3[16]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_4[16]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Global input[16]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 16);
         PARAM "Output control[16]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_16 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 16);
         PARAM "Interrupt enable[16]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Dual edge trigger[16]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Negative edge trigger[16]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Edge trigger[16]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 16);
         
         
         
         
         
         
         PARAM "Port[17]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_17.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 17);
         PARAM "Pin[17]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_17 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_1[17]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Output mux[17]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_17."
               "The default value is 0"
               present_if ("GPIO Count" > 17);
         PARAM "Hysteresis[17]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_2[17]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Drive[17]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 17);
         PARAM "Pullup Pulldown[17]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_3[17]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_4[17]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Global input[17]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 17);
         PARAM "Output control[17]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_17 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 17);
         PARAM "Interrupt enable[17]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Dual edge trigger[17]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Negative edge trigger[17]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Edge trigger[17]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 17);
         
         
         
         
         
         
         PARAM "Port[18]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_18.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 18);
         PARAM "Pin[18]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_18 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_1[18]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Output mux[18]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_18."
               "The default value is 0"
               present_if ("GPIO Count" > 18);
         PARAM "Hysteresis[18]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_2[18]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Drive[18]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 18);
         PARAM "Pullup Pulldown[18]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_3[18]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_4[18]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Global input[18]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 18);
         PARAM "Output control[18]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_18 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 18);
         PARAM "Interrupt enable[18]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Dual edge trigger[18]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Negative edge trigger[18]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Edge trigger[18]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 18);
         
         
         
         
         
         
         PARAM "Port[19]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_19.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 19);
         PARAM "Pin[19]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_19 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_1[19]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Output mux[19]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_19."
               "The default value is 0"
               present_if ("GPIO Count" > 19);
         PARAM "Hysteresis[19]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_2[19]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Drive[19]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 19);
         PARAM "Pullup Pulldown[19]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_3[19]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_4[19]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Global input[19]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 19);
         PARAM "Output control[19]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_19 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 19);
         PARAM "Interrupt enable[19]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Dual edge trigger[19]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Negative edge trigger[19]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Edge trigger[19]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 19);
         
         
         
         
         
         
         PARAM "Port[20]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_20.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 20);
         PARAM "Pin[20]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_20 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_1[20]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Output mux[20]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_20."
               "The default value is 0"
               present_if ("GPIO Count" > 20);
         PARAM "Hysteresis[20]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_2[20]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Drive[20]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 20);
         PARAM "Pullup Pulldown[20]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_3[20]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_4[20]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Global input[20]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 20);
         PARAM "Output control[20]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_20 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 20);
         PARAM "Interrupt enable[20]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Dual edge trigger[20]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Negative edge trigger[20]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Edge trigger[20]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 20);
         
         
         
         
         
         
         PARAM "Port[21]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_21.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 21);
         PARAM "Pin[21]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_21 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_1[21]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Output mux[21]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_21."
               "The default value is 0"
               present_if ("GPIO Count" > 21);
         PARAM "Hysteresis[21]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_2[21]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Drive[21]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 21);
         PARAM "Pullup Pulldown[21]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_3[21]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_4[21]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Global input[21]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 21);
         PARAM "Output control[21]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_21 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 21);
         PARAM "Interrupt enable[21]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Dual edge trigger[21]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Negative edge trigger[21]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Edge trigger[21]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 21);
         
         
         
         
         
         
         PARAM "Port[22]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_22.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 22);
         PARAM "Pin[22]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_22 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_1[22]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Output mux[22]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_22."
               "The default value is 0"
               present_if ("GPIO Count" > 22);
         PARAM "Hysteresis[22]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_2[22]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Drive[22]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 22);
         PARAM "Pullup Pulldown[22]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_3[22]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_4[22]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Global input[22]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 22);
         PARAM "Output control[22]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_22 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 22);
         PARAM "Interrupt enable[22]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Dual edge trigger[22]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Negative edge trigger[22]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Edge trigger[22]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 22);
         
         
         
         
         
         
         PARAM "Port[23]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_23.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 23);
         PARAM "Pin[23]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_23 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_1[23]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Output mux[23]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_23."
               "The default value is 0"
               present_if ("GPIO Count" > 23);
         PARAM "Hysteresis[23]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_2[23]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Drive[23]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 23);
         PARAM "Pullup Pulldown[23]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_3[23]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_4[23]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Global input[23]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 23);
         PARAM "Output control[23]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_23 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 23);
         PARAM "Interrupt enable[23]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Dual edge trigger[23]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Negative edge trigger[23]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Edge trigger[23]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 23);
         
         
         
         
         
         
         PARAM "Port[24]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_24.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 24);
         PARAM "Pin[24]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_24 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_1[24]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Output mux[24]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_24."
               "The default value is 0"
               present_if ("GPIO Count" > 24);
         PARAM "Hysteresis[24]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_2[24]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Drive[24]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 24);
         PARAM "Pullup Pulldown[24]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_3[24]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_4[24]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Global input[24]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 24);
         PARAM "Output control[24]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_24 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 24);
         PARAM "Interrupt enable[24]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Dual edge trigger[24]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Negative edge trigger[24]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Edge trigger[24]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 24);
         
         
         
         
         
         
         PARAM "Port[25]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_25.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 25);
         PARAM "Pin[25]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_25 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_1[25]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Output mux[25]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_25."
               "The default value is 0"
               present_if ("GPIO Count" > 25);
         PARAM "Hysteresis[25]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_2[25]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Drive[25]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 25);
         PARAM "Pullup Pulldown[25]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_3[25]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_4[25]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Global input[25]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 25);
         PARAM "Output control[25]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_25 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 25);
         PARAM "Interrupt enable[25]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Dual edge trigger[25]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Negative edge trigger[25]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Edge trigger[25]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 25);
         
         
         
         
         
         
         PARAM "Port[26]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_26.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 26);
         PARAM "Pin[26]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_26 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_1[26]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Output mux[26]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_26."
               "The default value is 0"
               present_if ("GPIO Count" > 26);
         PARAM "Hysteresis[26]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_2[26]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Drive[26]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 26);
         PARAM "Pullup Pulldown[26]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_3[26]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_4[26]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Global input[26]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 26);
         PARAM "Output control[26]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_26 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 26);
         PARAM "Interrupt enable[26]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Dual edge trigger[26]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Negative edge trigger[26]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Edge trigger[26]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 26);
         
         
         
         
         
         
         PARAM "Port[27]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_27.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 27);
         PARAM "Pin[27]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_27 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_1[27]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Output mux[27]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_27."
               "The default value is 0"
               present_if ("GPIO Count" > 27);
         PARAM "Hysteresis[27]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_2[27]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Drive[27]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 27);
         PARAM "Pullup Pulldown[27]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_3[27]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_4[27]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Global input[27]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 27);
         PARAM "Output control[27]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_27 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 27);
         PARAM "Interrupt enable[27]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Dual edge trigger[27]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Negative edge trigger[27]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Edge trigger[27]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 27);
         
         
         
         
         
         
         PARAM "Port[28]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_28.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 28);
         PARAM "Pin[28]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_28 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_1[28]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Output mux[28]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_28."
               "The default value is 0"
               present_if ("GPIO Count" > 28);
         PARAM "Hysteresis[28]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_2[28]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Drive[28]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 28);
         PARAM "Pullup Pulldown[28]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_3[28]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_4[28]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Global input[28]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 28);
         PARAM "Output control[28]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_28 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 28);
         PARAM "Interrupt enable[28]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Dual edge trigger[28]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Negative edge trigger[28]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Edge trigger[28]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 28);
         
         
         
         
         
         
         PARAM "Port[29]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_29.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 29);
         PARAM "Pin[29]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_29 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_1[29]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Output mux[29]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_29."
               "The default value is 0"
               present_if ("GPIO Count" > 29);
         PARAM "Hysteresis[29]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_2[29]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Drive[29]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 29);
         PARAM "Pullup Pulldown[29]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_3[29]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_4[29]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Global input[29]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 29);
         PARAM "Output control[29]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_29 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 29);
         PARAM "Interrupt enable[29]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Dual edge trigger[29]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Negative edge trigger[29]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Edge trigger[29]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 29);
         
         
         
         
         
         
         PARAM "Port[30]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_30.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 30);
         PARAM "Pin[30]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_30 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_1[30]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Output mux[30]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_30."
               "The default value is 0"
               present_if ("GPIO Count" > 30);
         PARAM "Hysteresis[30]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_2[30]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Drive[30]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 30);
         PARAM "Pullup Pulldown[30]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_3[30]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_4[30]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Global input[30]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 30);
         PARAM "Output control[30]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_30 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 30);
         PARAM "Interrupt enable[30]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Dual edge trigger[30]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Negative edge trigger[30]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Edge trigger[30]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 30);
         
         
         
         
         
         
         PARAM "Port[31]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_31.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 31);
         PARAM "Pin[31]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_31 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_1[31]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Output mux[31]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_31."
               "The default value is 0"
               present_if ("GPIO Count" > 31);
         PARAM "Hysteresis[31]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_2[31]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Drive[31]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 31);
         PARAM "Pullup Pulldown[31]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_3[31]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_4[31]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Global input[31]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 31);
         PARAM "Output control[31]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_31 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 31);
         PARAM "Interrupt enable[31]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Dual edge trigger[31]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Negative edge trigger[31]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Edge trigger[31]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 31);
         
         
         
         
         
         
         PARAM "Port[32]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_32.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 32);
         PARAM "Pin[32]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_32 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_1[32]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Output mux[32]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_32."
               "The default value is 0"
               present_if ("GPIO Count" > 32);
         PARAM "Hysteresis[32]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_2[32]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Drive[32]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 32);
         PARAM "Pullup Pulldown[32]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_3[32]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_4[32]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Global input[32]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 32);
         PARAM "Output control[32]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_32 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 32);
         PARAM "Interrupt enable[32]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Dual edge trigger[32]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Negative edge trigger[32]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Edge trigger[32]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 32);
         
         
         
         
         
         
         PARAM "Port[33]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_33.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 33);
         PARAM "Pin[33]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_33 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_1[33]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Output mux[33]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_33."
               "The default value is 0"
               present_if ("GPIO Count" > 33);
         PARAM "Hysteresis[33]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_2[33]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Drive[33]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 33);
         PARAM "Pullup Pulldown[33]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_3[33]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_4[33]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Global input[33]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 33);
         PARAM "Output control[33]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_33 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 33);
         PARAM "Interrupt enable[33]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Dual edge trigger[33]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Negative edge trigger[33]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Edge trigger[33]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 33);
         
         
         
         
         
         
         PARAM "Port[34]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_34.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 34);
         PARAM "Pin[34]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_34 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_1[34]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Output mux[34]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_34."
               "The default value is 0"
               present_if ("GPIO Count" > 34);
         PARAM "Hysteresis[34]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_2[34]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Drive[34]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 34);
         PARAM "Pullup Pulldown[34]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_3[34]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_4[34]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Global input[34]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 34);
         PARAM "Output control[34]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_34 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 34);
         PARAM "Interrupt enable[34]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Dual edge trigger[34]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Negative edge trigger[34]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Edge trigger[34]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 34);
         
         
         
         
         
         
         PARAM "Port[35]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_35.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 35);
         PARAM "Pin[35]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_35 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_1[35]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Output mux[35]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_35."
               "The default value is 0"
               present_if ("GPIO Count" > 35);
         PARAM "Hysteresis[35]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_2[35]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Drive[35]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 35);
         PARAM "Pullup Pulldown[35]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_3[35]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_4[35]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Global input[35]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 35);
         PARAM "Output control[35]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_35 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 35);
         PARAM "Interrupt enable[35]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Dual edge trigger[35]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Negative edge trigger[35]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Edge trigger[35]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 35);
         
         
         
         
         
         
         PARAM "Port[36]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_36.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 36);
         PARAM "Pin[36]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_36 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_1[36]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Output mux[36]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_36."
               "The default value is 0"
               present_if ("GPIO Count" > 36);
         PARAM "Hysteresis[36]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_2[36]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Drive[36]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 36);
         PARAM "Pullup Pulldown[36]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_3[36]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_4[36]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Global input[36]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 36);
         PARAM "Output control[36]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_36 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 36);
         PARAM "Interrupt enable[36]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Dual edge trigger[36]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Negative edge trigger[36]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Edge trigger[36]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 36);
         
         
         
         
         
         
         PARAM "Port[37]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_37.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 37);
         PARAM "Pin[37]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_37 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_1[37]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Output mux[37]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_37."
               "The default value is 0"
               present_if ("GPIO Count" > 37);
         PARAM "Hysteresis[37]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_2[37]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Drive[37]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 37);
         PARAM "Pullup Pulldown[37]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_3[37]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_4[37]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Global input[37]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 37);
         PARAM "Output control[37]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_37 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 37);
         PARAM "Interrupt enable[37]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Dual edge trigger[37]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Negative edge trigger[37]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Edge trigger[37]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 37);
         
         
         
         
         
         
         PARAM "Port[38]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_38.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 38);
         PARAM "Pin[38]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_38 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_1[38]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Output mux[38]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_38."
               "The default value is 0"
               present_if ("GPIO Count" > 38);
         PARAM "Hysteresis[38]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_2[38]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Drive[38]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 38);
         PARAM "Pullup Pulldown[38]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_3[38]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_4[38]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Global input[38]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 38);
         PARAM "Output control[38]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_38 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 38);
         PARAM "Interrupt enable[38]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Dual edge trigger[38]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Negative edge trigger[38]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Edge trigger[38]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 38);
         
         
         
         
         
         
         PARAM "Port[39]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_39.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 39);
         PARAM "Pin[39]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_39 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_1[39]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Output mux[39]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_39."
               "The default value is 0"
               present_if ("GPIO Count" > 39);
         PARAM "Hysteresis[39]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_2[39]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Drive[39]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 39);
         PARAM "Pullup Pulldown[39]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_3[39]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_4[39]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Global input[39]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 39);
         PARAM "Output control[39]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_39 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 39);
         PARAM "Interrupt enable[39]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Dual edge trigger[39]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Negative edge trigger[39]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Edge trigger[39]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 39);
         
         
         
         
         
         
         PARAM "Port[40]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_40.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 40);
         PARAM "Pin[40]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_40 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_1[40]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Output mux[40]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_40."
               "The default value is 0"
               present_if ("GPIO Count" > 40);
         PARAM "Hysteresis[40]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_2[40]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Drive[40]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 40);
         PARAM "Pullup Pulldown[40]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_3[40]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_4[40]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Global input[40]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 40);
         PARAM "Output control[40]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_40 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 40);
         PARAM "Interrupt enable[40]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Dual edge trigger[40]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Negative edge trigger[40]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Edge trigger[40]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 40);
         
         
         
         
         
         
         PARAM "Port[41]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_41.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 41);
         PARAM "Pin[41]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_41 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_1[41]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Output mux[41]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_41."
               "The default value is 0"
               present_if ("GPIO Count" > 41);
         PARAM "Hysteresis[41]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_2[41]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Drive[41]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 41);
         PARAM "Pullup Pulldown[41]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_3[41]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_4[41]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Global input[41]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 41);
         PARAM "Output control[41]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_41 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 41);
         PARAM "Interrupt enable[41]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Dual edge trigger[41]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Negative edge trigger[41]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Edge trigger[41]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 41);
         
         
         
         
         
         
         PARAM "Port[42]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_42.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 42);
         PARAM "Pin[42]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_42 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_1[42]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Output mux[42]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_42."
               "The default value is 0"
               present_if ("GPIO Count" > 42);
         PARAM "Hysteresis[42]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_2[42]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Drive[42]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 42);
         PARAM "Pullup Pulldown[42]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_3[42]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_4[42]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Global input[42]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 42);
         PARAM "Output control[42]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_42 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 42);
         PARAM "Interrupt enable[42]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Dual edge trigger[42]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Negative edge trigger[42]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Edge trigger[42]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 42);
         
         
         
         
         
         
         PARAM "Port[43]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_43.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 43);
         PARAM "Pin[43]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_43 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_1[43]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Output mux[43]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_43."
               "The default value is 0"
               present_if ("GPIO Count" > 43);
         PARAM "Hysteresis[43]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_2[43]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Drive[43]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 43);
         PARAM "Pullup Pulldown[43]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_3[43]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_4[43]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Global input[43]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 43);
         PARAM "Output control[43]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_43 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 43);
         PARAM "Interrupt enable[43]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Dual edge trigger[43]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Negative edge trigger[43]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Edge trigger[43]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 43);
         
         
         
         
         
         
         PARAM "Port[44]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_44.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 44);
         PARAM "Pin[44]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_44 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_1[44]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Output mux[44]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_44."
               "The default value is 0"
               present_if ("GPIO Count" > 44);
         PARAM "Hysteresis[44]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_2[44]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Drive[44]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 44);
         PARAM "Pullup Pulldown[44]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_3[44]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_4[44]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Global input[44]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 44);
         PARAM "Output control[44]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_44 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 44);
         PARAM "Interrupt enable[44]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Dual edge trigger[44]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Negative edge trigger[44]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Edge trigger[44]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 44);
         
         
         
         
         
         
         PARAM "Port[45]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_45.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 45);
         PARAM "Pin[45]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_45 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_1[45]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Output mux[45]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_45."
               "The default value is 0"
               present_if ("GPIO Count" > 45);
         PARAM "Hysteresis[45]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_2[45]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Drive[45]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 45);
         PARAM "Pullup Pulldown[45]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_3[45]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_4[45]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Global input[45]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 45);
         PARAM "Output control[45]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_45 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 45);
         PARAM "Interrupt enable[45]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Dual edge trigger[45]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Negative edge trigger[45]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Edge trigger[45]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 45);
         
         
         
         
         
         
         PARAM "Port[46]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_46.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 46);
         PARAM "Pin[46]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_46 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_1[46]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Output mux[46]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_46."
               "The default value is 0"
               present_if ("GPIO Count" > 46);
         PARAM "Hysteresis[46]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_2[46]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Drive[46]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 46);
         PARAM "Pullup Pulldown[46]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_3[46]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_4[46]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Global input[46]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 46);
         PARAM "Output control[46]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_46 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 46);
         PARAM "Interrupt enable[46]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Dual edge trigger[46]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Negative edge trigger[46]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Edge trigger[46]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 46);
         
         
         
         
         
         
         PARAM "Port[47]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_47.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 47);
         PARAM "Pin[47]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_47 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_1[47]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Output mux[47]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_47."
               "The default value is 0"
               present_if ("GPIO Count" > 47);
         PARAM "Hysteresis[47]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_2[47]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Drive[47]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 47);
         PARAM "Pullup Pulldown[47]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_3[47]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_4[47]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Global input[47]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 47);
         PARAM "Output control[47]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_47 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 47);
         PARAM "Interrupt enable[47]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Dual edge trigger[47]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Negative edge trigger[47]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Edge trigger[47]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 47);
         
         
         
         
         
         
         PARAM "Port[48]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_48.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 48);
         PARAM "Pin[48]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_48 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_1[48]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Output mux[48]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_48."
               "The default value is 0"
               present_if ("GPIO Count" > 48);
         PARAM "Hysteresis[48]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_2[48]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Drive[48]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 48);
         PARAM "Pullup Pulldown[48]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_3[48]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_4[48]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Global input[48]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 48);
         PARAM "Output control[48]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_48 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 48);
         PARAM "Interrupt enable[48]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Dual edge trigger[48]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Negative edge trigger[48]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Edge trigger[48]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 48);
         
         
         
         
         
         
         PARAM "Port[49]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_49.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 49);
         PARAM "Pin[49]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_49 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_1[49]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Output mux[49]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_49."
               "The default value is 0"
               present_if ("GPIO Count" > 49);
         PARAM "Hysteresis[49]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_2[49]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Drive[49]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 49);
         PARAM "Pullup Pulldown[49]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_3[49]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_4[49]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Global input[49]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 49);
         PARAM "Output control[49]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_49 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 49);
         PARAM "Interrupt enable[49]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Dual edge trigger[49]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Negative edge trigger[49]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Edge trigger[49]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 49);
         
         
         
         
         
         
         PARAM "Port[50]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_50.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 50);
         PARAM "Pin[50]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_50 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_1[50]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Output mux[50]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_50."
               "The default value is 0"
               present_if ("GPIO Count" > 50);
         PARAM "Hysteresis[50]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_2[50]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Drive[50]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 50);
         PARAM "Pullup Pulldown[50]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_3[50]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_4[50]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Global input[50]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 50);
         PARAM "Output control[50]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_50 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 50);
         PARAM "Interrupt enable[50]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Dual edge trigger[50]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Negative edge trigger[50]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Edge trigger[50]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 50);
         
         
         
         
         
         
         PARAM "Port[51]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_51.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 51);
         PARAM "Pin[51]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_51 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_1[51]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Output mux[51]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_51."
               "The default value is 0"
               present_if ("GPIO Count" > 51);
         PARAM "Hysteresis[51]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_2[51]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Drive[51]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 51);
         PARAM "Pullup Pulldown[51]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_3[51]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_4[51]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Global input[51]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 51);
         PARAM "Output control[51]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_51 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 51);
         PARAM "Interrupt enable[51]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Dual edge trigger[51]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Negative edge trigger[51]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Edge trigger[51]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 51);
         
         
         
         
         
         
         PARAM "Port[52]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_52.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 52);
         PARAM "Pin[52]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_52 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_1[52]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Output mux[52]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_52."
               "The default value is 0"
               present_if ("GPIO Count" > 52);
         PARAM "Hysteresis[52]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_2[52]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Drive[52]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 52);
         PARAM "Pullup Pulldown[52]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_3[52]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_4[52]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Global input[52]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 52);
         PARAM "Output control[52]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_52 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 52);
         PARAM "Interrupt enable[52]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Dual edge trigger[52]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Negative edge trigger[52]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Edge trigger[52]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 52);
         
         
         
         
         
         
         PARAM "Port[53]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_53.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 53);
         PARAM "Pin[53]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_53 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_1[53]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Output mux[53]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_53."
               "The default value is 0"
               present_if ("GPIO Count" > 53);
         PARAM "Hysteresis[53]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_2[53]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Drive[53]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 53);
         PARAM "Pullup Pulldown[53]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_3[53]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_4[53]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Global input[53]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 53);
         PARAM "Output control[53]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_53 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 53);
         PARAM "Interrupt enable[53]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Dual edge trigger[53]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Negative edge trigger[53]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Edge trigger[53]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 53);
         
         
         
         
         
         
         PARAM "Port[54]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_54.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 54);
         PARAM "Pin[54]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_54 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_1[54]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Output mux[54]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_54."
               "The default value is 0"
               present_if ("GPIO Count" > 54);
         PARAM "Hysteresis[54]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_2[54]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Drive[54]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 54);
         PARAM "Pullup Pulldown[54]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_3[54]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_4[54]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Global input[54]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 54);
         PARAM "Output control[54]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_54 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 54);
         PARAM "Interrupt enable[54]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Dual edge trigger[54]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Negative edge trigger[54]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Edge trigger[54]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 54);
         
         
         
         
         
         
         PARAM "Port[55]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_55.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 55);
         PARAM "Pin[55]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_55 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_1[55]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Output mux[55]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_55."
               "The default value is 0"
               present_if ("GPIO Count" > 55);
         PARAM "Hysteresis[55]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_2[55]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Drive[55]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 55);
         PARAM "Pullup Pulldown[55]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_3[55]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_4[55]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Global input[55]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 55);
         PARAM "Output control[55]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_55 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 55);
         PARAM "Interrupt enable[55]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Dual edge trigger[55]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Negative edge trigger[55]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Edge trigger[55]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 55);
         
         
         
         
         
         
         PARAM "Port[56]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_56.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 56);
         PARAM "Pin[56]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_56 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_1[56]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Output mux[56]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_56."
               "The default value is 0"
               present_if ("GPIO Count" > 56);
         PARAM "Hysteresis[56]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_2[56]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Drive[56]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 56);
         PARAM "Pullup Pulldown[56]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_3[56]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_4[56]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Global input[56]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 56);
         PARAM "Output control[56]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_56 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 56);
         PARAM "Interrupt enable[56]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Dual edge trigger[56]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Negative edge trigger[56]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Edge trigger[56]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 56);
         
         
         
         
         
         
         PARAM "Port[57]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_57.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 57);
         PARAM "Pin[57]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_57 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_1[57]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Output mux[57]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_57."
               "The default value is 0"
               present_if ("GPIO Count" > 57);
         PARAM "Hysteresis[57]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_2[57]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Drive[57]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 57);
         PARAM "Pullup Pulldown[57]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0" 
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_3[57]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_4[57]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Global input[57]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0" 
               present_if ("GPIO Count" > 57);
         PARAM "Output control[57]" 
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_57 output."
               "The default value is 0" 
               present_if ("GPIO Count" > 57);
         PARAM "Interrupt enable[57]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Dual edge trigger[57]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Negative edge trigger[57]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Edge trigger[57]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 57);
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_AGILENT_7050_DRIVER_CONFIG" 0x051F
     {
         doc "Configures Agilent 7050 optical sensor interface"
         PARAM "7050 CS Connected to Port"
             uint8
             doc "Defines the GPIO port of 20730 which 7050 CS pin connects to"
                 "Default is 1( port 1)"
             max = 2;
         PARAM "7050 CS Connected to Port Pin"
             uint8
             doc "Defines the pin of the above defined port which 7050 CS pin connects to"
                 "Default is 0( pin 0)"
             max = 15
             note "0=LSB, 15=MSB";
         PARAM "7050 Motion Connected to Port"
             uint8
             doc "Defines the GPIO port of 20730 which 7050 motion pin connects to"
                 "Default is 1( port 1)"
             max = 2;
         PARAM "7050 Motion Connected to Port Pin"
             uint8
             doc "Defines the pin of the above defined port which 7050 motion pin connects to"
                 "Default is 1( pin 1)"
             max = 15
             note "0=LSB, 15=MSB";
         PARAM "7050 Motion Line Pull Config"
             uint16
             doc "Set the input Pull-up, pull-down,float cpnfiguration"
             enum
             {
                 {0x0400, "Pull-Up"},
                 {0x0200, "Pull-Down"},
                 {0x0000, "Floating"}
             };
    
         PARAM "7050 Initial Config Register Value"
             uint8
             doc "Defines the initial value of the 7050 sensor configuration register"
                 "Default is 0x80( 800 dpi)";
         PARAM "SPI speed"
             uint32
             doc "Set to desired speed in KHz"
                 "Default is 500000 (500,000 KHz)";
         PARAM "Delay between SPI write complete to NCS inactive"
             uint8
             doc "Delay in microseconds after the SPI write is complete before NCS is deasserted."
                 "This delay is required by the 7050"
                 "Default is 20 us based on the 7050 spec";
         PARAM "7050 reset delay"
             uint16
             doc "Delay in microseconds after the reset command is issued to the 7050"
                 "Default is 1000 us"
                 "Note that this value is not specified in the 7050 spec"
             min = 1;
         PARAM "7050 Initial Laser Ctrl0 Register Value"
             uint8
             doc "Defines the initial value of the 7050 sensor Laser Ctrl0 register"
                 "Default is 0x0A";
         PARAM "7050 Initial Lsrpwr Cfg0 Register Value"
             uint8
             doc "Defines the initial value of the 7050 sensor Laser Cfg0 register"
                 "Default is 0xFF";
         PARAM "7050 Initial Lsrpwr Cfg1 Register Value"
             uint8
             doc "Defines the initial value of the 7050 sensor Laser Cfg1 register"
                 "Default is 0x00";
         PARAM "7050 Initial Laser Ctrl1 Register Value"
             uint8
             doc "Defines the initial value of the 7050 sensor Laser Ctrl1 register"
                 "Default is 0xA0";
         PARAM "Delay for Spi read in us"
             uint8
             doc "delay for spi-read in us"
                 "Default is 4";
         PARAM "Bust Read Length"
             uint8
             doc "bust read length"
                 "Default is 3";
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_QUADRATURE_DRIVER_CONFIG" 0x0520
     {
         doc "Configuration values for the quadrature driver"
         PARAM "Scan Period"
             uint16
             doc "Defines the initial count value for the QOC scanp counter."
                 "The counter counts at 128KHz rate, reloading the initial"
                 "count when max count of 0xFFFF is reached"
                 "Default is 0xFF00";
         PARAM "QOC LED 0 toggle count"
             uint16
             doc "Defines the instant when QOC LED 0 is toggled to 1"
                 "until the end of scanp counter terminal count of 0xFFFF,"
                 "at which point it toggles back to 0 and the initial"
                 "scanp counter value is reloaded."
                 "Default is 0xFFF0";
         PARAM "QOC LED 1 toggle count"
             uint16
             doc "Defines the instant when QOC LED 1 is toggled to 1"
                 "until the end of scanp counter terminal count of 0xFFFF,"
                 "at which point it toggles back to 0 and the initial"
                 "scanp counter value is reloaded."
                 "Default is 0xFFF0";
         PARAM "QOC LED 2 toggle count"
             uint16
             doc "Defines the instant when QOC LED 2 is toggled to 1"
                 "until the end of scanp counter terminal count of 0xFFFF,"
                 "at which point it toggles back to 0 and the initial"
                 "scanp counter value is reloaded."
                 "Default is 0xFFF0";
         PARAM "QOC LED 3 toggle count"
             uint16
             doc "Defines the instant when the QOC LED 3 is toggled to 1"
                 "until the end of scanp counter terminal count of 0xFFFF,"
                 "at which point it toggles back to 0 and the initial"
                 "scanp counter value is reloaded."
                 "Default is 0";
         PARAM "X axis sample instant"
             uint16
             doc "Defines the instant in the scan cycle when the X axis is sampled"
                 "Default is 0xFFF8";
         PARAM "Y axis sample instant"
             uint16
             doc "Defines the instant in the scan cycle when the Y axis is sampled"
                 "Default is 0xFFF8";
         PARAM "Z axis sample instant"
             uint16
             doc "Defines the instant in the scan cycle when the Z axis is sampled"
                 "Default is 0xFFF8";
         PARAM "Reserved_1"
             uint16 {15:8}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "QOC LED 3 output polarity"
             uint16 {7:6}
             doc "Controls the active and idle states of the QOC LED 3 signal"
                 "Default is 1 when on, tristate when off(open source)"
             enum
             {
                 {0, "1 when on, tristate when off(open source)"},
                 {1, "1 when on, 0 when off"},
                 {2, "tristate when on, 0 when off(open drain)"},
                 {3, "0 when on, 1 when off"}
             };
         PARAM "QOC LED 2 output polarity"
             uint16 {5:4}
             doc "Controls the active and idle states of the QOC LED 2 signal"
                 "Default is 1 when on, tristate when off(open source)"
             enum
             {
                 {0, "1 when on, tristate when off(open source)"},
                 {1, "1 when on, 0 when off"},
                 {2, "tristate when on, 0 when off(open drain)"},
                 {3, "0 when on, 1 when off"}
             };
         PARAM "QOC LED 1 output polarity"
             uint16 {3:2}
             doc "Controls the active and idle states of the QOC LED 1 signal"
                 "Default is 1 when on, tristate when off(open source)"
             enum
             {
                 {0, "1 when on, tristate when off(open source)"},
                 {1, "1 when on, 0 when off"},
                 {2, "tristate when on, 0 when off(open drain)"},
                 {3, "0 when on, 1 when off"}
             };
         PARAM "QOC LED 0 output polarity"
             uint16 {1:0}
             doc "Controls the active and idle states of the QOC LED 0 signal"
                 "Default is 1 when on, 0 when off"
             enum
             {
                 {0, "1 when on, tristate when off(open source)"},
                 {1, "1 when on, 0 when off"},
                 {2, "tristate when on, 0 when off(open drain)"},
                 {3, "0 when on, 1 when off"}
             };
         PARAM "Reserved_2"
             uint8
             doc "Reserved";
         PARAM "Reserved_3"
             uint8
             doc "Reserved";
         PARAM "Reserved_4"
             uint8
             doc "Reserved";
         PARAM "GPIO Config"
             uint16
             doc "Configuration value used for each GPIO pin used for quadrature"
                 "Default is input enable and pullup (0x400)";
         PARAM "Port 0 pins used as the quad input port"
             uint8
             doc "If TRUE, Port 0 selected as quadrature input port (P2,P3,P4,P5,P6,P7)"
                 "If FALSE, Port 2 selected as quadrature input port (P32,P33,P34,P35,P36,P37)"
                 "Default is TRUE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "Reserved_5"
             uint8 {7:4}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Configure P29 as Q0C LED 3"
             uint8 {3}
             doc "Indicates whether P29 should be configured as Q0C LED 0"
                 "If configured, the GPIO configuration for P29"
                 "is changed to the configured value for each line."
                 "If not configured as Q0C LED 3, P29 config is not modified."
                 "Default is FALSE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "Configure P28 as Q0C LED 2"
             uint8 {2}
             doc "Indicates whether P28 should be configured as Q0C LED 2"
                 "If configured, the GPIO configuration for P28"
                 "is changed to the configured value for each line."
                 "If not configured as Q0C LED 2, P28 config is not modified."
                 "Default is FALSE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "Configure P27 as Q0C LED 1"
             uint8 {1}
             doc "Indicates whether P27 should be configured as Q0C LED 1"
                 "If configured, the GPIO configuration for P27"
                 "is changed to the configured value for each line."
                 "If not configured as Q0C LED 1, P27 config is not modified"
          "Default is FALSE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "Configure P26 as Q0C LED 0"
             uint8 {0}
             doc "Indicates whether P26 should be configured as Q0C LED 0"
                 "If configured, the GPIO configuration for P26"
                 "is changed to the configured value for each line."
                 "If not configured as Q0C LED 0, P26 config is not modified"
                 "Default is TRUE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "Z interface control"
             uint8 {7}
             doc "Enables/disables Z interface."
                 "Default is Enable"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Z interface Sampling rate"
             uint8 {6:4}
             doc "Controls Z interface sampling rate"
                 "Default is to sample the Z interface once per scan cycle"
             enum
             {
                 {0, "Once per scan cycle"},
                 {1, "Once per 2 scan cycles"},
                 {2, "Once per 4 scan cycles"},
                 {3, "Once per 8 scan cycles"},
                 {4, "Once per 16 scan cycles"},
                 {5, "Once per 32 scan cycles"},
                 {6, "Once per 64 scan cycles"},
                 {7, "Once per 128 scan cycles"}
             };
         PARAM "XY interface control"
             uint8 {3}
             doc "Enables/disables XY interface"
                 "Note that XY interfaces must be enabled/disabled together"
                 "Default is Disable"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "XY interface Sampling select fixed rate"
             uint8 {2}
             doc "Select XY interface Sampling fixed rate"
                 "Default is TRUE"
             enum
             {
                 {0, "FALSE"},
                 {1, "TRUE"}
             };
         PARAM "XY interface Sampling fixed rate"
             uint8 {1:0}
             doc "Controls XY interface sampling rate"
                 "Default is 128 KHz"
             enum
             {
                 {0, "128 KHz"},
                 {1, "64 KHz"},
                 {2, "32 KHz"},
                 {3, "16 KHz"}
             };
         PARAM "Reserved_6"
             uint8 {7:4}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Scroll with no detent"
             uint8 {3}
             doc "When enabled, allows quadrature decoding for a scroll wheel that uses no detent"
                 "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Reserved_7"
             uint8 {2}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Quadrature interrupt/wakeup control"
             uint8 {1}
             doc "When enabled, allows quadrature interface to interrupt/wakeup the chip when it detects activity"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Quadrature control"
             uint8 {0}
             doc "Master control for the quadrature interface. Must be enabled for X/Y/Z interfaces to work"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "X Axis Data Polling"
             uint8
             doc "Whether the driver should collect X axis data when the HW is polled"
                 "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Y Axis Data Polling"
             uint8
             doc "Whether the driver should collect Y axis data when the HW is polled"
                 "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Z Axis Data Polling"
             uint8
             doc "Whether the driver should collect Z axis data when the HW is polled"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_BUTTON_DRIVER_CONFIG" 0x0521
     {
         doc "Configuration for the button driver"
         PARAM "Number of buttons"
             uint8
             doc "Total bumber of buttons in the HID including the connect button if present"
          "Default is 4"
             min = 0
             max = 16;
         PARAM "Process all buttons on flush"
             uint8
             doc "Whether flush requests to the driver cause the driver to process all pending events"
                 "If disabled, the driver will process pending events normally"
             "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Clear button state on flush"
             uint8
             doc "Whether flush requests cause the driver to reset the state of all buttons to up"
                 "If disabled, the driver does not reset button state on receiving a flush"
             "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Button 0 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
          "Default is 0x0001"
             present_if ("Number of buttons" > 0);
         PARAM "Button 1 report bit"
             uint16
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             "Default is 0x0004"
             present_if ("Number of buttons" > 1);
         PARAM "Button 2 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
             "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             "Default is 0x0002"
            present_if ("Number of buttons" > 2);
         PARAM "Button 3 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
          "Default is 0x8000"
             present_if ("Number of buttons" > 3);
         PARAM "Button 4 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 4);
         PARAM "Button 5 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 5);
         PARAM "Button 6 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 6);
         PARAM "Button 7 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 7);
         PARAM "Button 8 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 8);
         PARAM "Button 9 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 9);
         PARAM "Button 10 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 10);
         PARAM "Button 11 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 11);
         PARAM "Button 12 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 12);
         PARAM "Button 13 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 13);
         PARAM "Button 14 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 14);
         PARAM "Button 15 report bit"
             uint16 
             doc "Maps detected button bit to report bit"
          "Buttons are always detected in sequence; button tied to kso0 is detected"
             "as button 0, button tied to kso19 is detected as button 19, etc."
             present_if ("Number of buttons" > 15);
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_SPIFFY_DRIVER_CONFIG" 0x0522
     {
         doc "Spiffy1 GPIO configuration"
         
         PARAM "Spiffy Master or Slave"
          uint8
          doc "Master or Slave mode"
             enum                                                  
             {					      
                 {1, "Master"},
                 {2, "Slave"}
             };
     
         PARAM "Input Pin Pull Config"
             uint16
             doc "Set the input Pull-up, pull-down,float configuration"
             enum
             {
                 {0x0400, "Pull-Up"},
                 {0x0200, "Pull-Down"},
                 {0x0000, "Floating"}
             };
         PARAM "Spiffy 1 GPIO Config"
          uint32
          doc "Configure for CLK/MOSI/MISO/CS"
             enum  
             {
     
                 {0x00030001, "MASTER2_P03_CLK_P00_MOSI_P01_MISO" },
                 {0x00030005, "MASTER2_P03_CLK_P00_MOSI_P05_MISO" },
                 {0x00030201, "MASTER2_P03_CLK_P02_MOSI_P01_MISO" },
                 {0x00030205, "MASTER2_P03_CLK_P02_MOSI_P05_MISO" },
                 {0x00030401, "MASTER2_P03_CLK_P04_MOSI_P01_MISO" },
                 {0x00030405, "MASTER2_P03_CLK_P04_MOSI_P05_MISO" },
                 {0x00031b01, "MASTER2_P03_CLK_P27_MOSI_P01_MISO" },
                 {0x00031b05, "MASTER2_P03_CLK_P27_MOSI_P05_MISO" },
                 {0x00032601, "MASTER2_P03_CLK_P38_MOSI_P01_MISO" },
                 {0x00032605, "MASTER2_P03_CLK_P38_MOSI_P05_MISO" },
     
                 {0x00070001, "MASTER2_P07_CLK_P00_MOSI_P01_MISO" },
                 {0x00070005, "MASTER2_P07_CLK_P00_MOSI_P05_MISO" },
                 {0x00070201, "MASTER2_P07_CLK_P02_MOSI_P01_MISO" },
                 {0x00070205, "MASTER2_P07_CLK_P02_MOSI_P05_MISO" },
                 {0x00070401, "MASTER2_P07_CLK_P04_MOSI_P01_MISO" },
                 {0x00070405, "MASTER2_P07_CLK_P04_MOSI_P05_MISO" },
                 {0x00071b01, "MASTER2_P07_CLK_P27_MOSI_P01_MISO" },
                 {0x00071b05, "MASTER2_P07_CLK_P27_MOSI_P05_MISO" },
                 {0x00072601, "MASTER2_P07_CLK_P38_MOSI_P01_MISO" },
                 {0x00072605, "MASTER2_P07_CLK_P38_MOSI_P05_MISO" },
                 {0x00180019, "MASTER2_P24_CLK_P00_MOSI_P25_MISO" },
                 {0x00180219, "MASTER2_P24_CLK_P02_MOSI_P25_MISO" },
                 {0x00180419, "MASTER2_P24_CLK_P04_MOSI_P25_MISO" },
                 {0x00181b19, "MASTER2_P24_CLK_P27_MOSI_P25_MISO" },
                 {0x00182619, "MASTER2_P24_CLK_P38_MOSI_P25_MISO" },
                 {0x00240019, "MASTER2_P36_CLK_P00_MOSI_P25_MISO" },
                 {0x00240219, "MASTER2_P36_CLK_P02_MOSI_P25_MISO" },
                 {0x00240419, "MASTER2_P36_CLK_P04_MOSI_P25_MISO" },
                 {0x00241b19, "MASTER2_P36_CLK_P27_MOSI_P25_MISO" },
                 {0x00242619, "MASTER2_P36_CLK_P38_MOSI_P25_MISO" },
                 {0x02030001 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P01_MISO" },
                 {0x02030005 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P05_MISO" },
                 {0x02030019 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P25_MISO" },
                 {0x02030401 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P01_MISO" },
                 {0x02030405 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P05_MISO" },
                 {0x02030419 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P25_MISO" },
                 {0x02070001 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P01_MISO" },
                 {0x02070005 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P05_MISO" },
                 {0x02070019 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P25_MISO" },
                 {0x02070401 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P01_MISO" },
                 {0x02070405 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P05_MISO" },
                 {0x02070419 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P25_MISO" },
                 {0x06030001 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P01_MISO" },
                 {0x06030005 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P05_MISO" },
                 {0x06030019 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P25_MISO" },
                 {0x06030401 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P01_MISO" },
                 {0x06030405 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P05_MISO" },
                 {0x06030419 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P25_MISO" },
                 {0x06070001 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P01_MISO" },
                 {0x06070005 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P05_MISO" },
                 {0x06070019 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P25_MISO" },
                 {0x06070401 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P01_MISO" },
                 {0x06070405 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P05_MISO" },
                 {0x06070419 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P25_MISO" },
                 {0x1a181b01 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P01_MISO" },
                 {0x1a181b05 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P05_MISO" },
                 {0x1a181b19 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P25_MISO" },
                 {0x1a182101 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P01_MISO" },
                 {0x1a182105 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P05_MISO" },
                 {0x1a182119 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P25_MISO" },
                 {0x1a182601 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P01_MISO" },
                 {0x1a182605 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P05_MISO" },
                 {0x1a182619 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P25_MISO" },
                 {0x1a241b01 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P01_MISO" },
                 {0x1a241b05 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P05_MISO" },
                 {0x1a241b19 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P25_MISO" },
                 {0x1a242101 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P01_MISO" },
                 {0x1a242105 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P05_MISO" },
                 {0x1a242119 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P25_MISO" },
                 {0x1a242601 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P01_MISO" },
                 {0x1a242605 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P05_MISO" },
                 {0x1a242619 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P25_MISO" },
                 {0x20181b01 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P01_MISO" },
                 {0x20181b05 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P05_MISO" },
                 {0x20181b19 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P25_MISO" },
                 {0x20182101 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P01_MISO" },
                 {0x20182105 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P05_MISO" },
                 {0x20182119 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P25_MISO" },
                 {0x20182601 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P01_MISO" },
                 {0x20182605 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P05_MISO" },
                 {0x20182619 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P25_MISO" },
                 {0x20241b01 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P01_MISO" },
                 {0x20241b05 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P05_MISO" },
                 {0x20241b19 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P25_MISO" },
                 {0x20242101 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P01_MISO" },
                 {0x20242105 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P05_MISO" },
                 {0x20242119 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P25_MISO" },
                 {0x20242601 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P01_MISO" },
                 {0x20242605 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P05_MISO" },
                 {0x20242619 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P25_MISO" },
                 {0x27181b01 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P01_MISO" },
                 {0x27181b05 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P05_MISO" },
                 {0x27181b19 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P25_MISO" },
                 {0x27182101 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P01_MISO" },
                 {0x27182105 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P05_MISO" },
                 {0x27182119 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P25_MISO" },
                 {0x27182601 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P01_MISO" },
                 {0x27182605 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P05_MISO" },
                 {0x27182619 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P25_MISO" },
                 {0x27241b01 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P01_MISO" },
                 {0x27241b05 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P05_MISO" },
                 {0x27241b19 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P25_MISO" },
                 {0x27242101 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P01_MISO" },
                 {0x27242105 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P05_MISO" },
                 {0x27242119 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P25_MISO" },
                 {0x27242601 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P01_MISO" },
                 {0x27242605 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P05_MISO" },
                 {0x27242619 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P25_MISO" }
             };
     
         PARAM "Spiffy 2 GPIO Config"
          uint32
          doc "Configure for SPI-2 interface, for SPI-2 only support master mode."
             "SCL will be use as SPI clock, SDA will be uase as SPI MOSI, MISO can only works for following GPIO"
             enum     
             {
                 { 0xe0e1e218,"MASTER1_P24_MISO"},
                 { 0xe0e1e21a,"MASTER1_P26_MISO"},
                 { 0xe0e1e220,"MASTER1_P32_MISO"},
                 { 0xe0e1e227,"MASTER1_P39_MISO"}
             };
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_KEYSCAN_DRIVER_CONFIG" 0x0523
     {
         doc "Configuration for the keyscan driver"
         PARAM "Row GPIO Config"
             uint16
             doc "Configuration field for all GPIOs used as rows in the keyscan matrix"
                 "Default is input enable and pullup (0x400)";
         PARAM "Col GPIO Config"
             uint16
             doc "Configuration field for all GPIOs used as columns in the keyscan matrix"
                 "Default is keyscan output enable (0x0010)";
         PARAM "Reserved_6"
             uint32 {31:18}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Extend key cycle control"
             uint32 {17}
             doc "Enable/disable delay in-between keyscans"
                 "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Extend key cycle count"
             uint32 {16:10}
             doc "Inter-keyscan cycle delay in units of 4 MIA clocks"
                 "Default is 0" ;
         PARAM "Micro debounce count"
             uint32 {9:8}
             doc "The keyscan HW detects each key multiple times in every scan. This reduces"
                 "spurious key detection because of noise. This parameters configures the number"
                 "of times the keyscan HW checks each key. Set it to the desired value minus 1,"
                 "e.g. a value of 3 causes the HW to check for the key 4 times."
                 "Default is 3, i.e. each key must be detected 4 times"
             min = 0
             max = 3;
         PARAM "Macro up debounce count"
             uint32 {7:4}
             doc "Use this field to configure the number of full scan cycles in which a key must"
                 "be detected as up before it is reported as up. Set this field to one less than"
                 "the desired value, e.g. set it to 2 if a key should only be reported as up if"
                 "it is detected up for 3 full key scan cycles. Note that this differs from micro"
                 "debounce in that micro debounce checks the same key multiple times within the"
                 "same scan whereas macro debounce works across multiple scans."
                 "Default for this field is 3, i.e. 4 scans"
             min = 0
             max = 15;
         PARAM "Macro down debounce count"
             uint32 {3:0}
             doc "Use this field to configure the number of full scan cycles in which a key must"
                 "be detected as down before it is reported as down. Set this field to one less than"
                 "the desired value, e.g. set it to 2 if a key should only be reported as down if"
                 "it is detected down for 3 full key scan cycles. Note that this differs from micro"
                 "debounce in that micro debounce checks the same key multiple times within the"
                 "same scan whereas macro debounce works across multiple scans."
                 "Default for this field is 3, i.e. 4 scans"
             min = 0
             max = 15;
         PARAM "Reserved_5 of Keyscan"
             uint32 {31:19}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Keyscan clock behavior when idle"
             uint32 {18}
             doc "Defines keyscan clock behavior in idle state"
                 "Default is that the clock is always on, even when there is no user activity"
             enum
             {
                 {0, "Gated off by MIA"},
                 {1, "Always on"}
             };
         PARAM "Keyscan active rows drive"
             uint32 {17}
             doc "Enables/disables active drive on row input in between scans"
                 "This reduces the row pull-up time"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Keyscan active col pull-up"
             uint32 {16}
             doc "Enables/disables pull-up on col output in between scans"
                 "This alleviates slow rise time on large matrices"
                 "Default is disabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Number of cols"
             uint32 {15:11}
             doc "Number of columns in the keyscan matrix"
                 "Programmed value must be one less than the actual value"
                 "For example, set this field to 3 when the keyscan matrix has 4 columns"
                 "Default value is 3 for MOUSE_APP, otherwise 19"
             min = 0
             max = 19;
         PARAM "Number of rows"
             uint32 {10:8}
             doc "Number of rows in the keyscan matrix"
                 "Programmed value must be one less than the actual value"
                 "For example, set this field to 3 when the keyscan matrix has 4 rows"
                 "Default value is 0 for MOUSE_APP, otherwise 7"
             min = 0
             max = 7;
         PARAM "Keyscan RC ext"
             uint32 {7:6}
             doc "Programmable duration between column scans"
                 "Alleviates slow RC delay on large keyboards"
                 "Default is 3 i.e. maximum delay of 3 clocks"
             min = 1
             max = 3;
         PARAM "Reserved_4 of Keyscan"
             uint32 {5}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Reserved_3 of Keyscan"
             uint32 {4}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Reserved_2 of Keyscan"
             uint32 {3}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Keyscan ghost detection"
             uint32 {2}
             doc "Enable keyscan HW ghost detection"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
         PARAM "Reserved_1 of Keyscan"
             uint32 {1}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
         PARAM "Keyscan HW control"
             uint32 {0}
             doc "Enables/disables keyscan HW"
                 "Default is enabled"
             enum
             {
                 {0, "Disable"},
                 {1, "Enable"}
             };
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_MIA_DRIVER_CONFIG" 0x0524
     {
         doc "Configuration item for the MIA Driver object"
         PARAM "Microseconds to Delay After Entering HID-OFF"
             uint32
             doc "The HW takes a little time to enter HID-OFF,"
                 "so this is the time the FW will spin after enabling it."
             default = 10000;
         PARAM "Microseconds to Delay After Enabling Keyscan Block"
             uint16
             doc "number of microseconds to wait for keyscan block to get"
                 "synchronized before go to HID-OFF."
             default = 600;
         PARAM "timedWakeIntPortPin"         
             uint8
             doc "Port and Pin to be used for timed wake interrupt/async wake to PMU"
                 "timedWakeIntPortPin[7:5] = port, timedWakeIntPortPin[4:0] = pin. Default is Port 2, pin 7."
             default = 0x47;           
         PARAM "lpoActiveFreq"         
             uint8
             doc "lpoActiveFreq"
             enum
             {
                 { 0x0,      "HW_LPO_FREQ_128KHZ" },
                 { 0x1,      "HW_LPO_FREQ_32KHZ" },
                 { 0x3,      "HW_LPO_FREQ_16KHZ" }
             }
             default = 0;
         PARAM "lpoHidoffFreq"         
             uint8
             doc "lpoHidoffFreq"
             enum
             {
                 { 0x0,      "HW_LPO_FREQ_128KHZ" },
                 { 0x1,      "HW_LPO_FREQ_32KHZ" },
                 { 0x3,      "HW_LPO_FREQ_16KHZ" }
             }
             default = 0;
         PARAM "keyscan128kFreqAutoSwitchEnable"         
             uint8
             doc "keyscan128kFreqAutoSwitchEnable"
             default = 0;
     }

     COMMAND "MPAF_CONFIG_ITEM_ID_ADC_DRIVER_CONFIG" 0x0525
     {
         doc "Configure ADC driver"
    
         PARAM "Reserved_1"
             uint32 {31}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "ADC internal clock division"
             uint32 {30}
             doc "ADC internal clock division"
             enum
             {
                 {1,  "Enable divide-by-2"},
                 {0,  "Disable divide-by-2"}
             }
             default = 0x0;
    
         PARAM "ADC input range selection for DC measurement path"
             uint32 {29}
             doc "ADC input range selection for DC measurement path"
             enum
             {
                 {0,  "3.6V"},
                 {1,  "1.8V"}
             }
             default = 0x0;
    
         PARAM "Reserved_0"
             uint32 {28:26}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "Global bias current programmability"
             uint32 {25:24}
             doc "Global bias current programmability"
             default = 0x0;
    
         PARAM "Internal/External BG SCF power up sequence selection"
             uint32 {23}
             doc "Internal/External BG SCF power up sequence selection"
             enum
             {
                 {1, "use external power up sequence"},
                 {0, "use internal power up sequence"}
             }
             default = 0x0;
    
         PARAM "External power up sequence for BG SCF bypass"
             uint32 {22}
             doc "External power up sequence for BG SCF bypass"
             enum
             {
                 {1, "Bypass"},
                 {0, "Not bypass"}
             }
             default = 0x0;
    
         PARAM "BG REF switch cap filter bypass"
             uint32 {21}
             doc "BG REF switch cap filter bypass"
             enum
             {
                 {1, "Bypass switch cap filter"},
                 {0, "Enable switch cap filter"}
             }
             default = 0x0;
    
         PARAM " Switch cap filter clock frequency selection"
             uint32 {20:19}
             doc " Switch cap filter clock frequency selection"
             enum
             {
                 {0, "SCF_CLK_DIV_50KHz"},
                 {1, "SCF_CLK_DIV_25KHz"},
                 {2, "SCF_CLK_DIV_100KHz"},
                 {3, "SCF_CLK_DIV_1p6MHz"}
             }
             default = 0x0;
    
         PARAM "ADC reference voltage programmability"
             uint32 {18:15}
             doc "ADC reference voltage programmability"
             enum
             {
                 {0, "850"},
                 {1, "856.1"},
                 {2, "862.1"},
                 {3, "868.2"},
                 {4, "874.3"},
                 {5, "880.4"},
                 {6, "886.4"},
                 {7, "892.5"},
                 {8, "801.4"},
                 {9, "807.5"},
                 {10, "813.6"},
                 {11, "819.6"},
                 {12, "825.7"},
                 {13, "831.8"},
                 {14, "837.9"},
                 {15, "843.9"}
             }
             default = 0x0;
    
         PARAM "BG CTAT current adjustment"
             uint32 {14:12}
             doc "BG CTAT current adjustment"
             enum
             {
                 {0, "CTAT Current adjustment 0"},
                 {1, "CTAT Current adjustment 0.92"},
                 {2, "CTAT Current adjustment 1.92"},
                 {3, "CTAT Current adjustment 3.02"},
                 {4, "CTAT Current adjustment -3.51"},
                 {5, "CTAT Current adjustment -2.68"},
                 {6, "CTAT Current adjustment -1.82"},
                 {7, "CTAT Current adjustment -0.93"}
             }
             default = 0x0;
    
         PARAM "BG PTAT current adjustment"
             uint32 {11:9}
             doc "BG PTAT current adjustment"
             enum
             {
                 {0, "PTAT Current adjustment 0"},
                 {1, "PTAT Current adjustment 1.11"},
                 {2, "PTAT Current adjustment 2.32"},
                 {3, "PTAT Current adjustment 3.62"},
                 {4, "PTAT Current adjustment -4.10"},
                 {5, "PTAT Current adjustment -3.19"},
                 {6, "PTAT Current adjustment -2.17"},
                 {7, "PTAT Current adjustment -1.11"}
             }
             default = 0x0;
    
         PARAM "Chip global power down control"
             uint32 {8}
             doc "Chip global power down control"
             enum
             {
                 {1, "Power down"},
                 {0, "Power up"}
             }
             default = 0x0;
    
         PARAM "MIC path power up/down control selection in DC measurement mode"
             uint32 {7}
             doc "MIC path power up/down control selection in DC measurement mode"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
         PARAM "MIC (Audio) input and DC measurement input selection"
             uint32 {6}
             doc "MIC (Audio) input and DC measurement input selection"
             enum
             {
                 {1, "ADC in Audio mode"},
                 {0, "ADC in DC mode"}
             }
             default = 0x0;
    
         PARAM "Output synchronization clock phase controls"
             uint32 {5}
             doc "Output synchronization clock phase control"
             enum
             {
                 {1, "Inverted click phase"},
                 {0, "Non-inverted clock phase"}
             }
             default = 0x0;
    
         PARAM "MIC bias power up/down"
             uint32 {4}
             doc "MIC bias power up/down"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
         PARAM "ADC MIC (Audio) path power up/down control"
             uint32 {3}
             doc "ADC MIC (Audio) path power up/down control"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
         PARAM "ADC core power up/down"
             uint32 {2}
             doc "ADC core power up/down"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
         PARAM "ADC BG & REF power up/down"
             uint32 {1}
             doc "ADC BG & REF power up/down"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
         PARAM "ADC IP level main power up/down control"
             uint32 {0}
             doc "ADC IP level main power up/down control"
             enum
             {
                 {1, "Power up"},
                 {0, "Power down"}
             }
             default = 0x0;
    
    
         PARAM "Reserved_3"
             uint32 {31:23}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "MIC negative input select"
             uint32 {22}
             doc "MIC negative input select"
                 "default 0x0"
             default = 0x0;
    
         PARAM "MIC_PGA_incmres_ctl"
             uint32 {21:20}
             doc "MIC_PGA_incmres_ctl"
                 "default 0x0"
             default = 0x0;
    
         PARAM "PGA output common mode control"
             uint32 {19:18}
             doc "PGA output common mode control"
                 "default = 0.6V"
             enum
             {
                 {0x0,  "0.6V"},
                 {0x1,  "0.7V"},
                 {0x2,  "0.5V"}
             }
             default = 0x0;
    
         PARAM "PGA input common mode control"
             uint32 {17:16}
             doc "PGA input common mode control"
                 "default = 0.4*AVDD"
             enum
             {
                 {0x0,  "0.4*AVDD"},
                 {0x1,  "0.45*AVDD"},
                 {0x2,  "0.35*AVDD"}
             }
             default = 0x0;
    
         PARAM "Reserved_19"
             uint32 {15:12}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "MIC bias output impedance control"
             uint32 {11}
             doc "MIC bias low/high output impedance control during power down mode"
                 "default = MIC bias output is HZ in power down mode"
             enum
             {
                 {0x0,  "MIC bias output is HZ in power down mode"},
                 {0x1,  "MIC bias output is LZ in power down mode"}
             }
             default = 0x0;
    
         PARAM "Internal/External MIC bias SCF power up sequence selection"
             uint32 {10}
             doc "Internal/External MIC bias SCF power up sequence selection"
             enum
             {
                 {0x0,  "Use internal power up sequence"},
                 {0x1,  "Use external power up sequence"}
             }
             default = 0x0;
    
         PARAM "External power up sequence for MIC bias SCF bypass"
             uint32 {9}
             doc "External power up sequence for MIC bias SCF bypass"
             default = 0x0;
    
         PARAM "Reserved_2"
             uint32 {8}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "MIC bias switch cap filter bypass"
             uint32 {7}
             doc "MIC bias switch cap filter bypass"
                 "default = Enable switch cap filter"
             enum
             {
                 {0x0,  "Enable switch cap filter"},
                 {0x1,  "Bypass switch cap filter"}
             }
             default = 0x0;
    
         PARAM "MIC bias reference filter clock programmability"
             uint32 {6:5}
             doc "MIC bias reference filter clock programmability"
                 "default = 50KHz"
             enum
             {
                 {0x0,  "50KHz"},
                 {0x1,  "25KHz"},
                 {0x2,  "100KHz"},
                 {0x3,  "1.6MHz"}
             }
             default = 0x0;
    
         PARAM "MIC bias reference selection"
             uint32 {4}
             doc "MIC bias reference selection"
                 "default = Supply as MIC bias reference"
             enum
             {
                 {0x0,  "Supply as MIC bias reference. MIC bias output voltage scaled with supply voltage"},
                 {0x1,  "BG voltage as MIC bias reference to have constant MIC bias output voltage"}
             }
             default = 0x0;
    
         PARAM "MIC bias output voltage programmability"
             uint32 {3:2}
             doc "MIC bias output voltage programmability"
                 "default = 1.12 X Reference Voltage"
             enum
             {
                 {0x0,  "1.12 X Reference Voltage"},
                 {0x1,  "1.14 X Reference voltage"},
                 {0x2,  "1.17 X Reference voltage"},
                 {0x3,  "1.10 X Reference voltage"}
             }
             default = 0x0;
    
         PARAM "MIC bias reference voltage programmability"
             uint32 {1:0}
             doc "MIC bias reference voltage programmability"
                 "default = 75% of Audio Supply"
             enum
             {
                 {0x0,  "75% of Audio Supply"},
                 {0x1,  "70% of Audio Supply"},
                 {0x2,  "80% of Audio Supply"},
                 {0x3,  "70% of Audio Supply"}
             }
             default = 0x0;
    
    
         PARAM "Spare_0"
             uint32 {31:22}
             doc "Spare register"
             binary_message_only
             encode_value = 0;
    
         PARAM "Reserved_20"
             uint32 {21:18}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "MIC PGA gain control"
             uint32 {17:12}
             doc "MIC PGA gain control: 1dB steps"
             default = 0x0;
    
         PARAM "PGA clamp threshold voltage control"
             uint32 {11:10}
             doc "PGA clamp threshold voltage control"
             enum
             {
                 {0x0,  "0.95V"},
                 {0x1,  "0.925V"},
                 {0x2,  "0.975V"},
                 {0x3,  "1V"}
             }
             default = 0x0;
    
         PARAM "MIC PGA clamping enable"
             uint32 {9}
             doc "MIC PGA clamping enable"
             enum
             {
                 {1,  "Enable"},
                 {0,  "Disable"}
             }
             default = 0x1;
    
         PARAM "Disable reset function on DC measurement"
             uint32 {8}
             doc "Disable reset function on DC measurement"
             enum
             {
                 {1,  "Enable"},
                 {0,  "Disable"}
             }
             default = 0x0;
    
         PARAM "Disable the shuffler"
             uint32 {7}
             doc "Disable the shuffler"
                 "Disable"
             enum
             {
                 {1,  "Enable"},
                 {0,  "Disable"}
             }
             default = 0x0;
    
         PARAM "Dither Sequence control"
             uint32 {6:5}
             doc "Dither Sequence control"
                 "No dither"
             enum
             {
                 {0,  "No dither"},
                 {1,  "prbs15"},
                 {2,  "prbs23"},
                 {3,  "prbs31"}
             }
             default = 0x0;
    
         PARAM "ADC DC input selection"
             uint32 {4:0}
             doc "ADC DC input selection"
             enum
             {
                 {0x0,  "ADC_INPUT_P17"},
                 {0x1,  "ADC_INPUT_P16"},
                 {0x2,  "ADC_INPUT_P15"},
                 {0x3,  "ADC_INPUT_P14"},
                 {0x4,  "ADC_INPUT_P13"},
                 {0x5,  "ADC_INPUT_P12"},
                 {0x6,  "ADC_INPUT_P11"},
                 {0x7,  "ADC_INPUT_P10"},
                 {0x8,  "ADC_INPUT_P9"},
                 {0x9,  "ADC_INPUT_P8"},
                 {0xA,  "ADC_INPUT_P1"},
                 {0xB,  "ADC_INPUT_P0"},
                 {0xC,  "ADC_INPUT_VDDIO"},
                 {0xD,  "ADC_INPUT_VDD_CORE"},
                 {0xE,  "ADC_INPUT_ADC_BGREF"},
                 {0xF,  "ADC_INPUT_ADC_REFGND"},
                 {0x10,  "ADC_INPUT_P38"},
                 {0x11,  "ADC_INPUT_P37"},
                 {0x12,  "ADC_INPUT_P36"},
                 {0x13,  "ADC_INPUT_P35"},
                 {0x14,  "ADC_INPUT_P34"},
                 {0x15,  "ADC_INPUT_P33"},
                 {0x16,  "ADC_INPUT_P32"},
                 {0x17,  "ADC_INPUT_P31"},
                 {0x18,  "ADC_INPUT_P30"},
                 {0x19,  "ADC_INPUT_P29"},
                 {0x1A,  "ADC_INPUT_P28"},
                 {0x1B,  "ADC_INPUT_P23"},
                 {0x1C,  "ADC_INPUT_P22"},
                 {0x1D,  "ADC_INPUT_P21"},
                 {0x1E,  "ADC_INPUT_P19"},
                 {0x1F,  "ADC_INPUT_P18"}
             }
             default = 0x0;
    
         PARAM "Reserved_6"
             uint32 {31:24}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "ADC latency count max."
             uint32 {23:16}
             doc "ADC latency count max., value = (divide ratio - 1), for example, 0xf = divide by 16"
                 "Default = 0xf"
             default = 0xf;
    
         PARAM "Reserved_5"
             uint32 {15:14}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "ADC latency count software reset"
             uint32 {13}
             doc "ADC latency count software reset"
             enum
             {
                 {0,  "No effect"},
                 {1,  "Software reset latency_cnt to adc_latency_cnt_max"}
             }
             default = 0;
    
         PARAM "ADC uses latency count"
             uint32 {12}
             doc "ADC uses latency count"
             enum
             {
                 {0,  "latency_cnt has no effect"},
                 {1,  "latency_cnt has effect"}
             }
             default = 0;
    
         PARAM "ADC debug output select"
             uint32 {11:9}
             doc "ADC debug output select"
             enum
             {
                 {0,  "adc_sample_o[23:20], adc_sample_o[13:10], adc_sample_o[19:14], adc_sample_o[9:8], adc_sample_tick"},
                 {1,  "adc_sample_o[23:8], adc_sample_tick"},
                 {2,  "adc_sample_o[15:0], adc_sample_tick"},
                 {3,  "13'b0, rst_clk_adc_n, clk_adc_lv, ds2b"},
                 {4,  "14'b0, DMACCLR, DMACBREQ, DMACLBREQ"},
                 {5,  "12'b0, api_rclk_lv, api_fclk, api_bclk, api_serDatOut, adc_sample_ready"},
                 {6,  "adc_fifo_sample[15:0], DMACCLR"},
                 {7,  "adc_fifo_sample[31:16], DMACCLR"}
             }
             default = 0;
    
         PARAM "Data alignment mode of ADC DMA interface and pattern generator"
             uint32 {8}
             doc "Data alignment mode of ADC DMA interface and pattern generator"
             enum
             {
                 {0,  "MSB aligned"},
                 {1,  "LSB aligned"}
             }
             default = 0;
    
         PARAM "pattern generator init source select"
             uint32 {7}
             doc "pattern generator init source select"
             enum
             {
                 {0,  "adc_pat_gen_init register"},
                 {1,  "ADC DMA interface"}
             }
             default = 0;
    
         PARAM "ADC API interface input select"
             uint32 {6}
             doc "ADC API interface input select"
             enum
             {
                 {0,  "ADC filter output"},
                 {1,  "pattern generator output"}
             }
             default = 0;
    
         PARAM "ADC DMA interface input select"
             uint32 {5}
             doc "ADC DMA interface input select"
             enum
             {
                 {0,  "ADC filter output"},
                 {1,  "pattern generator output"}
             }
             default = 0;
    
         PARAM "Pattern generator software init"
             uint32 {4}
             doc "Pattern generator software init, only has effect when adc_pat_gen_source == 0"
             default = 0;
    
         PARAM "Pattern generator clock enable"
             uint32 {3}
             doc "Pattern generator clock enable"
             enum
             {
                 {0,  "Disable"},
                 {1,  "Enable"}
             }
             default = 0;
    
         PARAM "Pattern generator output mode"
             uint32 {2:0}
             doc "Pattern generator output mode"
             enum
             {
                 {0,  "MODE_24B_W32B"},
                 {1,  "MODE_24B_OFF3"},
                 {2,  "MODE_24B_SAME"},
                 {3,  "MODE_8B"},
                 {4,  "MODE_16B_SAME"},
                 {5,  "MODE_16B_OFF2"},
                 {6,  "MODE_ZERO"},
                 {7,  "MODE_FF"}
             }
             default = 0;
        
         PARAM "Reserved_7"
             uint32 {31:3}
             doc "Reserved (Pin)"
             binary_message_only
             encode_value = 0;
    
         PARAM "Mode of operation of the CIC filter"
             uint32 {2:0}
             doc "Mode of operation of the CIC filter"
                 "default FILTER_CTL0_REG_DF_MODE_96KHz"
             enum
             {
                 {0,  "DF_MODE_480KHz_FAST"},
                 {1,  "DF_MODE_480KHz_MED"},
                 {2,  "DF_MODE_480KHz_SLOW"},
                 {3,  "DF_MODE_16KHz_ANA"},
                 {4,  "DF_MODE_16KHz_DIG"},
                 {5,  "DF_MODE_8KHz_ANA"},
                 {6,  "DF_MODE_8KHz_DIG"}
             }
             default = 1;
    
    
         PARAM "High Pass Filter Denominator Co-efficient"
             uint32 {31:16}
             doc "High Pass Filter Denominator Co-efficient"
             default = 0x81b5;
    
         PARAM "High Pass Filter Numerator Co-efficient"
             uint32 {15:0}
             doc "High Pass Filter Numerator Co-efficient"
             default = 0x3f27;
    
    
         PARAM "Biquad 2 numerator  - 1 (LPF)"
             uint32 {31:16}
             doc "Biquad 2 numerator  - 1 (LPF)"
             default = 0;
    
         PARAM "Biquad 1 numerator - 1 (LPF)"
             uint32 {15:0}
             doc "Biquad 1 numerator - 1 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 4 numerator - 1 (LPF)"
             uint32 {31:16}
             doc "Biquad 4 numerator - 1 (LPF)"
             default = 0;
    
         PARAM "Biquad 3 numerator - 1 (LPF)"
             uint32 {15:0}
             doc "Biquad 3 numerator - 1 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 2 numerator - 2 (LPF)"
             uint32 {31:16}
             doc "Biquad 2 numerator - 2 (LPF)"
             default = 0;
    
         PARAM "Biquad 1 numerator - 2 (LPF)"
             uint32 {15:0}
             doc "Biquad 1 numerator - 2 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 4 numerator -2 (LPF)"
             uint32 {31:16}
             doc "Biquad 4 numerator -2 (LPF)"
             default = 0;
    
         PARAM "Biquad 3 numerator - 2 (LPF)"
             uint32 {15:0}
             doc "Biquad 3 numerator - 2 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 2 denominator - 1 (LPF)"
             uint32 {31:16}
             doc "Biquad 2 denominator - 1 (LPF)"
             default = 0;
    
         PARAM "Biquad 1 denominator - 1 (LPF)"
             uint32 {15:0}
             doc "Biquad 1 denominator - 1 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 4 denominator - 1 (LPF)"
             uint32 {31:16}
             doc "Biquad 4 denominator - 1 (LPF)"
             default = 0;
    
         PARAM "Biquad 3 denominator - 1 (LPF)"
             uint32 {15:0}
             doc "Biquad 3 denominator - 1 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 2 denominator - 2 (LPF)"
             uint32 {31:16}
             doc "Biquad 2 denominator - 2 (LPF)"
             default = 0;
    
         PARAM "Biquad 1 denominator - 2 (LPF)"
             uint32 {15:0}
             doc "Biquad 1 denominator - 2 (LPF)"
             default = 0;
    
    
         PARAM "Biquad 4 denominator - 2 (LPF)"
             uint32 {31:16}
             doc "Biquad 4 denominator - 2 (LPF)"
             default = 0;
    
         PARAM "Biquad 3 denominator - 2 (LPF)"
             uint32 {15:0}
             doc "Biquad 3 denominator - 2 (LPF)"
             default = 0;
    
    
         PARAM "ADC output precision"
             uint32 {31:30}
             doc "ADC output precision"
                 "default = 24 Bits"
             enum
             {
                 {0,  "24 Bits"},
                 {1,  "16 Bits"},
                 {2,  "8 Bits"}
             }
             default = 0;
    
         PARAM "Low pass filter rate"
             uint32 {29:28}
             doc "Low pass filter rate"
                 "default = 64KHz"
             enum
             {
                 {0,  "8KHz"},
                 {1,  "16KHz"},
                 {2,  "64KHz"},
                 {3,  "128KHz"}
             }
             default = 2;
    
         PARAM "Bypass mapper"
             uint32 {27}
             doc "Bypass mapper"
             enum
             {
                 {0,  "No bypass"},
                 {1,  "Bypass"}
             }
             default = 0;
    
         PARAM "ADC output rate"
             uint32 {26:24}
             doc "ADC output rate, Used to vary sampling rate of the high pass filter"
             default = 0x4;
    
         PARAM "auxAdcMpr"
             uint32 {23}
             doc "auxAdcMpr"
             default = 0x0;
    
         PARAM "To select between dc measurement and audio"
             uint32 {22}
             doc "To select between dc measurement and audio"
             enum
             {
                 {0,  "DC mode"},
                 {1,  "Audio mode"}
             }
             default = 0;
    
         PARAM "Flag to bypass high pass filter (if there is no DC)"
             uint32 {21}
             doc "Flag to bypass high pass filter (if there is no DC)"
             enum
             {
                 {0,  "Not bypass filter"},
                 {1,  "Bypass filter"}
             }
             default = 0;
    
         PARAM "Output strobe rate that is used to decimate the output:  1 - 16KHz, 0 - 8KHz"
             uint32 {20}
             doc "Output strobe rate that is used to decimate the output:  1 - 16KHz, 0 - 8KHz"
                 "default = 8KHz"
             enum
             {
                 {0,  "8KHz"},
                 {1,  "16KHz"}
             }
             default = 0;
    
         PARAM "Gain corresponding to second-order-section (biquad) implementation"
             uint32 {19:0}
             doc "Gain corresponding to second-order-section (biquad) implementation"
             default = 0x764;
    
    
         PARAM "Spare_1"
             uint32 {31:16}
             doc "Spare register"
             binary_message_only
             encode_value = 0;
    
         PARAM "Reserved_8"
             uint32 {15:10}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "df3Byp"
             uint32 {9}
             doc "df3Byp"
             default = 0x0;
    
         PARAM "adc channel sel"
             uint32 {8}
             doc "channel select for adc decimation filter (read status and debug pin out)."
             default = 0x0;
    
         PARAM "Mapper input corresponding to 11"
             uint32 {7:6}
             doc "Mapper input corresponding to 11"
             default = 0x1;
    
         PARAM "Mapper input corresponding to 10 - Same as Mapper input corresponding to 01"
             uint32 {5:4}
             doc "Mapper input corresponding to 10 - Same as Mapper input corresponding to 01"
             default = 0x0;
    
         PARAM "Mapper input corresponding to 01"
             uint32 {3:2}
             doc "Mapper input corresponding to 01"
             default = 0x0;
    
         PARAM "Mapper input corresponding to 00"
             uint32 {1:0}
             doc "Mapper input corresponding to 00"
             default = 0x3;
    
    
         PARAM "Reserved_9"
             uint32 {31:8}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "ADC API interface output data shift mode"
             uint32 {7:6}
             doc "ADC API interface output data shift mode"
                 "default = SHIFT_MODE_24B_8B0"
             enum
             {
                 {0,  "SHIFT_MODE_24B_8B0"},
                 {1,  "SHIFT_MODE_24B_8B0"},
                 {2,  "SHIFT_MODE_8B0_24B"},
                 {3,  "SHIFT_MODE_4B0_24B_4B0"}
             }
             default = 0x0;
    
         PARAM "ADC API interface output alignment mode"
             uint32 {5}
             doc "ADC API interface output alignment mode"
             enum
             {
                 {0,  "API interface outputs data as MSB aligned"},
                 {1,  "API interface outputs data as LSB aligned"}
             }
             default = 0x0;
    
         PARAM "ADC API interface input alignment mode"
             uint32 {4}
             doc "ADC API interface input alignment mode"
             enum
             {
                 {0,  "API interface treats input data as MSB aligned"},
                 {1,  "API interface treats input data as LSB aligned"}
             }
             default = 0x0;
    
         PARAM "API data mode"
             uint32 {3:2}
             doc "API data mode"
             enum
             {
                 {0,  "MODE_16BIT"},
                 {1,  "MODE_8BIT"},
                 {2,  "MODE_24BIT"},
                 {3,  "MODE_16BIT"}
             }
             default = 0x0;
    
         PARAM "Reserved_10"
             uint32 {1}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "API enable"
             uint32 {0}
             doc "API enable"
             enum
             {
                 {0,  "Disable"},
                 {1,  "Enable"}
             }
             default = 0x0;
    
    
         PARAM "Reserved_13"
             uint32 {31:26}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "apiBclkClrByDen"
             uint32 {25}
             doc "apiBclkClrByDen"
             default = 0x0;
    
         PARAM "apiBclkSetByDen"
             uint32 {24}
             doc "apiBclkSetByDen"
             default = 0x0;
    
         PARAM "apiBclkClrByInit"
             uint32 {23}
             doc "apiBclkClrByInit"
             default = 0x0;
    
         PARAM "apiBclkSetByInit"
             uint32 {22}
             doc "apiBclkSetByInit"
             default = 0x0;
    
         PARAM "apiBclkTogF"
             uint32 {21:16}
             doc "apiBclkTogF"
             default = 0xA;
    
         PARAM "Reserved_12"
             uint32 {15:14}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "apiBclkH2l"
             uint32 {13:8}
             doc "apiBclkH2l"
             default = 0x6;
    
         PARAM "Reserved_11"
             uint32 {7:6}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "apiBclkLl2h"
             uint32 {5:0}
             doc "apiBclkLl2h"
             default = 0x1;
    
    
         PARAM "Reserved_14"
             uint32 {31:28}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "Set API frame clock output high to low"
             uint32 {27:22}
             doc "bclk_cnt value to set API frame clock output high to low, only has effect when api_fclk_h2l_bclk_on = 1"
             default = 0x0;
    
         PARAM "set API frame clock output low to high"
             uint32 {21:16}
             doc "bclk_cnt value to set API frame clock output low to high, only has effect when api_fclk_l2h_bclk_on = 1"
             default = 0x0;
    
         PARAM "API frame clock output high to low ignores bclk_cnt or not"
             uint32 {15}
             doc "API frame clock output high to low ignores bclk_cnt or not"
             enum
             {
                 {0,  "Ignores bclk_cnt"},
                 {1,  "Checks bclk_cnt"}
             }
             default = 0;
    
         PARAM "API frame clock output low to high ignores bclk_cnt or not"
             uint32 {14}
             doc "API frame clock output low to high ignores bclk_cnt or not"
             enum
             {
                 {0,  "Ignores bclk_cnt"},
                 {1,  "Checks bclk_cnt"}
             }
             default = 0;
    
         PARAM "fclk_cnt value to set API frame clock output high to low"
             uint32 {13:9}
             doc "fclk_cnt value to set API frame clock output high to low"
             default = 0x1F;
    
         PARAM "fclk_cnt value to set API frame clock output low to high"
             uint32 {8:4}
             doc "fclk_cnt value to set API frame clock output low to high"
             default = 0;
    
         PARAM "apiFclkClrByDen"
             uint32 {3}
             doc "apiFclkClrByDen"
             enum
             {
                 {0,  "No effect"},
                 {1,  "API frame clock output reset to 0 by every input data sample"}
             }
             default = 0;
    
         PARAM "apiFclkSetByDen"
             uint32 {2}
             doc "apiFclkSetByDen"
             enum
             {
                 {0,  "No effect"},
                 {1,  "API frame clock output set to 1 by every input data sample"}
             }
             default = 1;
    
         PARAM "apiFclkClrByInit"
             uint32 {1}
             doc "apiFclkClrByInit"
             enum
             {
                 {0,  "No effect"},
                 {1,  "API frame clock output reset to 0 at init (enable from low to high)"}
             }
             default = 0;
    
         PARAM "apiFclkSetByInit"
             uint32 {0}
             doc "apiFclkSetByInit"
             enum
             {
                 {0,  "No effect"},
                 {1,  "API frame clock output set to 1 at init (enable from low to high)"}
             }
             default = 0;
    
    
         PARAM "Reserved_15"
             uint32 {31:13}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "fclk_cnt reset value"
             uint32 {12:8}
             doc "fclk_cnt reset value, this offset can be used to shift output data position"
             default = 0;
    
         PARAM "apiFclkCntMaxEn"
             uint32 {7}
             doc "apiFclkCntMaxEn"
             enum
             {
                 {0,  "fclk_cnt[4:0] increments until wrap around"},
                 {1,  "fclk_cnt[4:0] wrap around at api_fclk_cnt_max"}
             }
             default = 0;
    
         PARAM "fclk_cnt wrap around value"
             uint32 {6:2}
             doc "fclk_cnt wrap around value, only effective when api_fclk_cnt_max_en == 1"
             default = 0x1f;
    
         PARAM "apiRclkAlwaysOn"
             uint32 {1}
             doc "apiRclkAlwaysOn"
             enum
             {
                 {0,  "API reference clock output is gated when api_enable == 0"},
                 {1,  "API reference clock output is not gated when api_enable == 0"}
             }
             default = 0;
    
         PARAM "API reference clock output inversion"
             uint32 {0}
             doc "API reference clock output inversion"
             enum
             {
                 {0,  "No invert"},
                 {1,  "Invert"}
             }
             default = 0;
    
    
         PARAM "ADC power on delay"
             uint8
             doc "ADC power on delay in us"
                 "Default 20"
             max = 255
             default = 20;
    
    
         PARAM "bandgap reference channel"
             uint8
             doc "bandgap reference channel"
                 "Default 14"
             max = 31
             default = 13;
    
    
         PARAM "Calibration Reading Ave Count"
             uint8
             doc "Auto calibration reading average count."
                 "Default 8"
             max = 255
             default = 8;
    
         PARAM "Input Range"
             uint8
             doc "ADC input range select. Default is 0-1.2v"
    
             enum
             {
                 {0, "0V-3.6V"},
                 {1, "0V-1.8V"}
             }
             default = 0;
    
         PARAM "Reference MicroVoltage"
             uint32
             doc "ADC calibration reference voltage in mV"
                 "Default 1200mV"
             default = 1200;
    
         PARAM "ADCBandgapDelta[0]"
             int16
             doc "Offset to VSS to be applied to get bandgap for 0-1.2V range"
             default = 18790;
         
         PARAM "ADCBandgapDelta[1]"
             int16
             doc "Offset to VSS to be applied to get bandgap for 0-2.4V range"
             default = 7082;
         
          PARAM "ADCBandgapDelta[2]"
             int16
             doc "Offset to VSS to be applied to get bandgap for 0-3.6V range"
             default = 4306;            
    
         PARAM "ADC api enable"
             uint8
             doc "AADC api enable"
             enum
             {
                 {0, "Disable ADC API"},
                 {1, "Enable ADC API"}
             }
             default = 0;
    
         PARAM "ADC audio fifo number"
             uint8
             doc "ADC audio fifo number"
                 "Default 5"
             max = 255
             default = 5;
    
         PARAM "ADC audio fifo size"
             uint32
             doc "ADC audio fifo size"
                 "Default 240"
             default = 240;
    
    
         PARAM "Reserved_16"
             uint32 {31:23}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "pdm_phase_sel"
             uint32 {22:20}
             doc "pdm_phase_sel"
             default = 1;
    
         PARAM "pdm_decim_en_sel"
             uint32 {19}
             doc "pdm_decim_en_sel"
             default = 0;
    
         PARAM "pdm_decim_en_sel_manual"
             uint32 {18}
             doc "pdm_decim_en_sel_manual"
             default = 0;
    
         PARAM "adcDataSel"
             uint32 {17}
             doc "adcDataSel"
             default = 0;
    
         PARAM "adcDbgOutSelMsb"
             uint32 {16}
             doc "adcDbgOutSelMsb"
             default = 0;
    
         PARAM "latencyCnt2Set"
             uint32 {15:8}
             doc "latencyCnt2Set"
             default = 0;
    
         PARAM "dataToggleCntEn"
             uint32 {7}
             doc "dataToggleCntEn"
             default = 0;
    
         PARAM "clkDmaCntEn"
             uint32 {6}
             doc "clkDmaCntEn"
             default = 0;
    
         PARAM "clkAdcCntEn"
             uint32 {5}
             doc "clkAdcCntEn"
             default = 0;
    
         PARAM "latencyCnt2En"
             uint32 {4}
             doc "latencyCnt2En"
             default = 0;
    
         PARAM "dataToggleCntClr"
             uint32 {3}
             doc "dataToggleCntClr"
             default = 0;
    
         PARAM "clkDmaCntClr"
             uint32 {2}
             doc "clkDmaCntClr"
             default = 0;
    
         PARAM "clkAdcCntClr"
             uint32 {1}
             doc "clkAdcCntClr"
             default = 0;
    
         PARAM "adcSampleReadyClr"
             uint32 {0}
             doc "adcSampleReadyClr"
             default = 0;
    
    
         PARAM "Reserved_17"
             uint32 {31:7}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "apiFclkClrOld"
             uint32 {6}
             doc "apiFclkClrOld"
             default = 0;
    
         PARAM "apiBclkTogFEven"
             uint32 {5:0}
             doc "apiBclkTogFEven"
             default = 0xB;
    
    
         PARAM "Reserved_18"
             uint32 {31:16}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "api_ch_swap"
             uint32 {15}
             doc "api_ch_swap"
             default = 0;
    
         PARAM "apiFclkCntOffsetMsb"
             uint32 {14}
             doc "apiFclkCntOffsetMsb"
             default = 0;
    
         PARAM "apiFclkH2lFclkMsb"
             uint32 {13}
             doc "apiFclkH2lFclkMsb"
             default = 0;
    
         PARAM "apiFclkl2hFclkMsb"
             uint32 {12}
             doc "apiFclkl2hFclkMsb"
             default = 0;
    
         PARAM "apiFclkCntMaxMsb"
             uint32 {11}
             doc "apiFclkCntMaxMsb"
             default = 1;
    
         PARAM "apiBclkTogFLast"
             uint32 {10:4}
             doc "apiBclkTogFLast"
             default = 0x19;
    
         PARAM "apiFclkl2hBclkMsb"
             uint32 {3}
             doc "apiFclkl2hBclkMsb"
             default = 0;
    
         PARAM "fclkLastGatedOff"
             uint32 {2}
             doc "fclkLastGatedOff"
             default = 0;
    
         PARAM "fclkPhaseSel"
             uint32 {1}
             doc "fclkPhaseSel"
             default = 0;
    
         PARAM "bclk2xSpeed"
             uint32 {0}
             doc "bclk2xSpeed"
             default = 0;
    
     }

     COMMAND "MPAF CAPSCAN CONFIG" 0x052E
     {
         doc "Config item code for Bluetooth MPAF CAPSCAN CONFIG."
         PARAM "cscan_setting_config"
             uint32
             doc "the value of register 0x00450000, default=0x0F0F0064";
         PARAM "phasecyc_config "
             uint32
             doc "the value of register 0x0045000C, default=0x023FFFFF";
         PARAM "framecnt_config"
             uint32
             doc "the value of register 0x00450010, default=0x08000020";
         PARAM "port_enable"
             uint8
             doc "Enable capscan port, bit3~bit0 indicate port3~port0 enable or not";
         PARAM "port0_Cout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port0_Sout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port1_Cout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port1_Sout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port2_Cout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port2_Sout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port3_Cout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "port3_Sout_pinselect"
             uint8
             doc "range:0~39   LHL GPIO 40 pins; 0:P0; 1:P1; ... ; P39: 39";
         PARAM "threshold_p0"
             uint16
             doc "in port0, the thresholds to be determined a touch. no more than 0xFFFF";
         PARAM "threshold_p1"
             uint16
             doc "in port1, the thresholds to be determined a touch. no more than 0xFFFF";
         PARAM "threshold_p2"
             uint16
             doc "in port2, the thresholds to be determined a touch. no more than 0xFFFF";
         PARAM "threshold_p3"
             uint16
             doc "in port3, the thresholds to be determined a touch. no more than 0xFFFF";
         PARAM "debounce_cnt"
             uint8
             doc "the times more than threshold to be determined a real touch event";
         PARAM "ScanMode"
             uint8
             doc "1: use interrupt to get capscan raw count, 0 and others: use poll to get capscan raw count";
         PARAM "PollInterval"
             uint32
             doc "the time interval between two polls, unit: micro sec";
         PARAM "SingleKeyMode"
             uint8
             doc "1: only one key and be touched at a same timer;  0 and others: no restriction";
         PARAM "AdvanceErrorHandle"
             uint8
             doc "1: use some conditions to prevent unpredictable errors; 0 and others: normal";
     }

     COMMAND "USB Device Configuration" 0x0600
     {
         doc "Configuration for USB device options"
         PARAM "Active Controller"
             uint8
             doc "Hardware controller for platforms that have multiple controllers"
             enum
             {
             {4, "USB11"},
             {5, "USB30-BDC"},
             {3, "USB30-XDC"},
             {4, "Shared USB"}
             }
             default = 5;
    
         PARAM "Device function"
             uint8
             doc "This is a selection of functionality that depends on ROM support. "
                 "For USB11 controller, enabling functions other than Bluetooth only will result in the "
                 "Hub also being enabled.  Hub is only valid for USB11 controller."
                 "For USB30 controller, enabling multiple functions will result in a composite device "
             bitmap 
             {
                 {0x1, "Bluetooth"},
                 {0x2, "Keyboard"},
                 {0x4, "Mouse"},
                 {0x8, "Hub"},
                 {0x10, "Audio"}
               ## {0x7, "UHE"}
             }
             default = 1;
    
         PARAM "RESERVED"
             uint32 {31:2}
             doc "Reserved"
             binary_message_only
             encode_value = 0;
    
         PARAM "Skip USB detection"
             uint32 {1}
             doc "Hard code USB transport to TRUE. Transport detection will still happen but USB will"
                 "immediately assume detection the first chance it gets."
             enum
             {
                 {0,"FALSE"},
                 {1,"TRUE"}
             }
             default = 0;
    
         PARAM "HID ZLP Enable"
             uint32 {0}
             doc "Send ZLP packets when HID transactions are multiple of max packet size."
                 "Some BIOS cannot handle HID ZLP."
             enum
             {
                 {0,"FALSE"},
                 {1,"TRUE"}
             }
             default = 0;
    
     }

     COMMAND "USB Internal Configuration" 0x0601
     {
         doc "Internal USB Configuration"
         PARAM "Internal configuration"
             uint32 
             doc "Internal configuration only to be set with guidance of USB team";
    
     }

     COMMAND "Bluetooth Device Descriptor" 0x0610
     {
         doc "Config item code for USB Bluetooth Device Descriptor."
         PARAM "Length"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x12;
         PARAM "Descriptor type"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x01;                                            # device descriptor
         PARAM "USB spec version"
             uint16
             doc "($$$ COPY FROM 105_49)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Device class"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device subclass"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device protocol"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Max packet size"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Vendor ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device release number"
             uint16
             doc "($$$ COPY FROM 105_49)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Manufacturer string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Serial number string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Number of configurations"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 1;
     }

     COMMAND "Bluetooth Configuration Descriptor" 0x0611
     {
         doc "Config item code for USB Configuration Descriptor."
         PARAM "Descriptor"
             uint8[255] omit_pad_bytes 
             doc "USB Configuration Descriptor";
     }

     COMMAND "Keyboard Device Descriptor" 0x0620
     {
         doc "Config item code for USB KB Device Descriptor."
         PARAM "Length"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x12;
         PARAM "Descriptor type"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x01;                                            # device descriptor
         PARAM "USB spec version"
             uint16
             doc "($$$ NEEDS EXPLANATION)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Device class"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device subclass"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device protocol"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Max packet size"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Vendor ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device release number"
             uint16
             doc "($$$ COPY FROM 105_49)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Manufacturer string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Serial number string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Number of configurations"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 1;
     }

     COMMAND "Keyboard Configuration Descriptor" 0x0621
     {
         doc "Config item code for USB KB Configuration Descriptor."
         PARAM "Descriptor"
             uint8[64] omit_pad_bytes
             doc "($$$ NEEDS EXPLANATION)";
     }

     COMMAND "Keyboard Report Descriptor" 0x0622
     {
         doc "Config item code for USB KB Report Descriptor buffer."
         PARAM "Maximum Length"                   # in bytes
             uint32
             doc "Maximum report descriptor length.  This is necessary if the descriptor can be "
                 "dynamically changed during runtime by MPAF/UHE or other modules"
                 "Set to 0 if over-allocation is not needed";
         PARAM "Length"                           # in bytes
             uint32
             doc "Report descriptor length"
             binary_message_only
             encode_value =  ByteArrayValidLength("Descriptor");
         PARAM "Descriptor"
             uint8[384] omit_pad_bytes
             doc "USB report descriptor to be used by the keyboard port.  The"
                 "maximum length is 64 for most builds, but is extended for one"
                 "customer-specific build.";
     }

     COMMAND "Keyboard Product ID String Descriptor" 0x0623
     {
         doc "Config item code for USB KB Product ID buffer"
         PARAM "Product ID length"                           # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
         PARAM "Product ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                               # string descriptor
         PARAM "Product ID Unicode-16"
             uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Product ID length" - 2)        # in bytes
             min = 0;
     }

     COMMAND "Mouse Device Descriptor" 0x0630
     {
         doc "Config item code for USB Mouse Device Descriptor."
         PARAM "Length"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x12;
         PARAM "Descriptor type"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x01;                                            # device descriptor
         PARAM "USB spec version"
             uint16
             doc "($$$ NEEDS EXPLANATION)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Device class"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device subclass"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device protocol"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Max packet size"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Vendor ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device release number"
             uint16
             doc "($$$ COPY FROM 105_49)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Manufacturer string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Serial number string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Number of configurations"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 1;
     }

     COMMAND "Mouse Configuration Descriptor" 0x0631
     {
         doc "Config item code for USB Mouse Configuration Descriptor."
         PARAM "Descriptor"
             uint8[64] omit_pad_bytes
             doc "($$$ NEEDS EXPLANATION)";
     }

     COMMAND "Mouse Report Descriptor" 0x0632
     {
         doc "Config item code for USB Mouse Report Descriptor buffer."
         PARAM "Maximum Length"                   # in bytes
             uint32
             doc "Maximum report descriptor length.  This is necessary if the descriptor can be "
                 "dynamically changed during runtime by MPAF/UHE or other modules"
                 "Set to 0 if over-allocation is not needed";
         PARAM "Length"                           # in bytes
             uint32
             doc "Report descriptor length"
             binary_message_only
             encode_value = ByteArrayValidLength("Descriptor");
         PARAM "Descriptor"
             uint8[384] omit_pad_bytes
             doc "USB report descriptor to be used by the mouse port.  The"
                 "maximum length is 64 for most builds, but is extended for one"
                 "customer-specific build.";
     }

     COMMAND "Mouse Product ID String Descriptor" 0x0633
     {
         doc " Config item code for USB Mouse Product ID buffer"
         PARAM "Product ID length"                           # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
         PARAM "Product ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                               # string descriptor
         PARAM "Product ID Unicode-16"
             uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Product ID length" - 2)        # in bytes
             min = 0;
     }

     COMMAND "DFU Device Descriptor" 0x0640
     {
         doc "USB DFU Device descriptor"
         PARAM "Length"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x12;
         PARAM "Descriptor type"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 0x01;                                            # device descriptor
         PARAM "USB spec version"
             uint16
             doc "($$$ NEEDS EXPLANATION)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Device class"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device subclass"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Device protocol"
             uint8
             doc "($$$ NEEDS EXPLANATION)";
         PARAM "Max packet size"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Vendor ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product ID"
             uint16
             doc "($$$ COPY FROM 105_49)";
         PARAM "Device release number"
             uint16
             doc "($$$ COPY FROM 105_49)"
             note "BCD, version 1.10 = 0x0110";
         PARAM "Manufacturer string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Product string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Serial number string index"
             uint8
             doc "($$$ COPY FROM 105_49)";
         PARAM "Number of configurations"
             uint8
             doc "($$$ COPY FROM 105_49)"
             binary_message_only
             encode_value = 1;
     }
    

     COMMAND "DFU Configuration Descriptor" 0x0641
     {
         doc "USB DFU configuration descriptor"
         PARAM "Descriptor"
             uint8[0x19]
             doc "($$$ NEEDS EXPLANATION)";
     }
    

     COMMAND "DFU Manufacturer ID String Descriptor" 0x0642
     {
         doc "USB DFU Manufacturer ID String Descriptor"
         PARAM "Manufacturer ID length"                                      # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Manufacturer ID Unicode-16"));
         PARAM "Manufacturer ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                                               # string descriptor
         PARAM "Manufacturer ID Unicode-16"
             uint8[0x1A] omit_pad_bytes                        # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Manufacturer ID length" - 4)                   # in bytes
                 min = 0;
     }
    

     COMMAND "DFU Product ID String Descriptor" 0x0643
     {
         doc "USB DFU Product ID String Descriptor"
         PARAM "Product ID length"                                           # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
         PARAM "Product ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                                               # string descriptor
         PARAM "Product ID Unicode-16"
             uint8[0x44] omit_pad_bytes                        # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Product ID length" - 4)                        # in bytes
                 min = 0;
     }
    

     COMMAND "Language ID String Descriptor" 0x0670
     {
         doc "Config item code for USB Language ID buffer."
         PARAM "Language ID length"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 4;
         PARAM "Language ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                               # string descriptor
         PARAM "Language ID"
             uint16
             doc "($$$ NEEDS EXPLANATION)"
             default = 0x0409;
     }

     COMMAND "Manufacturer ID String Descriptor" 0x0671
     {
         doc "Config item code for USB Manufacture ID buffer."
         PARAM "Manufacturer ID length"                      # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Manufacturer ID Unicode-16"));
         PARAM "Manufacturer ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                               # string descriptor
         PARAM "Manufacturer ID Unicode-16"
             uint8[40] omit_pad_bytes                        # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Manufacturer ID length" - 2)   # in bytes
             min = 0;
     }

     COMMAND "Product ID String Descriptor" 0x0673
     {
         doc "Config item code for USB Product ID buffer."
         PARAM "Product ID length"                           # in bytes
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
         PARAM "Product ID descriptor type"
             uint8
             doc "($$$ NEEDS EXPLANATION)"
             binary_message_only
             encode_value = 3;                               # string descriptor
         PARAM "Product ID Unicode-16"
             uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
             doc "($$$ NEEDS EXPLANATION)"
             valid_length = ("Product ID length" - 2)        # in bytes
             min = 0;
     }

    COMMAND "Temperature Correction Algorithm Config" 0x0700
    {
    
        doc "TCA config"
            PARAM "Enable"
            uint32
            doc "TCA config flags"
            bitmap
            {
                 {0x00000001, "Bit 0 enable temperature correction algorithm for BT mode"},
                 {0x00000002, "Bit 1 enable temperature correction algorithm for BLE mode"},
                 {0x00000004, "Bit 2 TCA PADGC GGFSK interpolation enable"},
                 {0x00000008, "Bit 3 TCA PADGC EDR interpolation enable"},
                 {0x00000010, "Bit 4 TCA PADGC interpolation enable for BLE"},
                 {0x00000020, "Bit 5 TCA temperature sensor data LP filter enable"},
                 {0x00000080, "Bit 7 Enable TCA for LE2 mode"},
                 {0x00000100, "BIT 8 Enable TCA for Zigbee mode"},
                 {0x00000200, "BIT 9 TCA PADGC LE2 interpolation enable"},
                 {0x00000400, "BIT 10 TCA PADGC Zigbee interpolation enable"},
                 {0xFFFFF800, "RFU"} 
             };
    }

     COMMAND "TCA Table" 0x0701
    {
        doc "TCA temperature compensation tables. This format supports"
            "up to 25 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
        PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
                "this device was manufactured. Used to allow variable tuning for"
                "parts from different foundaries in the same products."
            default = 0;
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
                 "is actually the desired temperature plus a 50 degree Celsius offset"
                 "For example, a switching point of -5C would be input as 45"
                 "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
                 "therefore switching points should be chosen carefully to avoid"
                 "repeated adjustments around a switching point."
            min = 1
            max = 6;
        PARAM "Tmin[0]"
            uint8
            doc "Lowest temperature for region plus 50 degrees celsius offset, for"
                "example a value of 1 specifies a temperature range starting at 51"
                "degrees celsius.";
        PARAM "Tmin[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "Tmin[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "Tmin[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "Tmin[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "Tmin[5]"
            uint8
            present_if("Num TSteps" > 5);
    
        # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
                "Set value either 1 or 5."
            min = 1
            max = 5;
    
        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);
    
        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
           uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
    
    
        # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
         PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
         PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
         PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);
    
    
        #TSSI targets - EDR
        PARAM "TssiTargetEDR[0][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "TssiTargetEDR[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTargetEDR[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTargetEDR[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTargetEDR[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);
    
        PARAM "TssiTargetEDR[1][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTargetEDR[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTargetEDR[2][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTargetEDR[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTargetEDR[3][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTargetEDR[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTargetEDR[4][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTargetEDR[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTargetEDR[5][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTargetEDR[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
    
    
        ## TSSI ranges - EDR
        ## RFP PA gain binary search endpoints
        PARAM "TssiRangeLowEDR[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "TssiRangeHighEDR[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "TssiRangeLowEDR[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHighEDR[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLowEDR[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHighEDR[2]"
            uint8
            present_if("Num TSteps" > 2);
         PARAM "TssiRangeLowEDR[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHighEDR[3]"
            uint8
            present_if("Num TSteps" > 3);
         PARAM "TssiRangeLowEDR[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHighEDR[4]"
            uint8
            present_if("Num TSteps" > 4);
         PARAM "TssiRangeLowEDR[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHighEDR[5]"
            uint8
            present_if("Num TSteps" > 5);
    
        # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 10;
        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 2;
        #######################################################################
        #                              PAGE DESCRIPTORS
        #
        # Legend:
        # Single array index = [Page]
        # Dual array index   = [Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8 - BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0 is reserved for the PA Driver gain control
        # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        # Page 3
        PARAM "BaseAddress8[3]"
            uint32
            doc " 32-bit base address for Page 3"
            present_if("Num Pages8" > 3);
        PARAM "NumRegs8[3]"
            uint8
            doc " Number of registers in Page 3"
            min = 1
            max = 5
            present_if("Num Pages8" > 3);
        PARAM "AdrOffset8[3][0]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 0 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 0 ));
        PARAM "Bitmask8[3][0]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 0 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 0 ));
        PARAM "AdrOffset8[3][1]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 1 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 1 ));
        PARAM "Bitmask8[3][1]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 1 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 1 ));
        PARAM "AdrOffset8[3][2]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 2 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 2 ));
        PARAM "Bitmask8[3][2]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 2 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 2 ));
        PARAM "AdrOffset8[3][3]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 3 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 3 ));
        PARAM "Bitmask8[3][3]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 3 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 3 ));
        PARAM "AdrOffset8[3][4]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 4 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 4 ));
        PARAM "Bitmask8[3][4]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 4 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 4 ));
        # Page 4
        PARAM "BaseAddress8[4]"
            uint32
            doc " 32-bit base address for Page 4"
            present_if("Num Pages8" > 4);
        PARAM "NumRegs8[4]"
            uint8
            doc " Number of registers in Page 4"
            min = 1
            max = 5
            present_if("Num Pages8" > 4);
        PARAM "AdrOffset8[4][0]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 0 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 0 ));
        PARAM "Bitmask8[4][0]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 0 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 0 ));
        PARAM "AdrOffset8[4][1]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 1 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 1 ));
        PARAM "Bitmask8[4][1]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 1 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 1 ));
        PARAM "AdrOffset8[4][2]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 2 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 2 ));
        PARAM "Bitmask8[4][2]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 2 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 2 ));
        PARAM "AdrOffset8[4][3]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 3 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 3 ));
        PARAM "Bitmask8[4][3]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 3 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 3 ));
        PARAM "AdrOffset8[4][4]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 4 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 4 ));
        PARAM "Bitmask8[4][4]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 4 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 4 ));
        # Page 5
        PARAM "BaseAddress8[5]"
            uint32
            doc " 32-bit base address for Page 5"
            present_if("Num Pages8" > 5);
        PARAM "NumRegs8[5]"
            uint8
            doc " Number of registers in Page 5"
            min = 1
            max = 5
            present_if("Num Pages8" > 5);
        PARAM "AdrOffset8[5][0]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 0 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 0 ));
        PARAM "Bitmask8[5][0]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 0 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 0 ));
        PARAM "AdrOffset8[5][1]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 1 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 1 ));
        PARAM "Bitmask8[5][1]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 1 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 1 ));
        PARAM "AdrOffset8[5][2]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 2 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 2 ));
        PARAM "Bitmask8[5][2]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 2 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 2 ));
        PARAM "AdrOffset8[5][3]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 3 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 3 ));
        PARAM "Bitmask8[5][3]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 3 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 3 ));
        PARAM "AdrOffset8[5][4]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 4 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 4 ));
        PARAM "Bitmask8[5][4]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 4 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 4 ));
        # Page 6
        PARAM "BaseAddress8[6]"
            uint32
            doc " 32-bit base address for Page 6"
            present_if("Num Pages8" > 6);
        PARAM "NumRegs8[6]"
            uint8
            doc " Number of registers in Page 6"
            min = 1
            max = 5
            present_if("Num Pages8" > 6);
        PARAM "AdrOffset8[6][0]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 0 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 0 ));
        PARAM "Bitmask8[6][0]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 0 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 0 ));
        PARAM "AdrOffset8[6][1]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 1 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 1 ));
        PARAM "Bitmask8[6][1]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 1 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 1 ));
        PARAM "AdrOffset8[6][2]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 2 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 2 ));
        PARAM "Bitmask8[6][2]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 2 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 2 ));
        PARAM "AdrOffset8[6][3]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 3 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 3 ));
        PARAM "Bitmask8[6][3]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 3 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 3 ));
        PARAM "AdrOffset8[6][4]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 4 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 4 ));
        PARAM "Bitmask8[6][4]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 4 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 4 ));
        # Page 7
        PARAM "BaseAddress8[7]"
            uint32
            doc " 32-bit base address for Page 7"
            present_if("Num Pages8" > 7);
        PARAM "NumRegs8[7]"
            uint8
            doc " Number of registers in Page 7"
            min = 1
            max = 5
            present_if("Num Pages8" > 7);
        PARAM "AdrOffset8[7][0]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 0 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 0 ));
        PARAM "Bitmask8[7][0]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 0 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 0 ));
        PARAM "AdrOffset8[7][1]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 1 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 1 ));
        PARAM "Bitmask8[7][1]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 1 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 1 ));
        PARAM "AdrOffset8[7][2]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 2 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 2 ));
        PARAM "Bitmask8[7][2]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 2 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 2 ));
        PARAM "AdrOffset8[7][3]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 3 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 3 ));
        PARAM "Bitmask8[7][3]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 3 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 3 ));
        PARAM "AdrOffset8[7][4]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 4 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 4 ));
        PARAM "Bitmask8[7][4]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 4 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 4 ));
        # Page 8
        PARAM "BaseAddress8[8]"
            uint32
            doc " 32-bit base address for Page 8"
            present_if("Num Pages8" > 8);
        PARAM "NumRegs8[8]"
            uint8
            doc " Number of registers in Page 8"
            min = 1
            max = 5
            present_if("Num Pages8" > 8);
        PARAM "AdrOffset8[8][0]"
            uint16
            doc " 16-bit offset to the base address for Page 8 Reg 0 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 0 ));
        PARAM "Bitmask8[8][0]"
            uint8
            doc " 8-bit bit mask for Page 8 Reg 0 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 0 ));
        PARAM "AdrOffset8[8][1]"
            uint16
            doc " 16-bit offset to the base address for Page 8 Reg 1 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 1 ));
        PARAM "Bitmask8[8][1]"
            uint8
            doc " 8-bit bit mask for Page 8 Reg 1 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 1 ));
        PARAM "AdrOffset8[8][2]"
            uint16
            doc " 16-bit offset to the base address for Page 8 Reg 2 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 2 ));
        PARAM "Bitmask8[8][2]"
            uint8
            doc " 8-bit bit mask for Page 8 Reg 2 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 2 ));
        PARAM "AdrOffset8[8][3]"
            uint16
            doc " 16-bit offset to the base address for Page 8 Reg 3 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 3 ));
        PARAM "Bitmask8[8][3]"
            uint8
            doc " 8-bit bit mask for Page 8 Reg 3 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 3 ));
        PARAM "AdrOffset8[8][4]"
            uint16
            doc " 16-bit offset to the base address for Page 8 Reg 4 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 4 ));
        PARAM "Bitmask8[8][4]"
            uint8
            doc " 8-bit bit mask for Page 8 Reg 4 "
            present_if(( "Num Pages8" > 8) and ("NumRegs8[8]" > 4 ));
        # Page 9
        PARAM "BaseAddress8[9]"
            uint32
            doc " 32-bit base address for Page 9"
            present_if("Num Pages8" > 9);
        PARAM "NumRegs8[9]"
            uint8
            doc " Number of registers in Page 9"
            min = 1
            max = 5
            present_if("Num Pages8" > 9);
        PARAM "AdrOffset8[9][0]"
            uint16
            doc " 16-bit offset to the base address for Page 9 Reg 0 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 0 ));
        PARAM "Bitmask8[9][0]"
            uint8
            doc " 8-bit bit mask for Page 9 Reg 0 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 0 ));
        PARAM "AdrOffset8[9][1]"
            uint16
            doc " 16-bit offset to the base address for Page 9 Reg 1 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 1 ));
        PARAM "Bitmask8[9][1]"
            uint8
            doc " 8-bit bit mask for Page 9 Reg 1 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 1 ));
        PARAM "AdrOffset8[9][2]"
            uint16
            doc " 16-bit offset to the base address for Page 9 Reg 2 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 2 ));
        PARAM "Bitmask8[9][2]"
            uint8
            doc " 8-bit bit mask for Page 9 Reg 2 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 2 ));
        PARAM "AdrOffset8[9][3]"
            uint16
            doc " 16-bit offset to the base address for Page 9 Reg 3 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 3 ));
        PARAM "Bitmask8[9][3]"
            uint8
            doc " 8-bit bit mask for Page 9 Reg 3 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 3 ));
        PARAM "AdrOffset8[9][4]"
            uint16
            doc " 16-bit offset to the base address for Page 9 Reg 4 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 4 ));
        PARAM "Bitmask8[9][4]"
            uint8
            doc " 8-bit bit mask for Page 9 Reg 4 "
            present_if(( "Num Pages8" > 9) and ("NumRegs8[9]" > 4 ));
        #######################################################################
        #
        # 16-BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        # Page 1
        PARAM "BaseAddress16[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages16" > 1);
        PARAM "NumRegs16[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages16" > 1);
        PARAM "AdrOffset16[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 0 ));
        PARAM "Bitmask16[1][0]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 0 ));
        PARAM "AdrOffset16[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 1 ));
        PARAM "Bitmask16[1][1]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 1 ));
        PARAM "AdrOffset16[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 2 ));
        PARAM "Bitmask16[1][2]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 2 ));
        PARAM "AdrOffset16[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 3 ));
        PARAM "Bitmask16[1][3]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 3 ));
        PARAM "AdrOffset16[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 4 ));
        PARAM "Bitmask16[1][4]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 4 ));
        #######################################################################
        # PAGE DATA
        #
        # Legend:
        # Triple Array Indices: [TStep][Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8-BIT PAGE DATA
        #
        #######################################################################
        # TStep 0
        # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[0][3][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[0][3][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[0][3][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[0][3][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[0][3][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[0][4][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[0][4][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[0][4][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[0][4][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[0][4][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[0][5][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[0][5][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[0][5][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[0][5][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[0][5][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[0][6][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[0][6][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[0][6][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[0][6][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[0][6][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[0][7][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[0][7][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[0][7][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[0][7][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[0][7][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[0][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[0][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[0][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[0][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[0][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[0][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[0][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[0][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[0][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[0][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[1][3][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[1][3][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[1][3][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[1][3][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[1][3][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[1][4][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[1][4][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[1][4][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[1][4][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[1][4][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[1][5][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[1][5][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[1][5][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[1][5][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[1][5][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[1][6][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[1][6][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[1][6][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[1][6][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[1][6][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[1][7][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[1][7][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[1][7][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[1][7][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[1][7][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[1][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[1][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[1][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[1][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[1][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[1][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[1][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[1][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[1][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[1][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[2][3][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[2][3][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[2][3][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[2][3][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[2][3][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[2][4][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[2][4][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[2][4][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[2][4][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[2][4][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[2][5][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[2][5][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[2][5][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[2][5][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[2][5][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[2][6][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[2][6][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[2][6][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[2][6][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[2][6][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[2][7][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[2][7][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[2][7][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[2][7][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[2][7][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[2][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[2][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[2][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[2][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[2][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[2][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[2][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[2][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[2][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[2][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[3][3][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[3][3][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[3][3][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[3][3][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[3][3][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[3][4][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[3][4][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[3][4][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[3][4][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[3][4][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[3][5][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[3][5][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[3][5][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[3][5][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[3][5][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[3][6][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[3][6][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[3][6][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[3][6][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[3][6][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[3][7][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[3][7][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[3][7][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[3][7][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[3][7][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[3][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[3][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[3][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[3][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[3][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[3][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[3][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[3][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[3][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[3][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[4][3][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[4][3][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[4][3][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[4][3][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[4][3][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[4][4][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[4][4][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[4][4][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[4][4][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[4][4][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[4][5][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[4][5][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[4][5][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[4][5][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[4][5][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[4][6][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[4][6][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[4][6][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[4][6][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[4][6][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[4][7][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[4][7][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[4][7][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[4][7][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[4][7][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[4][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[4][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[4][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[4][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[4][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[4][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[4][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[4][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[4][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[4][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[5][3][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[5][3][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[5][3][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[5][3][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[5][3][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[5][4][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[5][4][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[5][4][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[5][4][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[5][4][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[5][5][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[5][5][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[5][5][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[5][5][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[5][5][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[5][6][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[5][6][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[5][6][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[5][6][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[5][6][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[5][7][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[5][7][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[5][7][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[5][7][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[5][7][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # Page 8
        PARAM "Data8[5][8][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 0) );
        PARAM "Data8[5][8][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 1) );
        PARAM "Data8[5][8][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 2) );
        PARAM "Data8[5][8][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 3) );
        PARAM "Data8[5][8][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 8 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 8) and ("NumRegs8[8]" > 4) );
        # Page 9
        PARAM "Data8[5][9][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 0) );
        PARAM "Data8[5][9][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 1) );
        PARAM "Data8[5][9][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 2) );
        PARAM "Data8[5][9][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 3) );
        PARAM "Data8[5][9][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 9 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 9) and ("NumRegs8[9]" > 4) );
        #######################################################################
        #
        # 16-BIT PAGE DATA
        #######################################################################
        # TStep 0
        # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[0][1][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[0][1][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[0][1][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[0][1][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[0][1][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[1][1][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[1][1][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[1][1][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[1][1][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[1][1][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[2][1][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[2][1][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[2][1][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[2][1][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[2][1][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[3][1][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[3][1][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[3][1][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[3][1][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[3][1][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[4][1][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[4][1][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[4][1][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[4][1][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[4][1][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[5][1][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[5][1][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[5][1][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[5][1][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[5][1][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
    }

    COMMAND "LE TCA Table" 0x0702
    {
        doc "TCA temperature compensation tables. This format supports"
            "up to 15 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
            PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
            "this device was manufactured. Used to allow variable tuning for"
            "parts from different foundaries in the same products."
            default = 0xff;
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
            "is actually the desired temperature plus a 50 degree Celsius offset"
            "For example, a switching point of -5C would be input as 45"
            "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
            "therefore switching points should be chosen carefully to avoid"
            "repeated adjustments around a switching point."
            min = 1
            max = 6;
    
    # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
            "Set value either 1 or 5."
            min = 1
            max = 5;
    
        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);
    
        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
    
    
    # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
            "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
            "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);
    
    
    # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 3;
        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 1;
    ######################################################################
    #                              PAGE DESCRIPTORS
    #
    # Legend:
    # Single array index = [Page]
    # Dual array index   = [Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8 - BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0 is reserved for the PA Driver gain control
    # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
    
    
    # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
    
    # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
    
    #######################################################################
    #
    # 16-BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
    #######################################################################
    # PAGE DATA
    #
    # Legend:
    # Triple Array Indices: [TStep][Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8-BIT PAGE DATA
    #
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    
    # 16-BIT PAGE DATA
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    }

    COMMAND "RFP Tuning Configuration" 0x0703
    {
        doc "This item contains the configurable values for the"
            "Radio Frequency Performance tuning function to control"
            "for process variation"
        PARAM "TSSI Config"
            uint32
            doc "Enable control"
            bitmap
            {
                { 0x00000001, "BDR/EDR TSSI cal enable" },
                { 0x00000002, "BLE TSSI Cal enable" },
                { 0x00000004, "TSSI cal mid bin only"},
                { 0x00000018, "Calibrate GFSK and EDR"},
                { 0x00000020, "TssI target interpolation"},
                { 0xFFFFFFC0, "RFU"}
            };
        PARAM "LO IQ Cal Config"
            uint32
            doc "LO and IQ Cal Config"
            bitmap
            {
                { 0x00000001, "IQ Cal enable" },
                { 0x00000002, "IQ Cal mid bin only" },
                { 0x00000004, "IQ Cal Force PAD" },
                { 0x00000008, "IQ Cal prior to Tssi Cal" },
                { 0xFFFFFFF0, "RFU"}
            };
        PARAM "TSSI Cal Maximum number of iterations"
            uint8
            doc "TSSI Cal Maximum number of iterations";
        PARAM "Tssi Cal Search Threshold"
            uint8
            doc "Tssi cal acceptable final search threshold";
        PARAM "Tssi Cal External Factor"
            uint32
            doc "External factor for GFSK TSSI for final optimization after power cal is done";
        PARAM "Tssi Cal Correction Factor"
            uint32
            doc "Correction factor to compensate for PA variation for GFSK gain calibration";
        PARAM "LO IQ Cal Max Iterations"
            uint8
            doc "LO IQ Cal maximum number of iterations";
        PARAM "LO IQ calibration RSSI threshold"
            uint8
            doc "Max RSSI for acceptable calibration";
        PARAM "LO calibration RSSI invalid"
            uint16
            doc "Max RSSI before calibration is rejected";
    # LO I calibration values
        PARAM "LO calibration for I initial LOW"
            int16
            doc "Initial LOW endpoint for the LO I binary search";
        PARAM "LO calibration for I initial HIGH"
            int16
            doc "Initial HIGH endpoint for the LO I binary search";
    # LO Q calibration values
        PARAM "LO calibration for Q initial LOW"
            int16
            doc "Initial LOW endpoint for the LO Q binary search";
        PARAM "LO calibration for Q initial HIGH"
            int16
            doc "Initial HIGH endpoint for the LO Q binary search";
    # I/Q Kappa Theta values
        PARAM "IQ Kappa Theta calibration for max iterations"
            uint8
            doc "Maximum number of iterations for IQ Kappa Theta side";
        PARAM "IQ Kappa Theta acceptable final search threshold"
            uint8
            doc "IQ Kappa Theta Acceptable final search threshold";
        PARAM "IQ Kappa Theta Max RssiValue"
            uint16
            doc "RSSI value at which calibration is called invalid";
        PARAM "IQ calibration for Kappa initial LOW"
            int16
            doc "Initial LOW endpoint for the IQ Kappa binary search";
        PARAM "IQ calibration for Kappa initial HIGH"
            int16
            doc "Initial HIGH endpoint for the IQ Kappa binary search";
        PARAM "IQ calibration for Theta initial LOW"
            int16
            doc "Initial LOW endpoint for the IQ Theta binary search";
        PARAM "IQ calibration for Theta initial HIGH"
            int16
            doc "Initial HIGH endpoint for the IQ Theta binary search";
    }

    
    COMMAND "HW Power LUT Table" 0x0704
    {
        doc "This item is used to reload the internal h/w power LUT present"
            "in some devices. It is here to support multiple fab houses"
            PARAM "FAB ID"
            uint8
            doc "FAB ID";
        PARAM "Num of Operational Steps"
            uint8
            doc "Default number of operational steps";
        PARAM "Operational Power Step[0].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[0].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[0].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[1].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[1].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[1].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[2].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[2].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[2].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[3].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[3].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[3].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[4].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[4].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[4].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[5].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[5].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[5].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[6].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[6].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[6].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[7].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[7].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[7].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[8].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[8].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[8].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[9].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[9].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[9].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[10].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[10].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[10].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[11].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[11].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[11].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[12].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[12].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[12].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[13].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[13].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[13].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[14].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[14].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[14].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[15].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[15].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[15].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[16].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[16].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[16].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[17].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[17].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[17].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[18].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[18].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[18].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[19].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[19].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[19].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[20].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[20].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[20].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[21].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[21].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[21].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[22].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[22].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[22].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[23].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[23].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[23].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[24].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[24].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[24].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[25].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[25].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[25].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[26].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[26].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[26].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[27].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[27].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[27].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[28].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[28].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[28].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[29].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[29].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[29].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[30].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[30].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[30].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[31].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[31].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[31].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[32].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[32].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[32].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[33].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[33].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[33].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[34].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[34].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[34].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[35].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[35].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[35].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[36].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[36].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[36].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[37].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[37].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[37].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[38].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[38].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[38].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[39].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[39].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[39].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[40].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[40].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[40].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[41].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[41].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[41].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[42].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[42].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[42].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[43].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[43].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[43].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[44].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[44].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[44].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[45].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[45].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[45].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[46].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[46].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[46].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[47].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[47].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[47].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[48].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[48].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[48].byte2"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[49].byte0"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[49].byte1"
            uint8
            doc "The h/w power at this operational step";
        PARAM "Operational Power Step[49].byte2"
            uint8
            doc "The h/w power at this operational step";
    }

    COMMAND "Tx Power Table For Class 1.5 Devices With FAB ID" 0x0705
    {
        doc "This config item is used only for class 1.5 devices"
            "For class 2 devices, use the RF Attenuation Table item, 0x5E"
            "This command sets the Tx power in dB (signed char) and register values for each power step"
            "Class 1.5 devices may also be configured for class 2 power output levels"
            PARAM "FAB ID"
            uint8
            doc "FAB ID";
        PARAM "Radio Tx power mode"
            uint8
            doc "When set the radio regs will be configured for class 1.5 mode"
            "When cleared the radio regs will be configured for class 2 mode"
            enum
            {
                {0x0, "Class 2 mode"},
                {0x1, "Class 1.5 mode"}
            };
        PARAM "Power table length"
            uint8
            doc "The number of entries in the power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Testmode power table length"
            uint8
            doc "The number of entries in the testmode power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Tx power in dB[0]"
            int8
            doc "The Tx power in dB to report for the corresponding register value";
        PARAM "Register value[0]"
            uint8
            doc "The register value to use for the Tx power at this step";
        PARAM "Tx power in dB[1]"
            int8;
        PARAM "Register value[1]"
            uint8;
        PARAM "Tx power in dB[2]"
            int8;
        PARAM "Register value[2]"
            uint8;
        PARAM "Tx power in dB[3]"
            int8;
        PARAM "Register value[3]"
            uint8;
        PARAM "Tx power in dB[4]"
            int8;
        PARAM "Register value[4]"
            uint8;
        PARAM "Tx power in dB[5]"
            int8;
        PARAM "Register value[5]"
            uint8;
        PARAM "Tx power in dB[6]"
            int8;
        PARAM "Register value[6]"
            uint8;
        PARAM "Tx power in dB[7]"
            int8;
        PARAM "Register value[7]"
            uint8;
        PARAM "Testmode Tx power in dB[0]"
            int8
            doc "The Tx power in dB to report for the corresponding register value";
        PARAM "Testmode register value[0]"
            uint8
            doc "The register value to use for the Tx power at this step";
        PARAM "Testmode Tx power in dB[1]"
            int8;
        PARAM "Testmode register value[1]"
            uint8;
        PARAM "Testmode Tx power in dB[2]"
            int8;
        PARAM "Testmode register value[2]"
            uint8;
        PARAM "Testmode Tx power in dB[3]"
            int8;
        PARAM "Testmode register value[3]"
            uint8;
        PARAM "Testmode Tx power in dB[4]"
            int8;
        PARAM "Testmode register value[4]"
            uint8;
        PARAM "Testmode Tx power in dB[5]"
            int8;
        PARAM "Testmode register value[5]"
            uint8;
        PARAM "Testmode Tx power in dB[6]"
            int8;
        PARAM "Testmode register value[6]"
            uint8;
        PARAM "Testmode Tx power in dB[7]"
            int8;
        PARAM "Testmode register value[7]"
            uint8;
    }

    COMMAND "RFM Trim PPM" 0x0706
    {
        doc "RFM Trim PPM"
            PARAM "RFM Trim PPM"
            int32
            doc "RFM Trim PPM";
    }

    COMMAND "Tssical Parameter Table" 0x0707
    {
        doc "Tssical Parameter tables. Parameters from legacy TCA tables"
            "8-bit minimum temperatures with 6 temperature zones"
            "8-bit binary search range (low, high) of each GFSK, EDR and BLE mode"
            "16-bit Tssi target values of each GFSK, EDR and BLE mode"
            "------------------------------------------------------------------------"
            "UINT8 NumTsteps"
            "UINT8 Tmin[TCA_NUM_TSTEPS_MAX]"
            "UINT8 GfskRangeLow"
            "UINT8 GfskRangeHigh"
            "UINT8 EdrRangeLow"
            "UINT8 EdrRangeHigh"
            "UINT8 BleRangeLow"
            "UINT8 BleRangeHigh"
            "UINT8 NumTssiTarget"
            "UINT16 GfskTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "UINT16 EdrTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "UINT16 BleTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "------------------------------------------------------------------------"
    
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
                 "is actually the desired temperature plus a 50 degree Celsius offset"
                 "For example, a switching point of -5C would be input as 45"
                 "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
                 "therefore switching points should be chosen carefully to avoid"
                 "repeated adjustments around a switching point."
            min = 1
            max = 6;
        # Min. Temp.
        PARAM "Tmin[0]"
            uint8
            doc "Lowest temperature for region plus 50 degrees celsius offset, for"
                "example a value of 1 specifies a temperature range starting at 51"
                "degrees celsius.";
        PARAM "Tmin[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "Tmin[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "Tmin[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "Tmin[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "Tmin[5]"
            uint8
            present_if("Num TSteps" > 5);
    
        # TSSI ranges - GFSK
        PARAM "GfskRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "GfskRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "EdrRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search at EDR mode";
        PARAM "EdrRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search at EDR mode";
        PARAM "BleRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search at BLE mode";
        PARAM "BleRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search at BLE mode";
    
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values per frequency bin";
    
        # TSSI Target Settings - GFSK
        PARAM "GfskTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "GfskTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "GfskTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "GfskTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "GfskTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "GfskTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "GfskTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "GfskTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "GfskTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "GfskTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "GfskTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "GfskTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "GfskTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "GfskTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "GfskTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    
        # TSSI Target Settings - EDR
        PARAM "EdrTarget[0][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "EdrTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "EdrTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "EdrTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "EdrTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "EdrTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "EdrTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "EdrTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "EdrTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "EdrTarget[1][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "EdrTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[2][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "EdrTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[3][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "EdrTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[4][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "EdrTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[5][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "EdrTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    
        # TSSI Target Settings - BLE
        PARAM "BleTarget[0][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "BleTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "BleTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "BleTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "BleTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "BleTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "BleTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "BleTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "BleTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "BleTarget[1][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "BleTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[2][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "BleTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[3][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "BleTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[4][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "BleTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[5][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "BleTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    }

    COMMAND "Tssical Parameter Table TX20" 0x0708
    {
        doc "Tssical Parameter tables. Parameters from legacy TCA tables"
            "8-bit minimum temperatures with 6 temperature zones"
            "8-bit binary search range (low, high) of each GFSK, EDR and BLE mode"
            "16-bit Tssi target values of each GFSK, EDR and BLE mode"
            "------------------------------------------------------------------------"
            "UINT8 NumTsteps"
            "UINT8 Tmin[TCA_NUM_TSTEPS_MAX]"
            "UINT8 GfskRangeLow"
            "UINT8 GfskRangeHigh"
            "UINT8 EdrRangeLow"
            "UINT8 EdrRangeHigh"
            "UINT8 BleRangeLow"
            "UINT8 BleRangeHigh"
            "UINT8 NumTssiTarget"
            "UINT16 GfskTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "UINT16 EdrTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "UINT16 BleTarget[TCA_NUM_TSTEPS_MAX][RFP_NUM_OF_FREQ_BINS_9BIN]"
            "------------------------------------------------------------------------"
    
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
                 "is actually the desired temperature plus a 50 degree Celsius offset"
                 "For example, a switching point of -5C would be input as 45"
                 "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
                 "therefore switching points should be chosen carefully to avoid"
                 "repeated adjustments around a switching point."
            min = 1
            max = 6;
        # Min. Temp.
        PARAM "Tmin[0]"
            uint8
            doc "Lowest temperature for region plus 50 degrees celsius offset, for"
                "example a value of 1 specifies a temperature range starting at 51"
                "degrees celsius.";
        PARAM "Tmin[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "Tmin[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "Tmin[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "Tmin[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "Tmin[5]"
            uint8
            present_if("Num TSteps" > 5);
    
        # TSSI ranges - GFSK
        PARAM "GfskRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "GfskRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "EdrRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search at EDR mode";
        PARAM "EdrRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search at EDR mode";
        PARAM "BleRangeLow"
            uint8
            doc "Value of the low endpoint for the PA gain binary search at BLE mode";
        PARAM "BleRangeHigh"
            uint8
            doc "Value of the high endpoint for the PA gain binary search at BLE mode";
    
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values per frequency bin";
    
        # TSSI Target Settings - GFSK
        PARAM "GfskTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "GfskTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "GfskTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "GfskTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "GfskTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "GfskTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "GfskTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "GfskTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "GfskTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "GfskTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "GfskTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "GfskTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "GfskTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "GfskTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "GfskTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "GfskTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "GfskTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "GfskTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "GfskTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "GfskTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "GfskTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "GfskTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "GfskTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    
        # TSSI Target Settings - EDR
        PARAM "EdrTarget[0][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "EdrTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "EdrTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "EdrTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "EdrTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "EdrTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "EdrTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "EdrTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "EdrTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "EdrTarget[1][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "EdrTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[2][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "EdrTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[3][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "EdrTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[4][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "EdrTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "EdrTarget[5][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "EdrTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "EdrTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "EdrTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "EdrTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "EdrTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "EdrTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "EdrTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "EdrTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    
        # TSSI Target Settings - BLE
        PARAM "BleTarget[0][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "BleTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "BleTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);  
        PARAM "BleTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3); 
        PARAM "BleTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4); 
        PARAM "BleTarget[0][5]"
            uint16
            present_if("Num TssiTargets" > 5); 
        PARAM "BleTarget[0][6]"
            uint16
            present_if("Num TssiTargets" > 6); 
        PARAM "BleTarget[0][7]"
            uint16
            present_if("Num TssiTargets" > 7); 
        PARAM "BleTarget[0][8]"
            uint16
            present_if("Num TssiTargets" > 8); 
        PARAM "BleTarget[1][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "BleTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[1][5]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[1][6]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[1][7]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[1][8]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[2][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "BleTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[2][5]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[2][6]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[2][7]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[2][8]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[3][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "BleTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[3][5]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[3][6]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[3][7]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[3][8]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[4][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "BleTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[4][5]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[4][6]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[4][7]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[4][8]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 8));
        PARAM "BleTarget[5][0]"
            uint16
            doc "TSSI target for the BLE PA gain binary search for"
                "the TStep0 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "BleTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "BleTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "BleTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "BleTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
        PARAM "BleTarget[5][5]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 5));
        PARAM "BleTarget[5][6]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 6));
        PARAM "BleTarget[5][7]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 7));
        PARAM "BleTarget[5][8]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 8));
    }

    COMMAND "LE2 TCA Table" 0x0709
    {
        doc "TCA temperature compensation tables for LE2 This format supports"
            "up to 15 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
            PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
            "this device was manufactured. Used to allow variable tuning for"
            "parts from different foundaries in the same products."
            default = 0xff;    
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
            "is actually the desired temperature plus a 50 degree Celsius offset"
            "For example, a switching point of -5C would be input as 45"
            "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
            "therefore switching points should be chosen carefully to avoid"
            "repeated adjustments around a switching point."
            min = 1
            max = 6;
    
    # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
            "Set value either 1 or 5."
            min = 1
            max = 5;
    
        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);            
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);            
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);            
    
        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep1 temperature setting."            
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep4 temperature setting."            
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep5 temperature setting."            
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
    
    
    # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
            "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
            "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);
    
    
    # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 3;
        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 1;
    ######################################################################
    #                              PAGE DESCRIPTORS
    #
    # Legend:
    # Single array index = [Page]
    # Dual array index   = [Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8 - BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0 is reserved for the PA Driver gain control
    # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
    
    
    # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
    
    # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
    
    #######################################################################
    #
    # 16-BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5 
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));  
    #######################################################################
    # PAGE DATA
    #
    # Legend:
    # Triple Array Indices: [TStep][Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8-BIT PAGE DATA
    #
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    
    # 16-BIT PAGE DATA
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    }

    COMMAND "Zigbee TCA Table" 0x070a
    {
        doc "TCA temperature compensation tables for LE2 This format supports"
            "up to 15 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
            PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
            "this device was manufactured. Used to allow variable tuning for"
            "parts from different foundaries in the same products."
            default = 0xff;    
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
            "is actually the desired temperature plus a 50 degree Celsius offset"
            "For example, a switching point of -5C would be input as 45"
            "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
            "therefore switching points should be chosen carefully to avoid"
            "repeated adjustments around a switching point."
            min = 1
            max = 6;
    
    # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
            "Set value either 1 or 5."
            min = 1
            max = 5;
    
        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1); 
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);            
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);            
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);            
    
        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep1 temperature setting."            
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep4 temperature setting."            
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));
    
        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
            "the TStep5 temperature setting."            
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));
    
    
    # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
            "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
            "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);
    
    
    # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 3;
        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 1;
    ######################################################################
    #                              PAGE DESCRIPTORS
    #
    # Legend:
    # Single array index = [Page]
    # Dual array index   = [Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8 - BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0 is reserved for the PA Driver gain control
    # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
    
    
    # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
    
    # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
    
    #######################################################################
    #
    # 16-BIT PAGE DESCRIPTORS
    #
    #######################################################################
    # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5 
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));  
    #######################################################################
    # PAGE DATA
    #
    # Legend:
    # Triple Array Indices: [TStep][Page][Reg]
    #######################################################################
    #######################################################################
    #
    # 8-BIT PAGE DATA
    #
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
    # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
    # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
    
    # 16-BIT PAGE DATA
    #######################################################################
    # TStep 0
    # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 1
    # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 2
    # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 3
    # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 4
    # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    # TStep 5
    # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    }

     COMMAND "ZBSTACK Debug" 0x0800
     {
         doc "Config item code for ZBSTACK debug purpose."
         PARAM "ZBSTACK Debug Flag"
             uint8
             doc "ZBSTACK debug flag";
     }

     COMMAND "I15DOT4 ieee address" 0x0900
     {
         doc "Config item code for 802.15.4 IEEE address."
         PARAM "I15DOT4 ieee address"
             uint8[8]
             doc "I15DOT4 ieee address";
     }

     COMMAND "I15DOT4 bg timer period" 0x0901
     {
         doc "Config item code for the background timer period."
         PARAM "I15DOT4 bg timer period"
             uint32
             doc "I15DOT4 background timer period";
     }

     COMMAND "I15DOT4 context id" 0x0902
     {
         doc "Config item code for the context id."
         PARAM "I15DOT4 context id"
             uint32
             doc "I15DOT4 context id";
     }

     COMMAND "I15DOT4 general config" 0x0903
     {
         doc "Config item code for the general config."
         PARAM "I15DOT4 general config"
             uint32
             doc "I15DOT4 general config";
     }

}
