/*
 * This file has been automatically generated by the WICED 20719-B1 Designer.
 * Bluetooth Application.
 *
 */

/** ex04_ble_bond.c
 *
 */

#include "wiced.h"
#include "wiced_bt_dev.h"
#include "wiced_bt_ble.h"
#include "wiced_bt_uuid.h"
#include "wiced_bt_gatt.h"
#include "wiced_hal_nvram.h"
#include "wiced_hal_gpio.h"
#include "wiced_bt_app_hal_common.h"
#include "wiced_hal_platform.h"
#include "wiced_hal_wdog.h"
#include "wiced_bt_trace.h"
#include "wiced_bt_stack.h"
#include "wiced_bt_sdp.h"
#include "wiced_bt_app_common.h"
#include "sparcommon.h"
#include "string.h"
#include "hci_control_api.h"
#include "wiced_transport.h"
#include "wiced_hal_pspi.h"
#include "ex04_ble_bond_db.h"
#include "wiced_bt_cfg.h"
#include "wiced_rtos.h"
#include "wiced_hal_i2c.h"
#include "wiced_timer.h"

/*******************************************************************
 * Constant Definitions
 ******************************************************************/
#define TRANS_UART_BUFFER_SIZE  1024
#define TRANS_UART_BUFFER_COUNT 2

#define BONDED_BLINK_RATE  (100)
#define BONDING_BLINK_RATE (500)

#define LED_ON  (1)
#define LED_OFF (0)

/* Useful macros for thread priorities */
#define PRIORITY_HIGH               (3)
#define PRIORITY_MEDIUM             (5)
#define PRIORITY_LOW                (7)

/* Sensible stack size for most threads */
#define THREAD_STACK_MIN_SIZE       (500)

/* NVSRAM locations available for application data - NVSRAM Volatile Section Identifier */
#define WICED_NVRAM_LOCAL_KEYS         ( WICED_NVRAM_VSID_START + 1 )
#define WICED_NVRAM_PAIRED_KEYS        ( WICED_NVRAM_LOCAL_KEYS + 1 )

/*******************************************************************
 * Variable Definitions
 ******************************************************************/
extern const wiced_bt_cfg_settings_t wiced_bt_cfg_settings;
extern const wiced_bt_cfg_buf_pool_t wiced_bt_cfg_buf_pools[WICED_BT_CFG_NUM_BUF_POOLS];
// Transport pool for sending RFCOMM data to host
static wiced_transport_buffer_pool_t* transport_pool = NULL;

wiced_timer_t ledBlinkTimer;
uint16_t connection_id = 0;

wiced_thread_t * i2c_thread;

wiced_bool_t bond_mode = WICED_TRUE; // If true we will go into bonding mode. This will be set false if pre-existing bonding info is available

/* Host information saved in  NVRAM */
struct
{
    BD_ADDR   bdaddr;                               /* BD address of the bonded host so we know if we reconnected to the same device */
    uint16_t  cccd;  /* Remember the value of the CCCD (whether notifications were on or off last time we were connected) */
} __attribute__((packed)) hostinfo;

/*******************************************************************
 * Function Prototypes
 ******************************************************************/
static void                   ex04_ble_bond_app_init               ( void );
static wiced_bt_dev_status_t  ex04_ble_bond_management_callback    ( wiced_bt_management_evt_t event, wiced_bt_management_evt_data_t *p_event_data );
static void                   ex04_ble_bond_set_advertisement_data ( void );
static void                   ex04_ble_bond_advertisement_stopped  ( void );
static void                   ex04_ble_bond_reset_device           ( void );
/* GATT Registration Callbacks */
static wiced_bt_gatt_status_t ex04_ble_bond_write_handler          ( wiced_bt_gatt_write_t *p_write_req, uint16_t conn_id );
static wiced_bt_gatt_status_t ex04_ble_bond_read_handler           ( wiced_bt_gatt_read_t *p_read_req, uint16_t conn_id );
static wiced_bt_gatt_status_t ex04_ble_bond_connect_callback       ( wiced_bt_gatt_connection_status_t *p_conn_status );
static wiced_bt_gatt_status_t ex04_ble_bond_server_callback        ( uint16_t conn_id, wiced_bt_gatt_request_type_t type, wiced_bt_gatt_request_data_t *p_data );
static wiced_bt_gatt_status_t ex04_ble_bond_event_handler          ( wiced_bt_gatt_evt_t  event, wiced_bt_gatt_event_data_t *p_event_data );
static uint32_t               hci_control_process_rx_cmd          ( uint8_t* p_data, uint32_t len );
#ifdef HCI_TRACE_OVER_TRANSPORT
static void                   ex04_ble_bond_trace_callback         ( wiced_bt_hci_trace_type_t type, uint16_t length, uint8_t* p_data );
#endif
void ledBlinkCallback(uint32_t arg);
void i2c_read( uint32_t arg );
void button_cback( void *data, uint8_t port_pin );  // Button ISR to enter bonding mode

/*******************************************************************
 * Macro Definitions
 ******************************************************************/
// Macro to extract uint16_t from little-endian byte array
#define LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(byte_array) \
        (uint16_t)( ((byte_array)[0] | ((byte_array)[1] << 8)) )

/*******************************************************************
 * Transport Configuration
 ******************************************************************/
wiced_transport_cfg_t transport_cfg =
{
    WICED_TRANSPORT_UART,              /**< Wiced transport type. */
    {
        WICED_TRANSPORT_UART_HCI_MODE, /**<  UART mode, HCI or Raw */
        HCI_UART_DEFAULT_BAUD          /**<  UART baud rate */
    },
    {
        TRANS_UART_BUFFER_SIZE,        /**<  Rx Buffer Size */
        TRANS_UART_BUFFER_COUNT        /**<  Rx Buffer Count */
    },
    NULL,                              /**< Wiced transport status handler.*/
    hci_control_process_rx_cmd,        /**< Wiced transport receive data handler. */
    NULL                               /**< Wiced transport tx complete callback. */
};

/*******************************************************************
 * GATT Initial Value Arrays
 ******************************************************************/
uint8_t ex04_ble_bond_generic_access_device_name[] = {'k','e','y','_','b','o','n','d'};
uint8_t ex04_ble_bond_generic_access_appearance[]  = {0x00,0x00};
uint8_t ex04_ble_bond_wiced101_led[]               = {0x00};
uint8_t ex04_ble_bond_wiced101_buttons[]           = {0x04,0x00,0x00};
uint8_t ex04_ble_bond_wiced101_buttons_cccd[]      = {0x00,0x00};

/*******************************************************************
 * GATT Lookup Table
 ******************************************************************/

/* GATT attribute lookup table                                */
/* (attributes externally referenced by GATT server database) */
gatt_db_lookup_table ex04_ble_bond_gatt_db_ext_attr_tbl[] =
{
    /* { attribute handle,                       maxlen, curlen, attribute data } */
    {HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE,      8,      8,      ex04_ble_bond_generic_access_device_name},
    {HDLC_GENERIC_ACCESS_APPEARANCE_VALUE,       2,      2,      ex04_ble_bond_generic_access_appearance},
    {HDLC_WICED101_LED_VALUE,                    1,      1,      ex04_ble_bond_wiced101_led},
    {HDLC_WICED101_BUTTONS_VALUE,                3,      3,      ex04_ble_bond_wiced101_buttons},
    {HDLD_WICED101_BUTTONS_CLIENT_CONFIGURATION, 2,      2,      ex04_ble_bond_wiced101_buttons_cccd},
};

// Number of Lookup Table Entries
const uint16_t ex04_ble_bond_gatt_db_ext_attr_tbl_size = ( sizeof ( ex04_ble_bond_gatt_db_ext_attr_tbl ) / sizeof ( gatt_db_lookup_table ) );

/*******************************************************************
 * Function Definitions
 ******************************************************************/

/*
 * Entry point to the application. Set device configuration and start BT
 * stack initialization.  The actual application initialization will happen
 * when stack reports that BT device is ready
 */
void application_start(void)
{
    /* Initialize the transport configuration */
    wiced_transport_init( &transport_cfg );

    /* Initialize Transport Buffer Pool */
    transport_pool = wiced_transport_create_buffer_pool ( TRANS_UART_BUFFER_SIZE, TRANS_UART_BUFFER_COUNT );

#if ((defined WICED_BT_TRACE_ENABLE) || (defined HCI_TRACE_OVER_TRANSPORT))
    /* Set the Debug UART as WICED_ROUTE_DEBUG_NONE to get rid of prints */
    //  wiced_set_debug_uart( WICED_ROUTE_DEBUG_NONE );

    /* Set Debug UART as WICED_ROUTE_DEBUG_TO_PUART to see debug traces on Peripheral UART (PUART) */
    wiced_set_debug_uart( WICED_ROUTE_DEBUG_TO_PUART );

    /* Set the Debug UART as WICED_ROUTE_DEBUG_TO_WICED_UART to send debug strings over the WICED debug interface */
    //wiced_set_debug_uart( WICED_ROUTE_DEBUG_TO_WICED_UART );
#endif

    /* Initialize Bluetooth Controller and Host Stack */
    wiced_bt_stack_init(ex04_ble_bond_management_callback, &wiced_bt_cfg_settings, wiced_bt_cfg_buf_pools);
}

/*
 * This function is executed in the BTM_ENABLED_EVT management callback.
 */
void ex04_ble_bond_app_init(void)
{
    /* These are needed for reading stored keys from NVRAM */
    wiced_result_t              result;
    wiced_bt_device_link_keys_t link_keys;
    uint8_t                     *p;

    /* Initialize Application */
    wiced_bt_app_init();

    /* Configure the Button GPIO as an input with a resistive pull up and interrupt on rising edge */
    wiced_hal_gpio_register_pin_for_interrupt( WICED_GPIO_PIN_BUTTON_1, button_cback, NULL );
    wiced_hal_gpio_configure_pin( WICED_GPIO_PIN_BUTTON_1, ( GPIO_INPUT_ENABLE | GPIO_PULL_UP | GPIO_EN_INT_FALLING_EDGE ), GPIO_PIN_OUTPUT_HIGH );

    /* Start a thread to read button values */
     i2c_thread = wiced_rtos_create_thread();       // Get memory for the thread handle
     wiced_rtos_init_thread(
             i2c_thread,                     // Thread handle
             PRIORITY_MEDIUM,                // Priority
             "Buttons",                      // Name
             i2c_read,                       // Function
             THREAD_STACK_MIN_SIZE,          // Stack
             NULL );                         // Function argument

    /* Allow peer to pair */
    wiced_bt_set_pairable_mode(WICED_TRUE, 0);

    /* Set Advertisement Data */
    ex04_ble_bond_set_advertisement_data();

    /* Load the address resolution DB with the keys stored in the NVRAM */
    /* If no client has bonded previously, then this read will fail */
    memset( &link_keys, 0, sizeof(wiced_bt_device_link_keys_t));
    p = (uint8_t*)&link_keys;
    wiced_hal_read_nvram( WICED_NVRAM_PAIRED_KEYS, sizeof(wiced_bt_device_link_keys_t), p, &result);
    if(result == WICED_BT_SUCCESS)
    {
        result = wiced_bt_dev_add_device_to_address_resolution_db ( &link_keys );
        WICED_BT_TRACE("\tRead paired keys from NVSRAM and add to address resolution %B result:%d \r\n", p, result );
        bond_mode = WICED_FALSE; /* We have bonding information already, so don't go into bonding mode */
    }

    /* Register with stack to receive GATT callback */
    wiced_bt_gatt_register( ex04_ble_bond_event_handler );

    /* Initialize GATT Database */
    wiced_bt_gatt_db_init( gatt_database, gatt_database_len );

    /* Initialize timer that will blink LED during advertising - speed depends on if we are bonded or not */
    wiced_init_timer(&ledBlinkTimer, ledBlinkCallback, 0, WICED_MILLI_SECONDS_PERIODIC_TIMER);
    wiced_start_timer(&ledBlinkTimer, bond_mode ? BONDING_BLINK_RATE : BONDED_BLINK_RATE);

    /* Start Undirected LE Advertisements on device startup.
     * The corresponding parameters are contained in 'wiced_bt_cfg.c' */
    /* TODO: Make sure that this is the desired behavior. */
    wiced_bt_start_advertisements(BTM_BLE_ADVERT_UNDIRECTED_HIGH, 0, NULL);
}

/* Set Advertisement Data */
void ex04_ble_bond_set_advertisement_data( void )
{
    wiced_bt_ble_advert_elem_t adv_elem[3] = { 0 };
    uint8_t adv_flag = BTM_BLE_GENERAL_DISCOVERABLE_FLAG | BTM_BLE_BREDR_NOT_SUPPORTED;
    uint8_t num_elem = 0; 
    uint8_t wiced101_service_uuid[LEN_UUID_128] = { __UUID_WICED101 };

    /* Advertisement Element for Flags */
    adv_elem[num_elem].advert_type = BTM_BLE_ADVERT_TYPE_FLAG;
    adv_elem[num_elem].len = sizeof(uint8_t);
    adv_elem[num_elem].p_data = &adv_flag;
    num_elem++;

    /* Advertisement Element for Name */
    adv_elem[num_elem].advert_type = BTM_BLE_ADVERT_TYPE_NAME_COMPLETE;
    adv_elem[num_elem].len = strlen((const char*)BT_LOCAL_NAME);
    adv_elem[num_elem].p_data = BT_LOCAL_NAME;
    num_elem++;

    /* Advertisement Element for Wiced101 Service */
    adv_elem[num_elem].advert_type = BTM_BLE_ADVERT_TYPE_128SRV_COMPLETE;
    adv_elem[num_elem].len = LEN_UUID_128;
    adv_elem[num_elem].p_data = wiced101_service_uuid;
    num_elem++;

    /* Set Raw Advertisement Data */
    wiced_bt_ble_set_raw_advertisement_data(num_elem, adv_elem);
}

/* This function is invoked when advertisements stop */
void ex04_ble_bond_advertisement_stopped( void )
{
    WICED_BT_TRACE("Advertisement stopped\n");

    /* TODO: Handle when advertisements stop */
    if(0 == connection_id) /* Not connected */
    {
        wiced_hal_gpio_set_pin_output(WICED_GPIO_PIN_LED_1, LED_OFF);
    }
    else
    {
        wiced_hal_gpio_set_pin_output(WICED_GPIO_PIN_LED_1, LED_ON);
    }
}

/* TODO: This function should be called when the device needs to be reset */
void ex04_ble_bond_reset_device( void )
{
    /* TODO: Clear any additional persistent values used by the application from NVRAM */

    // Reset the device
    wiced_hal_wdog_reset_system( );
}

/* Bluetooth Management Event Handler */
wiced_bt_dev_status_t ex04_ble_bond_management_callback( wiced_bt_management_evt_t event, wiced_bt_management_evt_data_t *p_event_data )
{
    wiced_bt_dev_status_t status = WICED_BT_SUCCESS;
    wiced_bt_device_address_t bda = { 0 };
    wiced_bt_dev_ble_pairing_info_t *p_ble_info = NULL;
    wiced_bt_ble_advert_mode_t *p_adv_mode = NULL;

    uint8_t counter;
    uint8_t bytes;

    WICED_BT_TRACE("*********************** BLE Stack Management Callback Event: %d ***********************\n", event );

    switch (event)
    {
    case BTM_ENABLED_EVT:
        /* Bluetooth Controller and Host Stack Enabled */

#ifdef HCI_TRACE_OVER_TRANSPORT
        // There is a virtual HCI interface between upper layers of the stack and
        // the controller portion of the chip with lower layers of the BT stack.
        // Register with the stack to receive all HCI commands, events and data.
        wiced_bt_dev_register_hci_trace(ex04_ble_bond_trace_callback);
#endif

        WICED_BT_TRACE("Bluetooth Enabled (%s)\n",
                ((WICED_BT_SUCCESS == p_event_data->enabled.status) ? "success" : "failure"));

        if (WICED_BT_SUCCESS == p_event_data->enabled.status)
        {
            /* Bluetooth is enabled */
            wiced_bt_dev_read_local_addr(bda);
            WICED_BT_TRACE("Local Bluetooth Address: [%B]\n", bda);

            /* Perform application-specific initialization */
            ex04_ble_bond_app_init();
        }
        break;
    case BTM_DISABLED_EVT:
        /* Bluetooth Controller and Host Stack Disabled */
        WICED_BT_TRACE("Bluetooth Disabled\n");
        break;
    case BTM_SECURITY_REQUEST_EVT:
        /* Security Request */
        /* Only grant if we are in bonding mode */
        if(bond_mode == WICED_TRUE)
        {
            WICED_BT_TRACE("Security Request Granted\n");
            wiced_bt_ble_security_grant(p_event_data->security_request.bd_addr, WICED_BT_SUCCESS);
        }
        else
        {
            WICED_BT_TRACE("Security Request Denied - not in bonding mode\n");
        }
        break;
    case BTM_PAIRING_IO_CAPABILITIES_BLE_REQUEST_EVT:
        /* Request for Pairing IO Capabilities (BLE) */
        WICED_BT_TRACE("BLE Pairing IO Capabilities Request\n");
        /* No IO Capabilities on this Platform */
        p_event_data->pairing_io_capabilities_ble_request.local_io_cap = BTM_IO_CAPABILITIES_NONE;
        p_event_data->pairing_io_capabilities_ble_request.oob_data = BTM_OOB_NONE;
        p_event_data->pairing_io_capabilities_ble_request.auth_req = BTM_LE_AUTH_REQ_SC_MITM_BOND;
        p_event_data->pairing_io_capabilities_ble_request.max_key_size = 0x10;
        p_event_data->pairing_io_capabilities_ble_request.init_keys = BTM_LE_KEY_PENC|BTM_LE_KEY_PID;
        p_event_data->pairing_io_capabilities_ble_request.resp_keys = BTM_LE_KEY_PENC|BTM_LE_KEY_PID;
        break;
    case BTM_PAIRING_COMPLETE_EVT:
        /* Pairing is Complete */
        p_ble_info = &p_event_data->pairing_complete.pairing_complete_info.ble;
        WICED_BT_TRACE("Pairing Complete %d.\n", p_ble_info->reason);

        /* Now that pairing is complete, we will save the BDADR of the host to NVRAM */
        /* Note that the .bdaddr was captured in the GATT connect callback function */
        if ( p_ble_info->reason == WICED_BT_SUCCESS ) /* Bonding successful */
        {
            /* Write to NVRAM */
            wiced_hal_write_nvram( WICED_NVRAM_VSID_START, sizeof(hostinfo), (uint8_t*)&hostinfo, &status );
            WICED_BT_TRACE("\tBonding info save to NVRAM: %B\n\r", &hostinfo);
            bond_mode = WICED_FALSE; // remember that the device is now bonded
        }
        break;
    case BTM_ENCRYPTION_STATUS_EVT:
        /* Encryption Status Change */
        WICED_BT_TRACE("Encryption Status event: bd ( %B ) res %d\n", p_event_data->encryption_status.bd_addr, p_event_data->encryption_status.result);

        /* Connection has been encrypted and we are already bonded meaning that we have correct/paired device restore values in the database */
        if(bond_mode == WICED_FALSE)
        {
            wiced_hal_read_nvram( WICED_NVRAM_VSID_START, sizeof(hostinfo), (uint8_t*)&hostinfo, &(p_event_data->encryption_status.result) );
            /* Set CCCD value from the value that was previously saved in the NVRAM */
            ex04_ble_bond_wiced101_buttons_cccd[0] = hostinfo.cccd;
            WICED_BT_TRACE("\tRestored existing bonded device info from NVRAM %B result: %d \n\r", hostinfo.bdaddr);
        }
        break;
    case BTM_PAIRED_DEVICE_LINK_KEYS_UPDATE_EVT:
        /* save keys to NVRAM if the link is encrypted */
        WICED_BT_TRACE( "Paired Device Key Update\n\r");
        wiced_hal_write_nvram ( WICED_NVRAM_PAIRED_KEYS, sizeof( wiced_bt_device_link_keys_t ), (uint8_t*)&(p_event_data->paired_device_link_keys_update), &status );
        WICED_BT_TRACE("\tKeys save to NVRAM %B result: %d \n\r", (uint8_t*)&(p_event_data->paired_device_link_keys_update), status);

        break;
    case BTM_PAIRED_DEVICE_LINK_KEYS_REQUEST_EVT:
        /* Paired Device Link Keys Request */
        WICED_BT_TRACE("Paired Device Link Request Keys Event for device %B\n",&(p_event_data->paired_device_link_keys_request));
        /* Device/app-specific TODO: HANDLE PAIRED DEVICE LINK REQUEST KEY - retrieve from NVRAM, etc */
        /* read keys from NVRAM */
        /* If the status from read_nvram is not SUCCESS, the stack will generate keys and will then call BTM_PAIRED_DEVICE_LINK_KEYS_UPDATE_EVT so that they can be stored */
        wiced_hal_read_nvram( WICED_NVRAM_PAIRED_KEYS, sizeof(wiced_bt_device_link_keys_t), (uint8_t *) &(p_event_data->paired_device_link_keys_request), &status );
        WICED_BT_TRACE("\tKeys read from NVRAM %B result: %d \n\r", &(p_event_data->paired_device_link_keys_request), status);
        break;
    case BTM_LOCAL_IDENTITY_KEYS_UPDATE_EVT: /* Update of local privacy keys - save to NVSRAM */
            WICED_BT_TRACE( "Local Identity Key Update\n\r");
            bytes = wiced_hal_write_nvram ( WICED_NVRAM_LOCAL_KEYS, sizeof( wiced_bt_local_identity_keys_t ), (uint8_t*)&(p_event_data->local_identity_keys_update), &status );
            /* Result is the number of bytes written */
            WICED_BT_TRACE("\tlocal keys save to NVRAM:\n\r");
            for(counter = 0; counter<bytes;counter++)
            {
                WICED_BT_TRACE("%02X ", p_event_data->local_identity_keys_update.local_key_data[counter]);
                if(counter % 16 == 0)
                {
                    WICED_BT_TRACE("\n\r");
                }
            }
            WICED_BT_TRACE("result: %d \n\r", status);
            break;
    case BTM_LOCAL_IDENTITY_KEYS_REQUEST_EVT: /* Request for local privacy keys - read from NVSRAM */
        WICED_BT_TRACE( "Local Identity Key Request\n\r");
        /* If the status from read_nvram is not SUCCESS, the stack will generate keys and will then call BTM_LOCAL_IDENTITY_KEYS_UPDATE_EVT so that they can be stored */
        bytes = wiced_hal_read_nvram( WICED_NVRAM_LOCAL_KEYS, sizeof(wiced_bt_local_identity_keys_t), (uint8_t *)&(p_event_data->local_identity_keys_request), &status );
        /* Result is the number of bytes read */
        WICED_BT_TRACE("\tlocal keys read from NVRAM:\n\r");
        for(counter = 0; counter<bytes;counter++)
        {
            WICED_BT_TRACE("%02X ", p_event_data->local_identity_keys_request.local_key_data[counter]);
            if(counter % 16 == 0)
            {
                WICED_BT_TRACE("\n\r");
            }
        }
        WICED_BT_TRACE("result: %d \n\r", status);
        break;
    case BTM_BLE_ADVERT_STATE_CHANGED_EVT:
        /* Advertisement State Changed */
        p_adv_mode = &p_event_data->ble_advert_state_changed;
        WICED_BT_TRACE("Advertisement State Change: %d\n", *p_adv_mode);
        if ( BTM_BLE_ADVERT_OFF == *p_adv_mode )
        {
            ex04_ble_bond_advertisement_stopped();
        }
        break;
    case BTM_USER_CONFIRMATION_REQUEST_EVT:
        /* Pairing request, TODO: handle confirmation of numeric compare here if desired */
        WICED_BT_TRACE("numeric_value: %d\n", p_event_data->user_confirmation_request.numeric_value);
        wiced_bt_dev_confirm_req_reply( WICED_BT_SUCCESS , p_event_data->user_confirmation_request.bd_addr);
        break;
    default:
        WICED_BT_TRACE("Unhandled Bluetooth Management Event: 0x%x (%d)\n", event, event);
        break;
    }

    return status;
}

/* Get a Value */
wiced_bt_gatt_status_t ex04_ble_bond_get_value( uint16_t attr_handle, uint16_t conn_id, uint8_t *p_val, uint16_t max_len, uint16_t *p_len )
{
    int i = 0;
    wiced_bool_t isHandleInTable = WICED_FALSE;
    wiced_bt_gatt_status_t res = WICED_BT_GATT_INVALID_HANDLE;

    // Check for a matching handle entry
    for (i = 0; i < ex04_ble_bond_gatt_db_ext_attr_tbl_size; i++)
    {
        if (ex04_ble_bond_gatt_db_ext_attr_tbl[i].handle == attr_handle)
        {
            // Detected a matching handle in external lookup table
            isHandleInTable = WICED_TRUE;
            // Detected a matching handle in the external lookup table
            if (ex04_ble_bond_gatt_db_ext_attr_tbl[i].cur_len <= max_len)
            {
                // Value fits within the supplied buffer; copy over the value
                *p_len = ex04_ble_bond_gatt_db_ext_attr_tbl[i].cur_len;
                memcpy(p_val, ex04_ble_bond_gatt_db_ext_attr_tbl[i].p_data, ex04_ble_bond_gatt_db_ext_attr_tbl[i].cur_len);
                res = WICED_BT_GATT_SUCCESS;

                // TODO: Add code for any action required when this attribute is read
                switch ( attr_handle )
                {
                case HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE:
                    break;
                case HDLC_GENERIC_ACCESS_APPEARANCE_VALUE:
                    break;
                case HDLC_WICED101_BUTTONS_VALUE:
                    break;
                }
            }
            else
            {
                // Value to read will not fit within the buffer
                res = WICED_BT_GATT_INVALID_ATTR_LEN;
            }
            break;
        }
    }

    if (!isHandleInTable)
    {
        // TODO: Add code to read value using handles not contained within external lookup table
        // This can apply when the option is enabled to not generate initial value arrays.
        // If the value for the current handle is successfully read then set the result using:
        // res = WICED_BT_GATT_SUCCESS;
        switch ( attr_handle )
        {
        default:
            // The read operation was not performed for the indicated handle
            WICED_BT_TRACE("Read Request to Invalid Handle: 0x%x\n", attr_handle);
            res = WICED_BT_GATT_READ_NOT_PERMIT;
            break;
        }
    }

    return res;
}

/* Set a Value */
wiced_bt_gatt_status_t ex04_ble_bond_set_value( uint16_t attr_handle, uint16_t conn_id, uint8_t *p_val, uint16_t len )
{
    int i = 0;
    wiced_bool_t isHandleInTable = WICED_FALSE;
    wiced_bool_t validLen = WICED_FALSE;
    wiced_bt_gatt_status_t res = WICED_BT_GATT_INVALID_HANDLE;

    // Check for a matching handle entry
    for (i = 0; i < ex04_ble_bond_gatt_db_ext_attr_tbl_size; i++)
    {
        if (ex04_ble_bond_gatt_db_ext_attr_tbl[i].handle == attr_handle)
        {
            // Detected a matching handle in external lookup table
            isHandleInTable = WICED_TRUE;
            // Verify that size constraints have been met
            validLen = (ex04_ble_bond_gatt_db_ext_attr_tbl[i].max_len >= len);
            if (validLen)
            {
                // Value fits within the supplied buffer; copy over the value
                ex04_ble_bond_gatt_db_ext_attr_tbl[i].cur_len = len;
                memcpy(ex04_ble_bond_gatt_db_ext_attr_tbl[i].p_data, p_val, len);
                res = WICED_BT_GATT_SUCCESS;

                // TODO: Add code for any action required when this attribute is written
                // For example you may need to write the value into NVRAM if it needs to be persistent
                switch ( attr_handle )
                {
                case HDLC_WICED101_LED_VALUE:
                    /* Turn the LED on/off depending on the value written to the GATT database */
                    WICED_BT_TRACE("Output = %d\n", ex04_ble_bond_wiced101_led[0]);
                    wiced_hal_gpio_set_pin_output(WICED_GPIO_PIN_LED_2, ex04_ble_bond_wiced101_led[0]);
                    break;
                case HDLD_WICED101_BUTTONS_CLIENT_CONFIGURATION:
                    if ( len != 2 )
                    {
                        return WICED_BT_GATT_INVALID_ATTR_LEN;
                    }
                    hostinfo.cccd = p_val[0] | ( p_val[1] << 8 );

                    /* Save value to NVRAM */
                    wiced_result_t temp_result;
                    wiced_hal_write_nvram( WICED_NVRAM_VSID_START, sizeof(hostinfo), (uint8_t*)&hostinfo, &temp_result );
                    WICED_BT_TRACE("\t\tWrite CCCD value to NVRAM\n\r");
                    break;
                }
            }
            else
            {
                // Value to write does not meet size constraints
                res = WICED_BT_GATT_INVALID_ATTR_LEN;
            }
            break;
        }
    }

    if (!isHandleInTable)
    {
        // TODO: Add code to write value using handles not contained within external lookup table
        // This can apply when the option is enabled to not generate initial value arrays.
        // If the value for the current handle is successfully written then set the result using:
        // res = WICED_BT_GATT_SUCCESS;
        switch ( attr_handle )
        {
        default:
            // The write operation was not performed for the indicated handle
            WICED_BT_TRACE("Write Request to Invalid Handle: 0x%x\n", attr_handle);
            res = WICED_BT_GATT_WRITE_NOT_PERMIT;
            break;
        }
    }

    return res;
}

/* Handles Write Requests received from Client device */
wiced_bt_gatt_status_t ex04_ble_bond_write_handler( wiced_bt_gatt_write_t *p_write_req, uint16_t conn_id )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_INVALID_HANDLE;

    /* Attempt to perform the Write Request */
    status = ex04_ble_bond_set_value(p_write_req->handle, conn_id, p_write_req->p_val, p_write_req->val_len);

    return status;
}

/* Handles Read Requests received from Client device */
wiced_bt_gatt_status_t ex04_ble_bond_read_handler( wiced_bt_gatt_read_t *p_read_req, uint16_t conn_id )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_INVALID_HANDLE;

    /* Attempt to perform the Read Request */
    status = ex04_ble_bond_get_value(p_read_req->handle, conn_id, p_read_req->p_val, *p_read_req->p_val_len, p_read_req->p_val_len);

    return status;
}

/* GATT Connection Status Callback */
wiced_bt_gatt_status_t ex04_ble_bond_connect_callback( wiced_bt_gatt_connection_status_t *p_conn_status )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;

    if ( NULL != p_conn_status )
    {
        if ( p_conn_status->connected )
        {
            // Device has connected
            WICED_BT_TRACE("Connected : BDA '%B', Connection ID '%d'\n", p_conn_status->bd_addr, p_conn_status->conn_id );

            /* TODO: Handle the connection */
            connection_id = p_conn_status->conn_id;

            /* Copy address of connected device to the hostinfo structure to be saved in NVRAM when pairing is complete */
            memcpy(hostinfo.bdaddr, p_conn_status->bd_addr, sizeof(BD_ADDR));
        }
        else
        {
            // Device has disconnected
            WICED_BT_TRACE("Disconnected : BDA '%B', Connection ID '%d', Reason '%d'\n", p_conn_status->bd_addr, p_conn_status->conn_id, p_conn_status->reason );

            /* TODO: Handle the disconnection */
            /* Clear the connection ID and the bdaddr of the remote */
            connection_id = 0;
            memset( hostinfo.bdaddr, 0, sizeof(BD_ADDR));
            /* Reset the CCCD value so that on a reconnect CCCD will be off */
            ex04_ble_bond_wiced101_buttons_cccd[0] = 0;

            /* set timer to correct speed depending on bond_mode and restart the advertisements */
            wiced_stop_timer(&ledBlinkTimer);
            wiced_start_timer(&ledBlinkTimer, bond_mode ? BONDING_BLINK_RATE : BONDED_BLINK_RATE);
            wiced_bt_start_advertisements(BTM_BLE_ADVERT_UNDIRECTED_HIGH, 0, NULL);
        }
        status = WICED_BT_GATT_SUCCESS;
    }

    return status;
}

/* GATT Server Event Callback */
wiced_bt_gatt_status_t ex04_ble_bond_server_callback( uint16_t conn_id, wiced_bt_gatt_request_type_t type, wiced_bt_gatt_request_data_t *p_data )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;

    switch ( type )
    {
    case GATTS_REQ_TYPE_READ:
        status = ex04_ble_bond_read_handler( &p_data->read_req, conn_id );
        break;
    case GATTS_REQ_TYPE_WRITE:
        status = ex04_ble_bond_write_handler( &p_data->write_req, conn_id );
        break;
    }

    return status;
}

/* GATT Event Handler */
wiced_bt_gatt_status_t ex04_ble_bond_event_handler( wiced_bt_gatt_evt_t event, wiced_bt_gatt_event_data_t *p_event_data )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;
    wiced_bt_gatt_connection_status_t *p_conn_status = NULL;
    wiced_bt_gatt_attribute_request_t *p_attr_req = NULL;

    WICED_BT_TRACE("****************** BLE GATT Callback Event: %d ******************\n", event );

    switch ( event )
    {
    case GATT_CONNECTION_STATUS_EVT:
        status = ex04_ble_bond_connect_callback( &p_event_data->connection_status );
        break;
    case GATT_ATTRIBUTE_REQUEST_EVT:
        p_attr_req = &p_event_data->attribute_request;
        status = ex04_ble_bond_server_callback( p_attr_req->conn_id, p_attr_req->request_type, &p_attr_req->data );
        break;
    default:
        status = WICED_BT_GATT_SUCCESS;
        break;
    }

    return status;
}


/* Handle Command Received over Transport */
uint32_t hci_control_process_rx_cmd( uint8_t* p_data, uint32_t len )
{
    uint8_t status = 0;
    uint8_t cmd_status = HCI_CONTROL_STATUS_SUCCESS;
    uint8_t opcode = 0;
    uint8_t* p_payload_data = NULL;
    uint8_t payload_length = 0;

    WICED_BT_TRACE("hci_control_process_rx_cmd : Data Length '%d'\n", len);

    // At least 4 bytes are expected in WICED Header
    if ((NULL == p_data) || (len < 4))
    {
        WICED_BT_TRACE("Invalid Parameters\n");
        status = HCI_CONTROL_STATUS_INVALID_ARGS;
    }
    else
    {
        // Extract OpCode and Payload Length from little-endian byte array
        opcode = LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(p_data);
        payload_length = LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(&p_data[sizeof(uint16_t)]);
        p_payload_data = &p_data[sizeof(uint16_t)*2];

        // TODO : Process received HCI Command based on its Control Group
        // (see 'hci_control_api.h' for additional details)
        switch ( HCI_CONTROL_GROUP(opcode) )
        {
        default:
            // HCI Control Group was not handled
            cmd_status = HCI_CONTROL_STATUS_UNKNOWN_GROUP;
            wiced_transport_send_data(HCI_CONTROL_EVENT_COMMAND_STATUS, &cmd_status, sizeof(cmd_status));
            break;
        }
    }

    // When operating in WICED_TRANSPORT_UART_HCI_MODE or WICED_TRANSPORT_SPI,
    // application has to free buffer in which data was received
    wiced_transport_free_buffer( p_data );
    p_data = NULL;

    return status;
}

#ifdef HCI_TRACE_OVER_TRANSPORT
/* Handle Sending of Trace over the Transport */
void ex04_ble_bond_trace_callback( wiced_bt_hci_trace_type_t type, uint16_t length, uint8_t* p_data )
{
    wiced_transport_send_hci_trace( transport_pool, type, length, p_data );
}
#endif

/* Invert LED state when the timer expires if we are advertising to cause the LED to blink */
void ledBlinkCallback(uint32_t arg)
{
    if(0 != wiced_bt_ble_get_current_advert_mode()) /* Advertising */
    {
        wiced_hal_gpio_set_pin_output(WICED_GPIO_PIN_LED_1, !wiced_hal_gpio_get_pin_output( WICED_GPIO_PIN_LED_1 ));
    }
}

/* Thread function to read button values from PSoC */
void i2c_read( uint32_t arg )
{
    /* Thread will delay so that button values are read every 100ms */
    #define THREAD_DELAY_IN_MS          (100)

    /* I2C address and register locations inside the PSoC and a mask for just CapSense buttons */
    #define I2C_ADDRESS        (0x42)
    #define BUTTON_REG         (0x06)
    #define CAPSENSE_MASK      (0x0F)

    char i2cReg;               // I2C Read register
    char buttonVal;            // Button value
    char prevVal = 0x00;       // Previous button value

    /* Configure I2C block */
    wiced_hal_i2c_init();
    wiced_hal_i2c_set_speed( I2CM_SPEED_400KHZ );

    /* Write the offset to allow reading of the button register */
    i2cReg = BUTTON_REG;
    wiced_hal_i2c_write( &i2cReg , sizeof( i2cReg ), I2C_ADDRESS );

    for(;;)
    {
        /* Read button values and mask out just the CapSense buttons */
        wiced_hal_i2c_read( &i2cReg , sizeof( i2cReg ), I2C_ADDRESS );
        buttonVal = i2cReg & CAPSENSE_MASK;

        if(prevVal != buttonVal) /* Only print if value has changed since last time */
        {
            WICED_BT_TRACE( "Button State: %02X\n\r", buttonVal);
            ex04_ble_bond_wiced101_buttons[2] = buttonVal;
            /* If the connection is up and if the client wants notifications, send it */
            if ( connection_id != 0)
            {
                 if(ex04_ble_bond_wiced101_buttons_cccd[0] & GATT_CLIENT_CONFIG_NOTIFICATION)
                {
                    wiced_bt_gatt_send_notification(connection_id, HDLC_WICED101_BUTTONS_VALUE, sizeof(ex04_ble_bond_wiced101_buttons), ex04_ble_bond_wiced101_buttons );
                    WICED_BT_TRACE( "\tSend Notification: sending CapSense value\r\n");
                }
            }
            prevVal = buttonVal;
        }
        /* Send the thread to sleep for a period of time */
        wiced_rtos_delay_milliseconds( THREAD_DELAY_IN_MS, ALLOW_THREAD_TO_SLEEP );
    }
}

/* Interrupt callback function for BUTTON_1  - remove existing bonding info and put into bonding mode */
void button_cback( void *data, uint8_t port_pin )
{
    wiced_result_t                  result;
    wiced_bt_device_link_keys_t     link_keys;
    wiced_bt_local_identity_keys_t  local_keys;
    BD_ADDR                         bonded_address;

    /* Put into bonding mode  */
    bond_mode = WICED_TRUE;

    /* Remove from the bonded device list */
    wiced_hal_read_nvram( WICED_NVRAM_VSID_START, sizeof(bonded_address), (uint8_t*)&bonded_address, &result );
    wiced_bt_dev_delete_bonded_device(bonded_address);
    WICED_BT_TRACE( "Remove host %B from bonded device list \n\r", bonded_address );
    WICED_BT_TRACE( "Bonding information removed\n\r" );

    /* Remove device from address resolution database */
    wiced_hal_read_nvram( WICED_NVRAM_PAIRED_KEYS, sizeof(wiced_bt_device_link_keys_t), (uint8_t*)&link_keys, &result);
    wiced_bt_dev_remove_device_from_address_resolution_db ( &link_keys );

    /* Remove bonding information from NVRAM */
    memset( &hostinfo, 0, sizeof(hostinfo));
    memset( &link_keys, 0, sizeof(wiced_bt_device_link_keys_t));
    wiced_hal_write_nvram( WICED_NVRAM_VSID_START, sizeof(hostinfo), (uint8_t*)&hostinfo, &result );
    wiced_hal_write_nvram ( WICED_NVRAM_PAIRED_KEYS, sizeof( wiced_bt_device_link_keys_t ), (uint8_t*)&link_keys, &result );

    /* Restart timer with correct speed */
    wiced_stop_timer(&ledBlinkTimer);
    wiced_start_timer(&ledBlinkTimer, BONDING_BLINK_RATE);


    /* Clear the GPIO interrupt */
    wiced_hal_gpio_clear_pin_interrupt_status( WICED_GPIO_PIN_BUTTON_1 );
}

